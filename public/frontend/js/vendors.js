/*! For license information please see vendors.js.LICENSE.txt */
(self.webpackChunkfrontend = self.webpackChunkfrontend || []).push([
  [730],
  {
    689: function (t, e, i) {
      "use strict";
      i.d(e, {
        KR: function () {
          return B;
        },
      });
      const s = (t) =>
          "object" == typeof t &&
          null !== t &&
          t.constructor === Object &&
          "[object Object]" === Object.prototype.toString.call(t),
        a = (...t) => {
          let e = !1;
          "boolean" == typeof t[0] && (e = t.shift());
          let i = t[0];
          if (!i || "object" != typeof i) throw new Error("extendee must be an object");
          const n = t.slice(1),
            r = n.length;
          for (let t = 0; t < r; t++) {
            const r = n[t];
            for (let t in r)
              if (r.hasOwnProperty(t)) {
                const n = r[t];
                if (e && (Array.isArray(n) || s(n))) {
                  const e = Array.isArray(n) ? [] : {};
                  i[t] = a(!0, i.hasOwnProperty(t) ? i[t] : e, n);
                } else i[t] = n;
              }
          }
          return i;
        },
        n = (t, e = 1e4) => ((t = parseFloat(t) || 0), Math.round((t + Number.EPSILON) * e) / e),
        r = function (t) {
          return (
            !!(t && "object" == typeof t && t instanceof Element && t !== document.body) &&
            !t.__Panzoom &&
            ((function (t) {
              const e = getComputedStyle(t)["overflow-y"],
                i = getComputedStyle(t)["overflow-x"],
                s = ("scroll" === e || "auto" === e) && Math.abs(t.scrollHeight - t.clientHeight) > 1,
                a = ("scroll" === i || "auto" === i) && Math.abs(t.scrollWidth - t.clientWidth) > 1;
              return s || a;
            })(t)
              ? t
              : r(t.parentNode))
          );
        },
        o =
          ("undefined" != typeof window && window.ResizeObserver) ||
          class {
            constructor(t) {
              (this.observables = []),
                (this.boundCheck = this.check.bind(this)),
                this.boundCheck(),
                (this.callback = t);
            }
            observe(t) {
              if (this.observables.some((e) => e.el === t)) return;
              const e = { el: t, size: { height: t.clientHeight, width: t.clientWidth } };
              this.observables.push(e);
            }
            unobserve(t) {
              this.observables = this.observables.filter((e) => e.el !== t);
            }
            disconnect() {
              this.observables = [];
            }
            check() {
              const t = this.observables
                .filter((t) => {
                  const e = t.el.clientHeight,
                    i = t.el.clientWidth;
                  if (t.size.height !== e || t.size.width !== i) return (t.size.height = e), (t.size.width = i), !0;
                })
                .map((t) => t.el);
              t.length > 0 && this.callback(t), window.requestAnimationFrame(this.boundCheck);
            }
          };
      class l {
        constructor(t) {
          (this.id = self.Touch && t instanceof Touch ? t.identifier : -1),
            (this.pageX = t.pageX),
            (this.pageY = t.pageY),
            (this.clientX = t.clientX),
            (this.clientY = t.clientY);
        }
      }
      const c = (t, e) => (e ? Math.sqrt((e.clientX - t.clientX) ** 2 + (e.clientY - t.clientY) ** 2) : 0),
        h = (t, e) => (e ? { clientX: (t.clientX + e.clientX) / 2, clientY: (t.clientY + e.clientY) / 2 } : t);
      class d {
        constructor(t, { start: e = () => !0, move: i = () => {}, end: s = () => {} } = {}) {
          (this._element = t),
            (this.startPointers = []),
            (this.currentPointers = []),
            (this._pointerStart = (t) => {
              if (t.buttons > 0 && 0 !== t.button) return;
              const e = new l(t);
              this.currentPointers.some((t) => t.id === e.id) ||
                (this._triggerPointerStart(e, t) &&
                  (window.addEventListener("mousemove", this._move),
                  window.addEventListener("mouseup", this._pointerEnd)));
            }),
            (this._touchStart = (t) => {
              for (const e of Array.from(t.changedTouches || [])) this._triggerPointerStart(new l(e), t);
            }),
            (this._move = (t) => {
              const e = this.currentPointers.slice(),
                i = ((t) => "changedTouches" in t)(t) ? Array.from(t.changedTouches).map((t) => new l(t)) : [new l(t)];
              for (const t of i) {
                const e = this.currentPointers.findIndex((e) => e.id === t.id);
                e < 0 || (this.currentPointers[e] = t);
              }
              this._moveCallback(e, this.currentPointers.slice(), t);
            }),
            (this._triggerPointerEnd = (t, e) => {
              const i = this.currentPointers.findIndex((e) => e.id === t.id);
              return !(
                i < 0 ||
                (this.currentPointers.splice(i, 1), this.startPointers.splice(i, 1), this._endCallback(t, e), 0)
              );
            }),
            (this._pointerEnd = (t) => {
              (t.buttons > 0 && 0 !== t.button) ||
                (this._triggerPointerEnd(new l(t), t) &&
                  (window.removeEventListener("mousemove", this._move, { passive: !1 }),
                  window.removeEventListener("mouseup", this._pointerEnd, { passive: !1 })));
            }),
            (this._touchEnd = (t) => {
              for (const e of Array.from(t.changedTouches || [])) this._triggerPointerEnd(new l(e), t);
            }),
            (this._startCallback = e),
            (this._moveCallback = i),
            (this._endCallback = s),
            this._element.addEventListener("mousedown", this._pointerStart, { passive: !1 }),
            this._element.addEventListener("touchstart", this._touchStart, { passive: !1 }),
            this._element.addEventListener("touchmove", this._move, { passive: !1 }),
            this._element.addEventListener("touchend", this._touchEnd),
            this._element.addEventListener("touchcancel", this._touchEnd);
        }
        stop() {
          this._element.removeEventListener("mousedown", this._pointerStart, { passive: !1 }),
            this._element.removeEventListener("touchstart", this._touchStart, { passive: !1 }),
            this._element.removeEventListener("touchmove", this._move, { passive: !1 }),
            this._element.removeEventListener("touchend", this._touchEnd),
            this._element.removeEventListener("touchcancel", this._touchEnd),
            window.removeEventListener("mousemove", this._move),
            window.removeEventListener("mouseup", this._pointerEnd);
        }
        _triggerPointerStart(t, e) {
          return !!this._startCallback(t, e) && (this.currentPointers.push(t), this.startPointers.push(t), !0);
        }
      }
      class u {
        constructor(t = {}) {
          (this.options = a(!0, {}, t)), (this.plugins = []), (this.events = {});
          for (const t of ["on", "once"]) for (const e of Object.entries(this.options[t] || {})) this[t](...e);
        }
        option(t, e, ...i) {
          let s =
            ((a = t = String(t)),
            (n = this.options),
            a.split(".").reduce(function (t, e) {
              return t && t[e];
            }, n));
          var a, n;
          return "function" == typeof s && (s = s.call(this, this, ...i)), void 0 === s ? e : s;
        }
        localize(t, e = []) {
          return (t = String(t).replace(/\{\{(\w+).?(\w+)?\}\}/g, (t, i, s) => {
            let a = "";
            s
              ? (a = this.option(`${i[0] + i.toLowerCase().substring(1)}.l10n.${s}`))
              : i && (a = this.option(`l10n.${i}`)),
              a || (a = t);
            for (let t = 0; t < e.length; t++) a = a.split(e[t][0]).join(e[t][1]);
            return a;
          })).replace(/\{\{(.*)\}\}/, (t, e) => e);
        }
        on(t, e) {
          if (s(t)) {
            for (const e of Object.entries(t)) this.on(...e);
            return this;
          }
          return (
            String(t)
              .split(" ")
              .forEach((t) => {
                const i = (this.events[t] = this.events[t] || []);
                -1 == i.indexOf(e) && i.push(e);
              }),
            this
          );
        }
        once(t, e) {
          if (s(t)) {
            for (const e of Object.entries(t)) this.once(...e);
            return this;
          }
          return (
            String(t)
              .split(" ")
              .forEach((t) => {
                const i = (...s) => {
                  this.off(t, i), e.call(this, this, ...s);
                };
                (i._ = e), this.on(t, i);
              }),
            this
          );
        }
        off(t, e) {
          if (!s(t))
            return (
              t.split(" ").forEach((t) => {
                const i = this.events[t];
                if (!i || !i.length) return this;
                let s = -1;
                for (let t = 0, a = i.length; t < a; t++) {
                  const a = i[t];
                  if (a && (a === e || a._ === e)) {
                    s = t;
                    break;
                  }
                }
                -1 != s && i.splice(s, 1);
              }),
              this
            );
          for (const e of Object.entries(t)) this.off(...e);
        }
        trigger(t, ...e) {
          for (const i of [...(this.events[t] || [])].slice()) if (i && !1 === i.call(this, this, ...e)) return !1;
          for (const i of [...(this.events["*"] || [])].slice()) if (i && !1 === i.call(this, t, this, ...e)) return !1;
          return !0;
        }
        attachPlugins(t) {
          const e = {};
          for (const [i, s] of Object.entries(t || {}))
            !1 === this.options[i] ||
              this.plugins[i] ||
              ((this.options[i] = a({}, s.defaults || {}, this.options[i])), (e[i] = new s(this)));
          for (const [t, i] of Object.entries(e)) i.attach(this);
          return (this.plugins = Object.assign({}, this.plugins, e)), this;
        }
        detachPlugins() {
          for (const t in this.plugins) {
            let e;
            (e = this.plugins[t]) && "function" == typeof e.detach && e.detach(this);
          }
          return (this.plugins = {}), this;
        }
      }
      const p = {
        touch: !0,
        zoom: !0,
        pinchToZoom: !0,
        panOnlyZoomed: !1,
        lockAxis: !1,
        friction: 0.64,
        decelFriction: 0.88,
        zoomFriction: 0.74,
        bounceForce: 0.2,
        baseScale: 1,
        minScale: 1,
        maxScale: 2,
        step: 0.5,
        textSelection: !1,
        click: "toggleZoom",
        wheel: "zoom",
        wheelFactor: 42,
        wheelLimit: 5,
        draggableClass: "is-draggable",
        draggingClass: "is-dragging",
        ratio: 1,
      };
      class g extends u {
        constructor(t, e = {}) {
          super(a(!0, {}, p, e)), (this.state = "init"), (this.$container = t);
          for (const t of ["onLoad", "onWheel", "onClick"]) this[t] = this[t].bind(this);
          this.initLayout(),
            this.resetValues(),
            this.attachPlugins(g.Plugins),
            this.trigger("init"),
            this.updateMetrics(),
            this.attachEvents(),
            this.trigger("ready"),
            !1 === this.option("centerOnStart") ? (this.state = "ready") : this.panTo({ friction: 0 }),
            (t.__Panzoom = this);
        }
        initLayout() {
          const t = this.$container;
          if (!(t instanceof HTMLElement)) throw new Error("Panzoom: Container not found");
          const e = this.option("content") || t.querySelector(".panzoom__content");
          if (!e) throw new Error("Panzoom: Content not found");
          this.$content = e;
          let i = this.option("viewport") || t.querySelector(".panzoom__viewport");
          i ||
            !1 === this.option("wrapInner") ||
            ((i = document.createElement("div")),
            i.classList.add("panzoom__viewport"),
            i.append(...t.childNodes),
            t.appendChild(i)),
            (this.$viewport = i || e.parentNode);
        }
        resetValues() {
          (this.updateRate = this.option(
            "updateRate",
            /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ? 250 : 24
          )),
            (this.container = { width: 0, height: 0 }),
            (this.viewport = { width: 0, height: 0 }),
            (this.content = {
              origWidth: 0,
              origHeight: 0,
              width: 0,
              height: 0,
              x: this.option("x", 0),
              y: this.option("y", 0),
              scale: this.option("baseScale"),
            }),
            (this.transform = { x: 0, y: 0, scale: 1 }),
            this.resetDragPosition();
        }
        onLoad(t) {
          this.updateMetrics(), this.panTo({ scale: this.option("baseScale"), friction: 0 }), this.trigger("load", t);
        }
        onClick(t) {
          if (t.defaultPrevented) return;
          if (document.activeElement && document.activeElement.closest("[contenteditable]")) return;
          if (
            this.option("textSelection") &&
            window.getSelection().toString().length &&
            (!t.target || !t.target.hasAttribute("data-fancybox-close"))
          )
            return void t.stopPropagation();
          const e = this.$content.getClientRects()[0];
          if (
            "ready" !== this.state &&
            (this.dragPosition.midPoint ||
              Math.abs(e.top - this.dragStart.rect.top) > 1 ||
              Math.abs(e.left - this.dragStart.rect.left) > 1)
          )
            return t.preventDefault(), void t.stopPropagation();
          !1 !== this.trigger("click", t) &&
            this.option("zoom") &&
            "toggleZoom" === this.option("click") &&
            (t.preventDefault(), t.stopPropagation(), this.zoomWithClick(t));
        }
        onWheel(t) {
          !1 !== this.trigger("wheel", t) && this.option("zoom") && this.option("wheel") && this.zoomWithWheel(t);
        }
        zoomWithWheel(t) {
          void 0 === this.changedDelta && (this.changedDelta = 0);
          const e = Math.max(-1, Math.min(1, -t.deltaY || -t.deltaX || t.wheelDelta || -t.detail)),
            i = this.content.scale;
          let s = (i * (100 + e * this.option("wheelFactor"))) / 100;
          if (
            ((e < 0 && Math.abs(i - this.option("minScale")) < 0.01) ||
            (e > 0 && Math.abs(i - this.option("maxScale")) < 0.01)
              ? ((this.changedDelta += Math.abs(e)), (s = i))
              : ((this.changedDelta = 0),
                (s = Math.max(Math.min(s, this.option("maxScale")), this.option("minScale")))),
            this.changedDelta > this.option("wheelLimit"))
          )
            return;
          if ((t.preventDefault(), s === i)) return;
          const a = this.$content.getBoundingClientRect(),
            n = t.clientX - a.left,
            r = t.clientY - a.top;
          this.zoomTo(s, { x: n, y: r });
        }
        zoomWithClick(t) {
          const e = this.$content.getClientRects()[0],
            i = t.clientX - e.left,
            s = t.clientY - e.top;
          this.toggleZoom({ x: i, y: s });
        }
        attachEvents() {
          this.$content.addEventListener("load", this.onLoad),
            this.$container.addEventListener("wheel", this.onWheel, { passive: !1 }),
            this.$container.addEventListener("click", this.onClick, { passive: !1 }),
            this.initObserver();
          const t = new d(this.$container, {
            start: (e, i) => {
              if (!this.option("touch")) return !1;
              if (this.velocity.scale < 0) return !1;
              const s = i.composedPath()[0];
              if (!t.currentPointers.length) {
                if (-1 !== ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(s.nodeName)) return !1;
                if (
                  this.option("textSelection") &&
                  ((t, e, i) => {
                    const s = t.childNodes,
                      a = document.createRange();
                    for (let t = 0; t < s.length; t++) {
                      const n = s[t];
                      if (n.nodeType !== Node.TEXT_NODE) continue;
                      a.selectNodeContents(n);
                      const r = a.getBoundingClientRect();
                      if (e >= r.left && i >= r.top && e <= r.right && i <= r.bottom) return n;
                    }
                    return !1;
                  })(s, e.clientX, e.clientY)
                )
                  return !1;
              }
              return (
                !r(s) &&
                !1 !== this.trigger("touchStart", i) &&
                ("mousedown" === i.type && i.preventDefault(),
                (this.state = "pointerdown"),
                this.resetDragPosition(),
                (this.dragPosition.midPoint = null),
                (this.dragPosition.time = Date.now()),
                !0)
              );
            },
            move: (e, i, s) => {
              if ("pointerdown" !== this.state) return;
              if (!1 === this.trigger("touchMove", s)) return void s.preventDefault();
              if (
                i.length < 2 &&
                !0 === this.option("panOnlyZoomed") &&
                this.content.width <= this.viewport.width &&
                this.content.height <= this.viewport.height &&
                this.transform.scale <= this.option("baseScale")
              )
                return;
              if (i.length > 1 && (!this.option("zoom") || !1 === this.option("pinchToZoom"))) return;
              const a = h(e[0], e[1]),
                n = h(i[0], i[1]),
                r = n.clientX - a.clientX,
                o = n.clientY - a.clientY,
                l = c(e[0], e[1]),
                d = c(i[0], i[1]),
                u = l && d ? d / l : 1;
              (this.dragOffset.x += r),
                (this.dragOffset.y += o),
                (this.dragOffset.scale *= u),
                (this.dragOffset.time = Date.now() - this.dragPosition.time);
              const p = 1 === this.dragStart.scale && this.option("lockAxis");
              if (p && !this.lockAxis) {
                if (Math.abs(this.dragOffset.x) < 6 && Math.abs(this.dragOffset.y) < 6) return void s.preventDefault();
                const t = Math.abs((180 * Math.atan2(this.dragOffset.y, this.dragOffset.x)) / Math.PI);
                this.lockAxis = t > 45 && t < 135 ? "y" : "x";
              }
              if ("xy" === p || "y" !== this.lockAxis) {
                if (
                  (s.preventDefault(),
                  s.stopPropagation(),
                  s.stopImmediatePropagation(),
                  this.lockAxis && (this.dragOffset["x" === this.lockAxis ? "y" : "x"] = 0),
                  this.$container.classList.add(this.option("draggingClass")),
                  (this.transform.scale === this.option("baseScale") && "y" === this.lockAxis) ||
                    (this.dragPosition.x = this.dragStart.x + this.dragOffset.x),
                  (this.transform.scale === this.option("baseScale") && "x" === this.lockAxis) ||
                    (this.dragPosition.y = this.dragStart.y + this.dragOffset.y),
                  (this.dragPosition.scale = this.dragStart.scale * this.dragOffset.scale),
                  i.length > 1)
                ) {
                  const e = h(t.startPointers[0], t.startPointers[1]),
                    i = e.clientX - this.dragStart.rect.x,
                    s = e.clientY - this.dragStart.rect.y,
                    { deltaX: a, deltaY: r } = this.getZoomDelta(this.content.scale * this.dragOffset.scale, i, s);
                  (this.dragPosition.x -= a), (this.dragPosition.y -= r), (this.dragPosition.midPoint = n);
                } else this.setDragResistance();
                (this.transform = { x: this.dragPosition.x, y: this.dragPosition.y, scale: this.dragPosition.scale }),
                  this.startAnimation();
              }
            },
            end: (e, i) => {
              if ("pointerdown" !== this.state) return;
              if (((this._dragOffset = { ...this.dragOffset }), t.currentPointers.length))
                return void this.resetDragPosition();
              if (
                ((this.state = "decel"),
                (this.friction = this.option("decelFriction")),
                this.recalculateTransform(),
                this.$container.classList.remove(this.option("draggingClass")),
                !1 === this.trigger("touchEnd", i))
              )
                return;
              if ("decel" !== this.state) return;
              const s = this.option("minScale");
              if (this.transform.scale < s) return void this.zoomTo(s, { friction: 0.64 });
              const a = this.option("maxScale");
              if (this.transform.scale - a > 0.01) {
                const t = this.dragPosition.midPoint || e,
                  i = this.$content.getClientRects()[0];
                this.zoomTo(a, { friction: 0.64, x: t.clientX - i.left, y: t.clientY - i.top });
              }
            },
          });
          this.pointerTracker = t;
        }
        initObserver() {
          this.resizeObserver ||
            ((this.resizeObserver = new o(() => {
              this.updateTimer ||
                (this.updateTimer = setTimeout(() => {
                  const t = this.$container.getBoundingClientRect();
                  t.width && t.height
                    ? ((Math.abs(t.width - this.container.width) > 1 ||
                        Math.abs(t.height - this.container.height) > 1) &&
                        (this.isAnimating() && this.endAnimation(!0),
                        this.updateMetrics(),
                        this.panTo({
                          x: this.content.x,
                          y: this.content.y,
                          scale: this.option("baseScale"),
                          friction: 0,
                        })),
                      (this.updateTimer = null))
                    : (this.updateTimer = null);
                }, this.updateRate));
            })),
            this.resizeObserver.observe(this.$container));
        }
        resetDragPosition() {
          (this.lockAxis = null), (this.friction = this.option("friction")), (this.velocity = { x: 0, y: 0, scale: 0 });
          const { x: t, y: e, scale: i } = this.content;
          (this.dragStart = { rect: this.$content.getBoundingClientRect(), x: t, y: e, scale: i }),
            (this.dragPosition = { ...this.dragPosition, x: t, y: e, scale: i }),
            (this.dragOffset = { x: 0, y: 0, scale: 1, time: 0 });
        }
        updateMetrics(t) {
          !0 !== t && this.trigger("beforeUpdate");
          const e = this.$container,
            i = this.$content,
            s = this.$viewport,
            a = i instanceof HTMLImageElement,
            r = this.option("zoom"),
            o = this.option("resizeParent", r);
          let l = this.option("width"),
            c = this.option("height"),
            h =
              l ||
              ((d = i),
              Math.max(
                parseFloat(d.naturalWidth || 0),
                parseFloat((d.width && d.width.baseVal && d.width.baseVal.value) || 0),
                parseFloat(d.offsetWidth || 0),
                parseFloat(d.scrollWidth || 0)
              ));
          var d;
          let u =
            c ||
            ((t) =>
              Math.max(
                parseFloat(t.naturalHeight || 0),
                parseFloat((t.height && t.height.baseVal && t.height.baseVal.value) || 0),
                parseFloat(t.offsetHeight || 0),
                parseFloat(t.scrollHeight || 0)
              ))(i);
          Object.assign(i.style, { width: l ? `${l}px` : "", height: c ? `${c}px` : "", maxWidth: "", maxHeight: "" }),
            o && Object.assign(s.style, { width: "", height: "" });
          const p = this.option("ratio");
          (h = n(h * p)), (u = n(u * p)), (l = h), (c = u);
          const g = i.getBoundingClientRect(),
            f = s.getBoundingClientRect(),
            m = s == e ? f : e.getBoundingClientRect();
          let v = Math.max(s.offsetWidth, n(f.width)),
            x = Math.max(s.offsetHeight, n(f.height)),
            b = window.getComputedStyle(s);
          if (
            ((v -= parseFloat(b.paddingLeft) + parseFloat(b.paddingRight)),
            (x -= parseFloat(b.paddingTop) + parseFloat(b.paddingBottom)),
            (this.viewport.width = v),
            (this.viewport.height = x),
            r)
          ) {
            if (Math.abs(h - g.width) > 0.1 || Math.abs(u - g.height) > 0.1) {
              const t = ((t, e, i, s) => {
                const a = Math.min(i / t || 0, s / e);
                return { width: t * a || 0, height: e * a || 0 };
              })(h, u, Math.min(h, g.width), Math.min(u, g.height));
              (l = n(t.width)), (c = n(t.height));
            }
            Object.assign(i.style, { width: `${l}px`, height: `${c}px`, transform: "" });
          }
          if (
            (o &&
              (Object.assign(s.style, { width: `${l}px`, height: `${c}px` }),
              (this.viewport = { ...this.viewport, width: l, height: c })),
            a && r && "function" != typeof this.options.maxScale)
          ) {
            const t = this.option("maxScale");
            this.options.maxScale = function () {
              return this.content.origWidth > 0 && this.content.fitWidth > 0
                ? this.content.origWidth / this.content.fitWidth
                : t;
            };
          }
          (this.content = {
            ...this.content,
            origWidth: h,
            origHeight: u,
            fitWidth: l,
            fitHeight: c,
            width: l,
            height: c,
            scale: 1,
            isZoomable: r,
          }),
            (this.container = { width: m.width, height: m.height }),
            !0 !== t && this.trigger("afterUpdate");
        }
        zoomIn(t) {
          this.zoomTo(this.content.scale + (t || this.option("step")));
        }
        zoomOut(t) {
          this.zoomTo(this.content.scale - (t || this.option("step")));
        }
        toggleZoom(t = {}) {
          const e = this.option("maxScale"),
            i = this.option("baseScale"),
            s = this.content.scale > i + 0.5 * (e - i) ? i : e;
          this.zoomTo(s, t);
        }
        zoomTo(t = this.option("baseScale"), { x: e = null, y: i = null } = {}) {
          t = Math.max(Math.min(t, this.option("maxScale")), this.option("minScale"));
          const s = n(this.content.scale / (this.content.width / this.content.fitWidth), 1e7);
          null === e && (e = this.content.width * s * 0.5), null === i && (i = this.content.height * s * 0.5);
          const { deltaX: a, deltaY: r } = this.getZoomDelta(t, e, i);
          (e = this.content.x - a),
            (i = this.content.y - r),
            this.panTo({ x: e, y: i, scale: t, friction: this.option("zoomFriction") });
        }
        getZoomDelta(t, e = 0, i = 0) {
          const s = this.content.fitWidth * this.content.scale,
            a = this.content.fitHeight * this.content.scale,
            n = e > 0 && s ? e / s : 0,
            r = i > 0 && a ? i / a : 0;
          return { deltaX: (this.content.fitWidth * t - s) * n, deltaY: (this.content.fitHeight * t - a) * r };
        }
        panTo({
          x: t = this.content.x,
          y: e = this.content.y,
          scale: i,
          friction: s = this.option("friction"),
          ignoreBounds: a = !1,
        } = {}) {
          if (((i = i || this.content.scale || 1), !a)) {
            const { boundX: s, boundY: a } = this.getBounds(i);
            s && (t = Math.max(Math.min(t, s.to), s.from)), a && (e = Math.max(Math.min(e, a.to), a.from));
          }
          (this.friction = s),
            (this.transform = { ...this.transform, x: t, y: e, scale: i }),
            s
              ? ((this.state = "panning"),
                (this.velocity = {
                  x: (1 / this.friction - 1) * (t - this.content.x),
                  y: (1 / this.friction - 1) * (e - this.content.y),
                  scale: (1 / this.friction - 1) * (i - this.content.scale),
                }),
                this.startAnimation())
              : this.endAnimation();
        }
        startAnimation() {
          this.rAF ? cancelAnimationFrame(this.rAF) : this.trigger("startAnimation"),
            (this.rAF = requestAnimationFrame(() => this.animate()));
        }
        animate() {
          if (
            (this.setEdgeForce(),
            this.setDragForce(),
            (this.velocity.x *= this.friction),
            (this.velocity.y *= this.friction),
            (this.velocity.scale *= this.friction),
            (this.content.x += this.velocity.x),
            (this.content.y += this.velocity.y),
            (this.content.scale += this.velocity.scale),
            this.isAnimating())
          )
            this.setTransform();
          else if ("pointerdown" !== this.state) return void this.endAnimation();
          this.rAF = requestAnimationFrame(() => this.animate());
        }
        getBounds(t) {
          let e = this.boundX,
            i = this.boundY;
          if (void 0 !== e && void 0 !== i) return { boundX: e, boundY: i };
          (e = { from: 0, to: 0 }), (i = { from: 0, to: 0 }), (t = t || this.transform.scale);
          const s = this.content.fitWidth * t,
            a = this.content.fitHeight * t,
            r = this.viewport.width,
            o = this.viewport.height;
          if (s < r) {
            const t = n(0.5 * (r - s));
            (e.from = t), (e.to = t);
          } else e.from = n(r - s);
          if (a < o) {
            const t = 0.5 * (o - a);
            (i.from = t), (i.to = t);
          } else i.from = n(o - a);
          return { boundX: e, boundY: i };
        }
        setEdgeForce() {
          if ("decel" !== this.state) return;
          const t = this.option("bounceForce"),
            { boundX: e, boundY: i } = this.getBounds(Math.max(this.transform.scale, this.content.scale));
          let s, a, n, r;
          if (
            (e && ((s = this.content.x < e.from), (a = this.content.x > e.to)),
            i && ((n = this.content.y < i.from), (r = this.content.y > i.to)),
            s || a)
          ) {
            let i = ((s ? e.from : e.to) - this.content.x) * t;
            const a = this.content.x + (this.velocity.x + i) / this.friction;
            a >= e.from && a <= e.to && (i += this.velocity.x), (this.velocity.x = i), this.recalculateTransform();
          }
          if (n || r) {
            let e = ((n ? i.from : i.to) - this.content.y) * t;
            const s = this.content.y + (e + this.velocity.y) / this.friction;
            s >= i.from && s <= i.to && (e += this.velocity.y), (this.velocity.y = e), this.recalculateTransform();
          }
        }
        setDragResistance() {
          if ("pointerdown" !== this.state) return;
          const { boundX: t, boundY: e } = this.getBounds(this.dragPosition.scale);
          let i, s, a, n;
          if (
            (t && ((i = this.dragPosition.x < t.from), (s = this.dragPosition.x > t.to)),
            e && ((a = this.dragPosition.y < e.from), (n = this.dragPosition.y > e.to)),
            (i || s) && (!i || !s))
          ) {
            const e = i ? t.from : t.to,
              s = e - this.dragPosition.x;
            this.dragPosition.x = e - 0.3 * s;
          }
          if ((a || n) && (!a || !n)) {
            const t = a ? e.from : e.to,
              i = t - this.dragPosition.y;
            this.dragPosition.y = t - 0.3 * i;
          }
        }
        setDragForce() {
          "pointerdown" === this.state &&
            ((this.velocity.x = this.dragPosition.x - this.content.x),
            (this.velocity.y = this.dragPosition.y - this.content.y),
            (this.velocity.scale = this.dragPosition.scale - this.content.scale));
        }
        recalculateTransform() {
          (this.transform.x = this.content.x + this.velocity.x / (1 / this.friction - 1)),
            (this.transform.y = this.content.y + this.velocity.y / (1 / this.friction - 1)),
            (this.transform.scale = this.content.scale + this.velocity.scale / (1 / this.friction - 1));
        }
        isAnimating() {
          return !(
            !this.friction ||
            !(
              Math.abs(this.velocity.x) > 0.05 ||
              Math.abs(this.velocity.y) > 0.05 ||
              Math.abs(this.velocity.scale) > 0.05
            )
          );
        }
        setTransform(t) {
          let e, i, s;
          if (
            (t
              ? ((e = n(this.transform.x)),
                (i = n(this.transform.y)),
                (s = this.transform.scale),
                (this.content = { ...this.content, x: e, y: i, scale: s }))
              : ((e = n(this.content.x)),
                (i = n(this.content.y)),
                (s = this.content.scale / (this.content.width / this.content.fitWidth)),
                (this.content = { ...this.content, x: e, y: i })),
            this.trigger("beforeTransform"),
            (e = n(this.content.x)),
            (i = n(this.content.y)),
            t && this.option("zoom"))
          ) {
            let t, a;
            (t = n(this.content.fitWidth * s)),
              (a = n(this.content.fitHeight * s)),
              (this.content.width = t),
              (this.content.height = a),
              (this.transform = { ...this.transform, width: t, height: a, scale: s }),
              Object.assign(this.$content.style, {
                width: `${t}px`,
                height: `${a}px`,
                maxWidth: "none",
                maxHeight: "none",
                transform: `translate3d(${e}px, ${i}px, 0) scale(1)`,
              });
          } else this.$content.style.transform = `translate3d(${e}px, ${i}px, 0) scale(${s})`;
          this.trigger("afterTransform");
        }
        endAnimation(t) {
          cancelAnimationFrame(this.rAF),
            (this.rAF = null),
            (this.velocity = { x: 0, y: 0, scale: 0 }),
            this.setTransform(!0),
            (this.state = "ready"),
            this.handleCursor(),
            !0 !== t && this.trigger("endAnimation");
        }
        handleCursor() {
          const t = this.option("draggableClass");
          t &&
            this.option("touch") &&
            (1 == this.option("panOnlyZoomed") &&
            this.content.width <= this.viewport.width &&
            this.content.height <= this.viewport.height &&
            this.transform.scale <= this.option("baseScale")
              ? this.$container.classList.remove(t)
              : this.$container.classList.add(t));
        }
        detachEvents() {
          this.$content.removeEventListener("load", this.onLoad),
            this.$container.removeEventListener("wheel", this.onWheel, { passive: !1 }),
            this.$container.removeEventListener("click", this.onClick, { passive: !1 }),
            this.pointerTracker && (this.pointerTracker.stop(), (this.pointerTracker = null)),
            this.resizeObserver && (this.resizeObserver.disconnect(), (this.resizeObserver = null));
        }
        destroy() {
          "destroy" !== this.state &&
            ((this.state = "destroy"),
            clearTimeout(this.updateTimer),
            (this.updateTimer = null),
            cancelAnimationFrame(this.rAF),
            (this.rAF = null),
            this.detachEvents(),
            this.detachPlugins(),
            this.resetDragPosition());
        }
      }
      (g.version = "4.0.31"), (g.Plugins = {});
      const f = (t, e) => {
        let i = 0;
        return function (...s) {
          const a = new Date().getTime();
          if (!(a - i < e)) return (i = a), t(...s);
        };
      };
      class m {
        constructor(t) {
          (this.$container = null),
            (this.$prev = null),
            (this.$next = null),
            (this.carousel = t),
            (this.onRefresh = this.onRefresh.bind(this));
        }
        option(t) {
          return this.carousel.option(`Navigation.${t}`);
        }
        createButton(t) {
          const e = document.createElement("button");
          e.setAttribute("title", this.carousel.localize(`{{${t.toUpperCase()}}}`));
          const i = this.option("classNames.button") + " " + this.option(`classNames.${t}`);
          return (
            e.classList.add(...i.split(" ")),
            e.setAttribute("tabindex", "0"),
            (e.innerHTML = this.carousel.localize(this.option(`${t}Tpl`))),
            e.addEventListener("click", (e) => {
              e.preventDefault(), e.stopPropagation(), this.carousel["slide" + ("next" === t ? "Next" : "Prev")]();
            }),
            e
          );
        }
        build() {
          this.$container ||
            ((this.$container = document.createElement("div")),
            this.$container.classList.add(...this.option("classNames.main").split(" ")),
            this.carousel.$container.appendChild(this.$container)),
            this.$next || ((this.$next = this.createButton("next")), this.$container.appendChild(this.$next)),
            this.$prev || ((this.$prev = this.createButton("prev")), this.$container.appendChild(this.$prev));
        }
        onRefresh() {
          const t = this.carousel.pages.length;
          t <= 1 ||
          (t > 1 &&
            this.carousel.elemDimWidth < this.carousel.wrapDimWidth &&
            !Number.isInteger(this.carousel.option("slidesPerPage")))
            ? this.cleanup()
            : (this.build(),
              this.$prev.removeAttribute("disabled"),
              this.$next.removeAttribute("disabled"),
              this.carousel.option("infiniteX", this.carousel.option("infinite")) ||
                (this.carousel.page <= 0 && this.$prev.setAttribute("disabled", ""),
                this.carousel.page >= t - 1 && this.$next.setAttribute("disabled", "")));
        }
        cleanup() {
          this.$prev && this.$prev.remove(),
            (this.$prev = null),
            this.$next && this.$next.remove(),
            (this.$next = null),
            this.$container && this.$container.remove(),
            (this.$container = null);
        }
        attach() {
          this.carousel.on("refresh change", this.onRefresh);
        }
        detach() {
          this.carousel.off("refresh change", this.onRefresh), this.cleanup();
        }
      }
      m.defaults = {
        prevTpl:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>',
        nextTpl:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>',
        classNames: { main: "carousel__nav", button: "carousel__button", next: "is-next", prev: "is-prev" },
      };
      class v {
        constructor(t) {
          (this.carousel = t),
            (this.selectedIndex = null),
            (this.friction = 0),
            (this.onNavReady = this.onNavReady.bind(this)),
            (this.onNavClick = this.onNavClick.bind(this)),
            (this.onNavCreateSlide = this.onNavCreateSlide.bind(this)),
            (this.onTargetChange = this.onTargetChange.bind(this));
        }
        addAsTargetFor(t) {
          (this.target = this.carousel), (this.nav = t), this.attachEvents();
        }
        addAsNavFor(t) {
          (this.target = t), (this.nav = this.carousel), this.attachEvents();
        }
        attachEvents() {
          (this.nav.options.initialSlide = this.target.options.initialPage),
            this.nav.on("ready", this.onNavReady),
            this.nav.on("createSlide", this.onNavCreateSlide),
            this.nav.on("Panzoom.click", this.onNavClick),
            this.target.on("change", this.onTargetChange),
            this.target.on("Panzoom.afterUpdate", this.onTargetChange);
        }
        onNavReady() {
          this.onTargetChange(!0);
        }
        onNavClick(t, e, i) {
          const s = i.target.closest(".carousel__slide");
          if (!s) return;
          i.stopPropagation();
          const a = parseInt(s.dataset.index, 10),
            n = this.target.findPageForSlide(a);
          this.target.page !== n && this.target.slideTo(n, { friction: this.friction }), this.markSelectedSlide(a);
        }
        onNavCreateSlide(t, e) {
          e.index === this.selectedIndex && this.markSelectedSlide(e.index);
        }
        onTargetChange() {
          const t = this.target.pages[this.target.page].indexes[0],
            e = this.nav.findPageForSlide(t);
          this.nav.slideTo(e), this.markSelectedSlide(t);
        }
        markSelectedSlide(t) {
          (this.selectedIndex = t),
            [...this.nav.slides].filter((t) => t.$el && t.$el.classList.remove("is-nav-selected"));
          const e = this.nav.slides[t];
          e && e.$el && e.$el.classList.add("is-nav-selected");
        }
        attach(t) {
          const e = t.options.Sync;
          (e.target || e.nav) &&
            (e.target ? this.addAsNavFor(e.target) : e.nav && this.addAsTargetFor(e.nav), (this.friction = e.friction));
        }
        detach() {
          this.nav &&
            (this.nav.off("ready", this.onNavReady),
            this.nav.off("Panzoom.click", this.onNavClick),
            this.nav.off("createSlide", this.onNavCreateSlide)),
            this.target &&
              (this.target.off("Panzoom.afterUpdate", this.onTargetChange),
              this.target.off("change", this.onTargetChange));
        }
      }
      v.defaults = { friction: 0.92 };
      const x = {
          Navigation: m,
          Dots: class {
            constructor(t) {
              (this.carousel = t),
                (this.$list = null),
                (this.events = { change: this.onChange.bind(this), refresh: this.onRefresh.bind(this) });
            }
            buildList() {
              if (this.carousel.pages.length < this.carousel.option("Dots.minSlideCount")) return;
              const t = document.createElement("ol");
              return (
                t.classList.add("carousel__dots"),
                t.addEventListener("click", (t) => {
                  if (!("page" in t.target.dataset)) return;
                  t.preventDefault(), t.stopPropagation();
                  const e = parseInt(t.target.dataset.page, 10),
                    i = this.carousel;
                  e !== i.page &&
                    (i.pages.length < 3 && i.option("infinite")
                      ? i[0 == e ? "slidePrev" : "slideNext"]()
                      : i.slideTo(e));
                }),
                (this.$list = t),
                this.carousel.$container.appendChild(t),
                this.carousel.$container.classList.add("has-dots"),
                t
              );
            }
            removeList() {
              this.$list && (this.$list.parentNode.removeChild(this.$list), (this.$list = null)),
                this.carousel.$container.classList.remove("has-dots");
            }
            rebuildDots() {
              let t = this.$list;
              const e = !!t,
                i = this.carousel.pages.length;
              if (i < 2) return void (e && this.removeList());
              e || (t = this.buildList());
              const s = this.$list.children.length;
              if (s > i) for (let t = i; t < s; t++) this.$list.removeChild(this.$list.lastChild);
              else {
                for (let t = s; t < i; t++) {
                  const e = document.createElement("li");
                  e.classList.add("carousel__dot"),
                    (e.dataset.page = t),
                    e.setAttribute("role", "button"),
                    e.setAttribute("tabindex", "0"),
                    e.setAttribute("title", this.carousel.localize("{{GOTO}}", [["%d", t + 1]])),
                    e.addEventListener("keydown", (t) => {
                      const i = t.code;
                      let s;
                      "Enter" === i || "NumpadEnter" === i
                        ? (s = e)
                        : "ArrowRight" === i
                        ? (s = e.nextSibling)
                        : "ArrowLeft" === i && (s = e.previousSibling),
                        s && s.click();
                    }),
                    this.$list.appendChild(e);
                }
                this.setActiveDot();
              }
            }
            setActiveDot() {
              if (!this.$list) return;
              this.$list.childNodes.forEach((t) => {
                t.classList.remove("is-selected");
              });
              const t = this.$list.childNodes[this.carousel.page];
              t && t.classList.add("is-selected");
            }
            onChange() {
              this.setActiveDot();
            }
            onRefresh() {
              this.rebuildDots();
            }
            attach() {
              this.carousel.on(this.events);
            }
            detach() {
              this.removeList(), this.carousel.off(this.events), (this.carousel = null);
            }
          },
          Sync: v,
        },
        b = {
          slides: [],
          preload: 0,
          slidesPerPage: "auto",
          initialPage: null,
          initialSlide: null,
          friction: 0.92,
          center: !0,
          infinite: !0,
          fill: !0,
          dragFree: !1,
          prefix: "",
          classNames: {
            viewport: "carousel__viewport",
            track: "carousel__track",
            slide: "carousel__slide",
            slideSelected: "is-selected",
          },
          l10n: { NEXT: "Next slide", PREV: "Previous slide", GOTO: "Go to slide #%d" },
        };
      class y extends u {
        constructor(t, e = {}) {
          if (
            (super((e = a(!0, {}, b, e))),
            (this.state = "init"),
            (this.$container = t),
            !(this.$container instanceof HTMLElement))
          )
            throw new Error("No root element provided");
          (this.slideNext = f(this.slideNext.bind(this), 250)),
            (this.slidePrev = f(this.slidePrev.bind(this), 250)),
            this.init(),
            (t.__Carousel = this);
        }
        init() {
          (this.pages = []),
            (this.page = this.pageIndex = null),
            (this.prevPage = this.prevPageIndex = null),
            this.attachPlugins(y.Plugins),
            this.trigger("init"),
            this.initLayout(),
            this.initSlides(),
            this.updateMetrics(),
            this.$track &&
              this.pages.length &&
              (this.$track.style.transform = `translate3d(${-1 * this.pages[this.page].left}px, 0px, 0) scale(1)`),
            this.manageSlideVisiblity(),
            this.initPanzoom(),
            (this.state = "ready"),
            this.trigger("ready");
        }
        initLayout() {
          const t = this.option("prefix"),
            e = this.option("classNames");
          (this.$viewport = this.option("viewport") || this.$container.querySelector(`.${t}${e.viewport}`)),
            this.$viewport ||
              ((this.$viewport = document.createElement("div")),
              this.$viewport.classList.add(...(t + e.viewport).split(" ")),
              this.$viewport.append(...this.$container.childNodes),
              this.$container.appendChild(this.$viewport)),
            (this.$track = this.option("track") || this.$container.querySelector(`.${t}${e.track}`)),
            this.$track ||
              ((this.$track = document.createElement("div")),
              this.$track.classList.add(...(t + e.track).split(" ")),
              this.$track.append(...this.$viewport.childNodes),
              this.$viewport.appendChild(this.$track));
        }
        initSlides() {
          (this.slides = []),
            this.$viewport
              .querySelectorAll(`.${this.option("prefix")}${this.option("classNames.slide")}`)
              .forEach((t) => {
                const e = { $el: t, isDom: !0 };
                this.slides.push(e), this.trigger("createSlide", e, this.slides.length);
              }),
            Array.isArray(this.options.slides) && (this.slides = a(!0, [...this.slides], this.options.slides));
        }
        updateMetrics() {
          let t,
            e = 0,
            i = [];
          this.slides.forEach((s, a) => {
            const n = s.$el,
              r = s.isDom || !t ? this.getSlideMetrics(n) : t;
            (s.index = a), (s.width = r), (s.left = e), (t = r), (e += r), i.push(a);
          });
          let s = Math.max(this.$track.offsetWidth, n(this.$track.getBoundingClientRect().width)),
            a = getComputedStyle(this.$track);
          (s -= parseFloat(a.paddingLeft) + parseFloat(a.paddingRight)),
            (this.contentWidth = e),
            (this.viewportWidth = s);
          const r = [],
            o = this.option("slidesPerPage");
          if (Number.isInteger(o) && e > s)
            for (let t = 0; t < this.slides.length; t += o)
              r.push({ indexes: i.slice(t, t + o), slides: this.slides.slice(t, t + o) });
          else {
            let t = 0,
              e = 0;
            for (let i = 0; i < this.slides.length; i += 1) {
              let a = this.slides[i];
              (!r.length || e + a.width > s) && (r.push({ indexes: [], slides: [] }), (t = r.length - 1), (e = 0)),
                (e += a.width),
                r[t].indexes.push(i),
                r[t].slides.push(a);
            }
          }
          const l = this.option("center"),
            c = this.option("fill");
          r.forEach((t, i) => {
            (t.index = i),
              (t.width = t.slides.reduce((t, e) => t + e.width, 0)),
              (t.left = t.slides[0].left),
              l && (t.left += 0.5 * (s - t.width) * -1),
              c &&
                !this.option("infiniteX", this.option("infinite")) &&
                e > s &&
                ((t.left = Math.max(t.left, 0)), (t.left = Math.min(t.left, e - s)));
          });
          const h = [];
          let d;
          r.forEach((t) => {
            const e = { ...t };
            d && e.left === d.left
              ? ((d.width += e.width),
                (d.slides = [...d.slides, ...e.slides]),
                (d.indexes = [...d.indexes, ...e.indexes]))
              : ((e.index = h.length), (d = e), h.push(e));
          }),
            (this.pages = h);
          let u = this.page;
          if (null === u) {
            const t = this.option("initialSlide");
            (u = null !== t ? this.findPageForSlide(t) : parseInt(this.option("initialPage", 0), 10) || 0),
              h[u] || (u = h.length && u > h.length ? h[h.length - 1].index : 0),
              (this.page = u),
              (this.pageIndex = u);
          }
          this.updatePanzoom(), this.trigger("refresh");
        }
        getSlideMetrics(t) {
          if (!t) {
            const e = this.slides[0];
            ((t = document.createElement("div")).dataset.isTestEl = 1),
              (t.style.visibility = "hidden"),
              t.classList.add(...(this.option("prefix") + this.option("classNames.slide")).split(" ")),
              e.customClass && t.classList.add(...e.customClass.split(" ")),
              this.$track.prepend(t);
          }
          let e = Math.max(t.offsetWidth, n(t.getBoundingClientRect().width));
          const i = t.currentStyle || window.getComputedStyle(t);
          return (
            (e = e + (parseFloat(i.marginLeft) || 0) + (parseFloat(i.marginRight) || 0)),
            t.dataset.isTestEl && t.remove(),
            e
          );
        }
        findPageForSlide(t) {
          t = parseInt(t, 10) || 0;
          const e = this.pages.find((e) => e.indexes.indexOf(t) > -1);
          return e ? e.index : null;
        }
        slideNext() {
          this.slideTo(this.pageIndex + 1);
        }
        slidePrev() {
          this.slideTo(this.pageIndex - 1);
        }
        slideTo(t, e = {}) {
          const { x: i = -1 * this.setPage(t, !0), y: s = 0, friction: a = this.option("friction") } = e;
          (this.Panzoom.content.x === i && !this.Panzoom.velocity.x && a) ||
            (this.Panzoom.panTo({ x: i, y: s, friction: a, ignoreBounds: !0 }),
            "ready" === this.state && "ready" === this.Panzoom.state && this.trigger("settle"));
        }
        initPanzoom() {
          this.Panzoom && this.Panzoom.destroy();
          const t = a(
            !0,
            {},
            {
              content: this.$track,
              wrapInner: !1,
              resizeParent: !1,
              zoom: !1,
              click: !1,
              lockAxis: "x",
              x: this.pages.length ? -1 * this.pages[this.page].left : 0,
              centerOnStart: !1,
              textSelection: () => this.option("textSelection", !1),
              panOnlyZoomed: function () {
                return this.content.width <= this.viewport.width;
              },
            },
            this.option("Panzoom")
          );
          (this.Panzoom = new g(this.$container, t)),
            this.Panzoom.on({
              "*": (t, ...e) => this.trigger(`Panzoom.${t}`, ...e),
              afterUpdate: () => {
                this.updatePage();
              },
              beforeTransform: this.onBeforeTransform.bind(this),
              touchEnd: this.onTouchEnd.bind(this),
              endAnimation: () => {
                this.trigger("settle");
              },
            }),
            this.updateMetrics(),
            this.manageSlideVisiblity();
        }
        updatePanzoom() {
          this.Panzoom &&
            ((this.Panzoom.content = {
              ...this.Panzoom.content,
              fitWidth: this.contentWidth,
              origWidth: this.contentWidth,
              width: this.contentWidth,
            }),
            this.pages.length > 1 && this.option("infiniteX", this.option("infinite"))
              ? (this.Panzoom.boundX = null)
              : this.pages.length &&
                (this.Panzoom.boundX = {
                  from: -1 * this.pages[this.pages.length - 1].left,
                  to: -1 * this.pages[0].left,
                }),
            this.option("infiniteY", this.option("infinite"))
              ? (this.Panzoom.boundY = null)
              : (this.Panzoom.boundY = { from: 0, to: 0 }),
            this.Panzoom.handleCursor());
        }
        manageSlideVisiblity() {
          const t = this.contentWidth,
            e = this.viewportWidth;
          let i = this.Panzoom ? -1 * this.Panzoom.content.x : this.pages.length ? this.pages[this.page].left : 0;
          const s = this.option("preload"),
            a = this.option("infiniteX", this.option("infinite")),
            n = parseFloat(getComputedStyle(this.$viewport, null).getPropertyValue("padding-left")),
            r = parseFloat(getComputedStyle(this.$viewport, null).getPropertyValue("padding-right"));
          this.slides.forEach((o) => {
            let l,
              c,
              h = 0;
            (l = i - n), (c = i + e + r), (l -= s * (e + n + r)), (c += s * (e + n + r));
            const d = o.left + o.width > l && o.left < c;
            (l = i + t - n), (c = i + t + e + r), (l -= s * (e + n + r));
            const u = a && o.left + o.width > l && o.left < c;
            (l = i - t - n), (c = i - t + e + r), (l -= s * (e + n + r));
            const p = a && o.left + o.width > l && o.left < c;
            u || d || p
              ? (this.createSlideEl(o),
                d && (h = 0),
                u && (h = -1),
                p && (h = 1),
                o.left + o.width > i && o.left <= i + e + r && (h = 0))
              : this.removeSlideEl(o),
              (o.hasDiff = h);
          });
          let o = 0,
            l = 0;
          this.slides.forEach((e, i) => {
            let s = 0;
            e.$el
              ? (i !== o || e.hasDiff ? (s = l + e.hasDiff * t) : (l = 0),
                (e.$el.style.left = Math.abs(s) > 0.1 ? `${l + e.hasDiff * t}px` : ""),
                o++)
              : (l += e.width);
          }),
            this.markSelectedSlides();
        }
        createSlideEl(t) {
          if (!t) return;
          if (t.$el) {
            let e = t.$el.dataset.index;
            if (!e || parseInt(e, 10) !== t.index) {
              let e;
              (t.$el.dataset.index = t.index),
                t.$el.querySelectorAll("[data-lazy-srcset]").forEach((t) => {
                  t.srcset = t.dataset.lazySrcset;
                }),
                t.$el.querySelectorAll("[data-lazy-src]").forEach((t) => {
                  let e = t.dataset.lazySrc;
                  t instanceof HTMLImageElement ? (t.src = e) : (t.style.backgroundImage = `url('${e}')`);
                }),
                (e = t.$el.dataset.lazySrc) && (t.$el.style.backgroundImage = `url('${e}')`),
                (t.state = "ready");
            }
            return;
          }
          const e = document.createElement("div");
          (e.dataset.index = t.index),
            e.classList.add(...(this.option("prefix") + this.option("classNames.slide")).split(" ")),
            t.customClass && e.classList.add(...t.customClass.split(" ")),
            t.html && (e.innerHTML = t.html);
          const i = [];
          this.slides.forEach((t, e) => {
            t.$el && i.push(e);
          });
          const s = t.index;
          let a = null;
          if (i.length) {
            let t = i.reduce((t, e) => (Math.abs(e - s) < Math.abs(t - s) ? e : t));
            a = this.slides[t];
          }
          return (
            this.$track.insertBefore(e, a && a.$el ? (a.index < t.index ? a.$el.nextSibling : a.$el) : null),
            (t.$el = e),
            this.trigger("createSlide", t, s),
            t
          );
        }
        removeSlideEl(t) {
          t.$el && !t.isDom && (this.trigger("removeSlide", t), t.$el.remove(), (t.$el = null));
        }
        markSelectedSlides() {
          const t = this.option("classNames.slideSelected"),
            e = "aria-hidden";
          this.slides.forEach((i, s) => {
            const a = i.$el;
            if (!a) return;
            const n = this.pages[this.page];
            n && n.indexes && n.indexes.indexOf(s) > -1
              ? (t && !a.classList.contains(t) && (a.classList.add(t), this.trigger("selectSlide", i)),
                a.removeAttribute(e))
              : (t && a.classList.contains(t) && (a.classList.remove(t), this.trigger("unselectSlide", i)),
                a.setAttribute(e, !0));
          });
        }
        updatePage() {
          this.updateMetrics(), this.slideTo(this.page, { friction: 0 });
        }
        onBeforeTransform() {
          this.option("infiniteX", this.option("infinite")) && this.manageInfiniteTrack(), this.manageSlideVisiblity();
        }
        manageInfiniteTrack() {
          const t = this.contentWidth,
            e = this.viewportWidth;
          if (!this.option("infiniteX", this.option("infinite")) || this.pages.length < 2 || t < e) return;
          const i = this.Panzoom;
          let s = !1;
          return (
            i.content.x < -1 * (t - e) &&
              ((i.content.x += t), (this.pageIndex = this.pageIndex - this.pages.length), (s = !0)),
            i.content.x > e && ((i.content.x -= t), (this.pageIndex = this.pageIndex + this.pages.length), (s = !0)),
            s && "pointerdown" === i.state && i.resetDragPosition(),
            s
          );
        }
        onTouchEnd(t, e) {
          const i = this.option("dragFree");
          if (
            !i &&
            this.pages.length > 1 &&
            t.dragOffset.time < 350 &&
            Math.abs(t.dragOffset.y) < 1 &&
            Math.abs(t.dragOffset.x) > 5
          )
            this[t.dragOffset.x < 0 ? "slideNext" : "slidePrev"]();
          else if (i) {
            const [, e] = this.getPageFromPosition(-1 * t.transform.x);
            this.setPage(e);
          } else this.slideToClosest();
        }
        slideToClosest(t = {}) {
          let [, e] = this.getPageFromPosition(-1 * this.Panzoom.content.x);
          this.slideTo(e, t);
        }
        getPageFromPosition(t) {
          const e = this.pages.length;
          this.option("center") && (t += 0.5 * this.viewportWidth);
          const i = Math.floor(t / this.contentWidth);
          t -= i * this.contentWidth;
          let s = this.slides.find((e) => e.left <= t && e.left + e.width > t);
          if (s) {
            let t = this.findPageForSlide(s.index);
            return [t, t + i * e];
          }
          return [0, 0];
        }
        setPage(t, e) {
          let i = 0,
            s = parseInt(t, 10) || 0;
          const a = this.page,
            n = this.pageIndex,
            r = this.pages.length,
            o = this.contentWidth,
            l = this.viewportWidth;
          if (((t = ((s % r) + r) % r), this.option("infiniteX", this.option("infinite")) && o > l)) {
            const a = Math.floor(s / r) || 0,
              n = o;
            if (((i = this.pages[t].left + a * n), !0 === e && r > 2)) {
              let t = -1 * this.Panzoom.content.x;
              const e = i - n,
                a = i + n,
                o = Math.abs(t - i),
                l = Math.abs(t - e),
                c = Math.abs(t - a);
              c < o && c <= l ? ((i = a), (s += r)) : l < o && l < c && ((i = e), (s -= r));
            }
          } else (t = s = Math.max(0, Math.min(s, r - 1))), (i = this.pages.length ? this.pages[t].left : 0);
          return (
            (this.page = t),
            (this.pageIndex = s),
            null !== a && t !== a && ((this.prevPage = a), (this.prevPageIndex = n), this.trigger("change", t, a)),
            i
          );
        }
        destroy() {
          (this.state = "destroy"),
            this.slides.forEach((t) => {
              this.removeSlideEl(t);
            }),
            (this.slides = []),
            this.Panzoom.destroy(),
            this.detachPlugins();
        }
      }
      (y.version = "4.0.31"), (y.Plugins = x);
      const w = !("undefined" == typeof window || !window.document || !window.document.createElement);
      let k = null;
      const S = [
          "a[href]",
          "area[href]",
          'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',
          "select:not([disabled]):not([aria-hidden])",
          "textarea:not([disabled]):not([aria-hidden])",
          "button:not([disabled]):not([aria-hidden])",
          "iframe",
          "object",
          "embed",
          "video",
          "audio",
          "[contenteditable]",
          '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])',
        ],
        C = (t) => {
          if (t && w) {
            null === k &&
              document.createElement("div").focus({
                get preventScroll() {
                  return (k = !0), !1;
                },
              });
            try {
              if (t.setActive) t.setActive();
              else if (k) t.focus({ preventScroll: !0 });
              else {
                const e = window.pageXOffset || document.body.scrollTop,
                  i = window.pageYOffset || document.body.scrollLeft;
                t.focus(), document.body.scrollTo({ top: e, left: i, behavior: "auto" });
              }
            } catch (t) {}
          }
        };
      class A {
        constructor(t) {
          (this.fancybox = t), (this.$container = null), (this.state = "init");
          for (const t of ["onPrepare", "onClosing", "onKeydown"]) this[t] = this[t].bind(this);
          this.events = { prepare: this.onPrepare, closing: this.onClosing, keydown: this.onKeydown };
        }
        onPrepare() {
          this.getSlides().length < this.fancybox.option("Thumbs.minSlideCount")
            ? (this.state = "disabled")
            : !0 === this.fancybox.option("Thumbs.autoStart") &&
              this.fancybox.Carousel.Panzoom.content.height >= this.fancybox.option("Thumbs.minScreenHeight") &&
              this.build();
        }
        onClosing() {
          this.Carousel && this.Carousel.Panzoom.detachEvents();
        }
        onKeydown(t, e) {
          e === t.option("Thumbs.key") && this.toggle();
        }
        build() {
          if (this.$container) return;
          const t = document.createElement("div");
          t.classList.add("fancybox__thumbs"),
            this.fancybox.$carousel.parentNode.insertBefore(t, this.fancybox.$carousel.nextSibling),
            (this.Carousel = new y(
              t,
              a(
                !0,
                {
                  Dots: !1,
                  Navigation: !1,
                  Sync: { friction: 0 },
                  infinite: !1,
                  center: !0,
                  fill: !0,
                  dragFree: !0,
                  slidesPerPage: 1,
                  preload: 1,
                },
                this.fancybox.option("Thumbs.Carousel"),
                { Sync: { target: this.fancybox.Carousel }, slides: this.getSlides() }
              )
            )),
            this.Carousel.Panzoom.on("wheel", (t, e) => {
              e.preventDefault(), this.fancybox[e.deltaY < 0 ? "prev" : "next"]();
            }),
            (this.$container = t),
            (this.state = "visible");
        }
        getSlides() {
          const t = [];
          for (const e of this.fancybox.items) {
            const i = e.thumb;
            i &&
              t.push({
                html: this.fancybox.option("Thumbs.tpl").replace(/\{\{src\}\}/gi, i),
                customClass: `has-thumb has-${e.type || "image"}`,
              });
          }
          return t;
        }
        toggle() {
          "visible" === this.state ? this.hide() : "hidden" === this.state ? this.show() : this.build();
        }
        show() {
          "hidden" === this.state &&
            ((this.$container.style.display = ""), this.Carousel.Panzoom.attachEvents(), (this.state = "visible"));
        }
        hide() {
          "visible" === this.state &&
            (this.Carousel.Panzoom.detachEvents(), (this.$container.style.display = "none"), (this.state = "hidden"));
        }
        cleanup() {
          this.Carousel && (this.Carousel.destroy(), (this.Carousel = null)),
            this.$container && (this.$container.remove(), (this.$container = null)),
            (this.state = "init");
        }
        attach() {
          this.fancybox.on(this.events);
        }
        detach() {
          this.fancybox.off(this.events), this.cleanup();
        }
      }
      A.defaults = {
        minSlideCount: 2,
        minScreenHeight: 500,
        autoStart: !0,
        key: "t",
        Carousel: {},
        tpl: '<div class="fancybox__thumb" style="background-image:url(\'{{src}}\')"></div>',
      };
      const E = (t, e) => {
          const i = new URL(t),
            s = new URLSearchParams(i.search);
          let a = new URLSearchParams();
          for (const [t, i] of [...s, ...Object.entries(e)]) "t" === t ? a.set("start", parseInt(i)) : a.set(t, i);
          a = a.toString();
          let n = t.match(/#t=((.*)?\d+s)/);
          return n && (a += `#t=${n[1]}`), a;
        },
        T = {
          video: { autoplay: !0, ratio: 16 / 9 },
          youtube: { autohide: 1, fs: 1, rel: 0, hd: 1, wmode: "transparent", enablejsapi: 1, html5: 1 },
          vimeo: { hd: 1, show_title: 1, show_byline: 1, show_portrait: 0, fullscreen: 1 },
          html5video: {
            tpl: '<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">\n  <source src="{{src}}" type="{{format}}" />Sorry, your browser doesn\'t support embedded videos.</video>',
            format: "",
          },
        };
      class L {
        constructor(t) {
          this.fancybox = t;
          for (const t of [
            "onInit",
            "onReady",
            "onCreateSlide",
            "onRemoveSlide",
            "onSelectSlide",
            "onUnselectSlide",
            "onRefresh",
            "onMessage",
          ])
            this[t] = this[t].bind(this);
          this.events = {
            init: this.onInit,
            ready: this.onReady,
            "Carousel.createSlide": this.onCreateSlide,
            "Carousel.removeSlide": this.onRemoveSlide,
            "Carousel.selectSlide": this.onSelectSlide,
            "Carousel.unselectSlide": this.onUnselectSlide,
            "Carousel.refresh": this.onRefresh,
          };
        }
        onInit() {
          for (const t of this.fancybox.items) this.processType(t);
        }
        processType(t) {
          if (t.html) return (t.src = t.html), (t.type = "html"), void delete t.html;
          const e = t.src || "";
          let i = t.type || this.fancybox.options.type,
            s = null;
          if (!e || "string" == typeof e) {
            if (
              (s = e.match(
                /(?:youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i
              ))
            ) {
              const a = E(e, this.fancybox.option("Html.youtube")),
                n = encodeURIComponent(s[1]);
              (t.videoId = n),
                (t.src = `https://www.youtube-nocookie.com/embed/${n}?${a}`),
                (t.thumb = t.thumb || `https://i.ytimg.com/vi/${n}/mqdefault.jpg`),
                (t.vendor = "youtube"),
                (i = "video");
            } else if ((s = e.match(/^.+vimeo.com\/(?:\/)?([\d]+)(.*)?/))) {
              const a = E(e, this.fancybox.option("Html.vimeo")),
                n = encodeURIComponent(s[1]);
              (t.videoId = n),
                (t.src = `https://player.vimeo.com/video/${n}?${a}`),
                (t.vendor = "vimeo"),
                (i = "video");
            } else
              (s = e.match(
                /(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i
              ))
                ? ((t.src = `//maps.google.${s[1]}/?ll=${(s[2]
                    ? s[2] + "&z=" + Math.floor(s[3]) + (s[4] ? s[4].replace(/^\//, "&") : "")
                    : s[4] + ""
                  ).replace(/\?/, "&")}&output=${s[4] && s[4].indexOf("layer=c") > 0 ? "svembed" : "embed"}`),
                  (i = "map"))
                : (s = e.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i)) &&
                  ((t.src = `//maps.google.${s[1]}/maps?q=${s[2]
                    .replace("query=", "q=")
                    .replace("api=1", "")}&output=embed`),
                  (i = "map"));
            i ||
              ("#" === e.charAt(0)
                ? (i = "inline")
                : (s = e.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i))
                ? ((i = "html5video"), (t.format = t.format || "video/" + ("ogv" === s[1] ? "ogg" : s[1])))
                : e.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i)
                ? (i = "image")
                : e.match(/\.(pdf)((\?|#).*)?$/i) && (i = "pdf")),
              (t.type = i || this.fancybox.option("defaultType", "image")),
              ("html5video" !== i && "video" !== i) ||
                ((t.video = a({}, this.fancybox.option("Html.video"), t.video)),
                t._width && t._height
                  ? (t.ratio = parseFloat(t._width) / parseFloat(t._height))
                  : (t.ratio = t.ratio || t.video.ratio || T.video.ratio));
          }
        }
        onReady() {
          this.fancybox.Carousel.slides.forEach((t) => {
            t.$el && (this.setContent(t), t.index === this.fancybox.getSlide().index && this.playVideo(t));
          });
        }
        onCreateSlide(t, e, i) {
          "ready" === this.fancybox.state && this.setContent(i);
        }
        loadInlineContent(t) {
          let e;
          if (t.src instanceof HTMLElement) e = t.src;
          else if ("string" == typeof t.src) {
            const i = t.src.split("#", 2),
              s = 2 === i.length && "" === i[0] ? i[1] : i[0];
            e = document.getElementById(s);
          }
          if (e) {
            if ("clone" === t.type || e.$placeHolder) {
              e = e.cloneNode(!0);
              let i = e.getAttribute("id");
              (i = i ? `${i}--clone` : `clone-${this.fancybox.id}-${t.index}`), e.setAttribute("id", i);
            } else {
              const t = document.createElement("div");
              t.classList.add("fancybox-placeholder"), e.parentNode.insertBefore(t, e), (e.$placeHolder = t);
            }
            this.fancybox.setContent(t, e);
          } else this.fancybox.setError(t, "{{ELEMENT_NOT_FOUND}}");
        }
        loadAjaxContent(t) {
          const e = this.fancybox,
            i = new XMLHttpRequest();
          e.showLoading(t),
            (i.onreadystatechange = function () {
              i.readyState === XMLHttpRequest.DONE &&
                "ready" === e.state &&
                (e.hideLoading(t),
                200 === i.status
                  ? e.setContent(t, i.responseText)
                  : e.setError(t, 404 === i.status ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}"));
            });
          const s = t.ajax || null;
          i.open(s ? "POST" : "GET", t.src),
            i.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"),
            i.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
            i.send(s),
            (t.xhr = i);
        }
        loadIframeContent(t) {
          const e = this.fancybox,
            i = document.createElement("iframe");
          if (
            ((i.className = "fancybox__iframe"),
            i.setAttribute("id", `fancybox__iframe_${e.id}_${t.index}`),
            i.setAttribute("allow", "autoplay; fullscreen"),
            i.setAttribute("scrolling", "auto"),
            (t.$iframe = i),
            "iframe" !== t.type || !1 === t.preload)
          )
            return i.setAttribute("src", t.src), this.fancybox.setContent(t, i), void this.resizeIframe(t);
          e.showLoading(t);
          const s = document.createElement("div");
          (s.style.visibility = "hidden"),
            this.fancybox.setContent(t, s),
            s.appendChild(i),
            (i.onerror = () => {
              e.setError(t, "{{IFRAME_ERROR}}");
            }),
            (i.onload = () => {
              e.hideLoading(t);
              let s = !1;
              i.isReady || ((i.isReady = !0), (s = !0)),
                i.src.length && ((i.parentNode.style.visibility = ""), this.resizeIframe(t), s && e.revealContent(t));
            }),
            i.setAttribute("src", t.src);
        }
        setAspectRatio(t) {
          const e = t.$content,
            i = t.ratio;
          if (!e) return;
          let s = t._width,
            a = t._height;
          if (i || (s && a)) {
            Object.assign(e.style, {
              width: s && a ? "100%" : "",
              height: s && a ? "100%" : "",
              maxWidth: "",
              maxHeight: "",
            });
            let t = e.offsetWidth,
              n = e.offsetHeight;
            if (((s = s || t), (a = a || n), s > t || a > n)) {
              let e = Math.min(t / s, n / a);
              (s *= e), (a *= e);
            }
            Math.abs(s / a - i) > 0.01 && (i < s / a ? (s = a * i) : (a = s / i)),
              Object.assign(e.style, { width: `${s}px`, height: `${a}px` });
          }
        }
        resizeIframe(t) {
          const e = t.$iframe;
          if (!e) return;
          let i = t._width || 0,
            s = t._height || 0;
          i && s && (t.autoSize = !1);
          const a = e.parentNode,
            n = a && a.style;
          if (!1 !== t.preload && !1 !== t.autoSize && n)
            try {
              const t = window.getComputedStyle(a),
                r = parseFloat(t.paddingLeft) + parseFloat(t.paddingRight),
                o = parseFloat(t.paddingTop) + parseFloat(t.paddingBottom),
                l = e.contentWindow.document,
                c = l.getElementsByTagName("html")[0],
                h = l.body;
              (n.width = ""),
                (h.style.overflow = "hidden"),
                (i = i || c.scrollWidth + r),
                (n.width = `${i}px`),
                (h.style.overflow = ""),
                (n.flex = "0 0 auto"),
                (n.height = `${h.scrollHeight}px`),
                (s = c.scrollHeight + o);
            } catch (t) {}
          if (i || s) {
            const t = { flex: "0 1 auto" };
            i && (t.width = `${i}px`), s && (t.height = `${s}px`), Object.assign(n, t);
          }
        }
        onRefresh(t, e) {
          e.slides.forEach((t) => {
            t.$el && (t.$iframe && this.resizeIframe(t), t.ratio && this.setAspectRatio(t));
          });
        }
        setContent(t) {
          if (t && !t.isDom) {
            switch (t.type) {
              case "html":
                this.fancybox.setContent(t, t.src);
                break;
              case "html5video":
                this.fancybox.setContent(
                  t,
                  this.fancybox
                    .option("Html.html5video.tpl")
                    .replace(/\{\{src\}\}/gi, t.src)
                    .replace("{{format}}", t.format || (t.html5video && t.html5video.format) || "")
                    .replace("{{poster}}", t.poster || t.thumb || "")
                );
                break;
              case "inline":
              case "clone":
                this.loadInlineContent(t);
                break;
              case "ajax":
                this.loadAjaxContent(t);
                break;
              case "pdf":
              case "video":
              case "map":
                t.preload = !1;
              case "iframe":
                this.loadIframeContent(t);
            }
            t.ratio && this.setAspectRatio(t);
          }
        }
        onSelectSlide(t, e, i) {
          "ready" === t.state && this.playVideo(i);
        }
        playVideo(t) {
          if ("html5video" === t.type && t.video.autoplay)
            try {
              const e = t.$el.querySelector("video");
              if (e) {
                const t = e.play();
                void 0 !== t &&
                  t
                    .then(() => {})
                    .catch((t) => {
                      (e.muted = !0), e.play();
                    });
              }
            } catch (t) {}
          if ("video" !== t.type || !t.$iframe || !t.$iframe.contentWindow) return;
          const e = () => {
            if ("done" === t.state && t.$iframe && t.$iframe.contentWindow) {
              let e;
              if (t.$iframe.isReady)
                return (
                  t.video &&
                    t.video.autoplay &&
                    (e =
                      "youtube" == t.vendor
                        ? { event: "command", func: "playVideo" }
                        : { method: "play", value: "true" }),
                  void (e && t.$iframe.contentWindow.postMessage(JSON.stringify(e), "*"))
                );
              "youtube" === t.vendor &&
                ((e = { event: "listening", id: t.$iframe.getAttribute("id") }),
                t.$iframe.contentWindow.postMessage(JSON.stringify(e), "*"));
            }
            t.poller = setTimeout(e, 250);
          };
          e();
        }
        onUnselectSlide(t, e, i) {
          if ("html5video" === i.type) {
            try {
              i.$el.querySelector("video").pause();
            } catch (t) {}
            return;
          }
          let s = !1;
          "vimeo" == i.vendor
            ? (s = { method: "pause", value: "true" })
            : "youtube" === i.vendor && (s = { event: "command", func: "pauseVideo" }),
            s && i.$iframe && i.$iframe.contentWindow && i.$iframe.contentWindow.postMessage(JSON.stringify(s), "*"),
            clearTimeout(i.poller);
        }
        onRemoveSlide(t, e, i) {
          i.xhr && (i.xhr.abort(), (i.xhr = null)),
            i.$iframe &&
              ((i.$iframe.onload = i.$iframe.onerror = null), (i.$iframe.src = "//about:blank"), (i.$iframe = null));
          const s = i.$content;
          "inline" === i.type &&
            s &&
            (s.classList.remove("fancybox__content"), "none" !== s.style.display && (s.style.display = "none")),
            i.$closeButton && (i.$closeButton.remove(), (i.$closeButton = null));
          const a = s && s.$placeHolder;
          a && (a.parentNode.insertBefore(s, a), a.remove(), (s.$placeHolder = null));
        }
        onMessage(t) {
          try {
            let e = JSON.parse(t.data);
            if ("https://player.vimeo.com" === t.origin) {
              if ("ready" === e.event)
                for (let e of document.getElementsByClassName("fancybox__iframe"))
                  e.contentWindow === t.source && (e.isReady = 1);
            } else
              "https://www.youtube-nocookie.com" === t.origin &&
                "onReady" === e.event &&
                (document.getElementById(e.id).isReady = 1);
          } catch (t) {}
        }
        attach() {
          this.fancybox.on(this.events), window.addEventListener("message", this.onMessage, !1);
        }
        detach() {
          this.fancybox.off(this.events), window.removeEventListener("message", this.onMessage, !1);
        }
      }
      L.defaults = T;
      class P {
        constructor(t) {
          this.fancybox = t;
          for (const t of [
            "onReady",
            "onClosing",
            "onDone",
            "onPageChange",
            "onCreateSlide",
            "onRemoveSlide",
            "onImageStatusChange",
          ])
            this[t] = this[t].bind(this);
          this.events = {
            ready: this.onReady,
            closing: this.onClosing,
            done: this.onDone,
            "Carousel.change": this.onPageChange,
            "Carousel.createSlide": this.onCreateSlide,
            "Carousel.removeSlide": this.onRemoveSlide,
          };
        }
        onReady() {
          this.fancybox.Carousel.slides.forEach((t) => {
            t.$el && this.setContent(t);
          });
        }
        onDone(t, e) {
          this.handleCursor(e);
        }
        onClosing(t) {
          clearTimeout(this.clickTimer),
            (this.clickTimer = null),
            t.Carousel.slides.forEach((t) => {
              t.$image && (t.state = "destroy"), t.Panzoom && t.Panzoom.detachEvents();
            }),
            "closing" === this.fancybox.state && this.canZoom(t.getSlide()) && this.zoomOut();
        }
        onCreateSlide(t, e, i) {
          "ready" === this.fancybox.state && this.setContent(i);
        }
        onRemoveSlide(t, e, i) {
          i.$image && (i.$el.classList.remove(t.option("Image.canZoomInClass")), i.$image.remove(), (i.$image = null)),
            i.Panzoom && (i.Panzoom.destroy(), (i.Panzoom = null)),
            i.$el && i.$el.dataset && delete i.$el.dataset.imageFit;
        }
        setContent(t) {
          if (t.isDom || t.html || (t.type && "image" !== t.type)) return;
          if (t.$image) return;
          (t.type = "image"), (t.state = "loading");
          const e = document.createElement("div");
          e.style.visibility = "hidden";
          const i = document.createElement("img");
          i.addEventListener("load", (e) => {
            e.stopImmediatePropagation(), this.onImageStatusChange(t);
          }),
            i.addEventListener("error", () => {
              this.onImageStatusChange(t);
            }),
            (i.src = t.src),
            (i.alt = ""),
            (i.draggable = !1),
            i.classList.add("fancybox__image"),
            t.srcset && i.setAttribute("srcset", t.srcset),
            t.sizes && i.setAttribute("sizes", t.sizes),
            (t.$image = i);
          const s = this.fancybox.option("Image.wrap");
          if (s) {
            const a = document.createElement("div");
            a.classList.add("string" == typeof s ? s : "fancybox__image-wrap"),
              a.appendChild(i),
              e.appendChild(a),
              (t.$wrap = a);
          } else e.appendChild(i);
          (t.$el.dataset.imageFit = this.fancybox.option("Image.fit")),
            this.fancybox.setContent(t, e),
            i.complete || i.error ? this.onImageStatusChange(t) : this.fancybox.showLoading(t);
        }
        onImageStatusChange(t) {
          const e = t.$image;
          e &&
            "loading" === t.state &&
            (e.complete && e.naturalWidth && e.naturalHeight
              ? (this.fancybox.hideLoading(t),
                "contain" === this.fancybox.option("Image.fit") && this.initSlidePanzoom(t),
                t.$el.addEventListener("wheel", (e) => this.onWheel(t, e), { passive: !1 }),
                t.$content.addEventListener("click", (e) => this.onClick(t, e), { passive: !1 }),
                this.revealContent(t))
              : this.fancybox.setError(t, "{{IMAGE_ERROR}}"));
        }
        initSlidePanzoom(t) {
          t.Panzoom ||
            ((t.Panzoom = new g(
              t.$el,
              a(!0, this.fancybox.option("Image.Panzoom", {}), {
                viewport: t.$wrap,
                content: t.$image,
                width: t._width,
                height: t._height,
                wrapInner: !1,
                textSelection: !0,
                touch: this.fancybox.option("Image.touch"),
                panOnlyZoomed: !0,
                click: !1,
                wheel: !1,
              })
            )),
            t.Panzoom.on("startAnimation", () => {
              this.fancybox.trigger("Image.startAnimation", t);
            }),
            t.Panzoom.on("endAnimation", () => {
              "zoomIn" === t.state && this.fancybox.done(t),
                this.handleCursor(t),
                this.fancybox.trigger("Image.endAnimation", t);
            }),
            t.Panzoom.on("afterUpdate", () => {
              this.handleCursor(t), this.fancybox.trigger("Image.afterUpdate", t);
            }));
        }
        revealContent(t) {
          null === this.fancybox.Carousel.prevPage && t.index === this.fancybox.options.startIndex && this.canZoom(t)
            ? this.zoomIn()
            : this.fancybox.revealContent(t);
        }
        getZoomInfo(t) {
          const e = t.$thumb.getBoundingClientRect(),
            i = e.width,
            s = e.height,
            a = t.$content.getBoundingClientRect(),
            n = a.width,
            r = a.height,
            o = a.top - e.top,
            l = a.left - e.left;
          let c = this.fancybox.option("Image.zoomOpacity");
          return (
            "auto" === c && (c = Math.abs(i / s - n / r) > 0.1),
            { top: o, left: l, scale: n && i ? i / n : 1, opacity: c }
          );
        }
        canZoom(t) {
          const e = this.fancybox,
            i = e.$container;
          if (window.visualViewport && 1 !== window.visualViewport.scale) return !1;
          if (t.Panzoom && !t.Panzoom.content.width) return !1;
          if (!e.option("Image.zoom") || "contain" !== e.option("Image.fit")) return !1;
          const s = t.$thumb;
          if (!s || "loading" === t.state) return !1;
          i.classList.add("fancybox__no-click");
          const a = s.getBoundingClientRect();
          let n;
          if (this.fancybox.option("Image.ignoreCoveredThumbnail")) {
            const t = document.elementFromPoint(a.left + 1, a.top + 1) === s,
              e = document.elementFromPoint(a.right - 1, a.bottom - 1) === s;
            n = t && e;
          } else n = document.elementFromPoint(a.left + 0.5 * a.width, a.top + 0.5 * a.height) === s;
          return i.classList.remove("fancybox__no-click"), n;
        }
        zoomIn() {
          const t = this.fancybox,
            e = t.getSlide(),
            i = e.Panzoom,
            { top: s, left: a, scale: n, opacity: r } = this.getZoomInfo(e);
          t.trigger("reveal", e),
            i.panTo({ x: -1 * a, y: -1 * s, scale: n, friction: 0, ignoreBounds: !0 }),
            (e.$content.style.visibility = ""),
            (e.state = "zoomIn"),
            !0 === r &&
              i.on("afterTransform", (t) => {
                ("zoomIn" !== e.state && "zoomOut" !== e.state) ||
                  (t.$content.style.opacity = Math.min(1, 1 - (1 - t.content.scale) / (1 - n)));
              }),
            i.panTo({ x: 0, y: 0, scale: 1, friction: this.fancybox.option("Image.zoomFriction") });
        }
        zoomOut() {
          const t = this.fancybox,
            e = t.getSlide(),
            i = e.Panzoom;
          if (!i) return;
          (e.state = "zoomOut"), (t.state = "customClosing"), e.$caption && (e.$caption.style.visibility = "hidden");
          let s = this.fancybox.option("Image.zoomFriction");
          const a = (t) => {
            const { top: a, left: n, scale: r, opacity: o } = this.getZoomInfo(e);
            t || o || (s *= 0.82),
              i.panTo({ x: -1 * n, y: -1 * a, scale: r, friction: s, ignoreBounds: !0 }),
              (s *= 0.98);
          };
          window.addEventListener("scroll", a),
            i.once("endAnimation", () => {
              window.removeEventListener("scroll", a), t.destroy();
            }),
            a();
        }
        handleCursor(t) {
          if ("image" !== t.type || !t.$el) return;
          const e = t.Panzoom,
            i = this.fancybox.option("Image.click", !1, t),
            s = this.fancybox.option("Image.touch"),
            a = t.$el.classList,
            n = this.fancybox.option("Image.canZoomInClass"),
            r = this.fancybox.option("Image.canZoomOutClass");
          a.remove(r),
            a.remove(n),
            e && "toggleZoom" === i
              ? e && 1 === e.content.scale && e.option("maxScale") - e.content.scale > 0.01
                ? a.add(n)
                : e.content.scale > 1 && !s && a.add(r)
              : "close" === i && a.add(r);
        }
        onWheel(t, e) {
          if ("ready" === this.fancybox.state && !1 !== this.fancybox.trigger("Image.wheel", e))
            switch (this.fancybox.option("Image.wheel")) {
              case "zoom":
                "done" === t.state && t.Panzoom && t.Panzoom.zoomWithWheel(e);
                break;
              case "close":
                this.fancybox.close();
                break;
              case "slide":
                this.fancybox[e.deltaY < 0 ? "prev" : "next"]();
            }
        }
        onClick(t, e) {
          if ("ready" !== this.fancybox.state) return;
          const i = t.Panzoom;
          if (
            i &&
            (i.dragPosition.midPoint || 0 !== i.dragOffset.x || 0 !== i.dragOffset.y || 1 !== i.dragOffset.scale)
          )
            return;
          if (this.fancybox.Carousel.Panzoom.lockAxis) return !1;
          const s = (i) => {
              switch (i) {
                case "toggleZoom":
                  e.stopPropagation(), t.Panzoom && t.Panzoom.zoomWithClick(e);
                  break;
                case "close":
                  this.fancybox.close();
                  break;
                case "next":
                  e.stopPropagation(), this.fancybox.next();
              }
            },
            a = this.fancybox.option("Image.click"),
            n = this.fancybox.option("Image.doubleClick");
          n
            ? this.clickTimer
              ? (clearTimeout(this.clickTimer), (this.clickTimer = null), s(n))
              : (this.clickTimer = setTimeout(() => {
                  (this.clickTimer = null), s(a);
                }, 300))
            : s(a);
        }
        onPageChange(t, e) {
          const i = t.getSlide();
          e.slides.forEach((t) => {
            t.Panzoom &&
              "done" === t.state &&
              t.index !== i.index &&
              t.Panzoom.panTo({ x: 0, y: 0, scale: 1, friction: 0.8 });
          });
        }
        attach() {
          this.fancybox.on(this.events);
        }
        detach() {
          this.fancybox.off(this.events);
        }
      }
      P.defaults = {
        canZoomInClass: "can-zoom_in",
        canZoomOutClass: "can-zoom_out",
        zoom: !0,
        zoomOpacity: "auto",
        zoomFriction: 0.82,
        ignoreCoveredThumbnail: !1,
        touch: !0,
        click: "toggleZoom",
        doubleClick: null,
        wheel: "zoom",
        fit: "contain",
        wrap: !1,
        Panzoom: { ratio: 1 },
      };
      class M {
        constructor(t) {
          this.fancybox = t;
          for (const t of ["onChange", "onClosing"]) this[t] = this[t].bind(this);
          (this.events = { initCarousel: this.onChange, "Carousel.change": this.onChange, closing: this.onClosing }),
            (this.hasCreatedHistory = !1),
            (this.origHash = ""),
            (this.timer = null);
        }
        onChange(t) {
          const e = t.Carousel;
          this.timer && clearTimeout(this.timer);
          const i = null === e.prevPage,
            s = t.getSlide(),
            a = new URL(document.URL).hash;
          let n = !1;
          if (s.slug) n = "#" + s.slug;
          else {
            const i = s.$trigger && s.$trigger.dataset,
              a = t.option("slug") || (i && i.fancybox);
            a && a.length && "true" !== a && (n = "#" + a + (e.slides.length > 1 ? "-" + (s.index + 1) : ""));
          }
          i && (this.origHash = a !== n ? a : ""),
            n &&
              a !== n &&
              (this.timer = setTimeout(() => {
                try {
                  window.history[i ? "pushState" : "replaceState"](
                    {},
                    document.title,
                    window.location.pathname + window.location.search + n
                  ),
                    i && (this.hasCreatedHistory = !0);
                } catch (t) {}
              }, 300));
        }
        onClosing() {
          if ((this.timer && clearTimeout(this.timer), !0 !== this.hasSilentClose))
            try {
              return void window.history.replaceState(
                {},
                document.title,
                window.location.pathname + window.location.search + (this.origHash || "")
              );
            } catch (t) {}
        }
        attach(t) {
          t.on(this.events);
        }
        detach(t) {
          t.off(this.events);
        }
        static startFromUrl() {
          const t = M.Fancybox;
          if (!t || t.getInstance() || !1 === t.defaults.Hash) return;
          const { hash: e, slug: i, index: s } = M.getParsedURL();
          if (!i) return;
          let a = document.querySelector(`[data-slug="${e}"]`);
          if ((a && a.dispatchEvent(new CustomEvent("click", { bubbles: !0, cancelable: !0 })), t.getInstance()))
            return;
          const n = document.querySelectorAll(`[data-fancybox="${i}"]`);
          n.length &&
            (null === s && 1 === n.length ? (a = n[0]) : s && (a = n[s - 1]),
            a && a.dispatchEvent(new CustomEvent("click", { bubbles: !0, cancelable: !0 })));
        }
        static onHashChange() {
          const { slug: t, index: e } = M.getParsedURL(),
            i = M.Fancybox,
            s = i && i.getInstance();
          if (s && s.plugins.Hash) {
            if (t) {
              const i = s.Carousel;
              if (t === s.option("slug")) return i.slideTo(e - 1);
              for (let e of i.slides) if (e.slug && e.slug === t) return i.slideTo(e.index);
              const a = s.getSlide(),
                n = a.$trigger && a.$trigger.dataset;
              if (n && n.fancybox === t) return i.slideTo(e - 1);
            }
            (s.plugins.Hash.hasSilentClose = !0), s.close();
          }
          M.startFromUrl();
        }
        static create(t) {
          function e() {
            window.addEventListener("hashchange", M.onHashChange, !1), M.startFromUrl();
          }
          (M.Fancybox = t),
            w &&
              window.requestAnimationFrame(() => {
                /complete|interactive|loaded/.test(document.readyState)
                  ? e()
                  : document.addEventListener("DOMContentLoaded", e);
              });
        }
        static destroy() {
          window.removeEventListener("hashchange", M.onHashChange, !1);
        }
        static getParsedURL() {
          const t = window.location.hash.substr(1),
            e = t.split("-"),
            i = (e.length > 1 && /^\+?\d+$/.test(e[e.length - 1]) && parseInt(e.pop(-1), 10)) || null;
          return { hash: t, slug: e.join("-"), index: i };
        }
      }
      const O = {
        pageXOffset: 0,
        pageYOffset: 0,
        element: () => document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement,
        activate(t) {
          (O.pageXOffset = window.pageXOffset),
            (O.pageYOffset = window.pageYOffset),
            t.requestFullscreen
              ? t.requestFullscreen()
              : t.mozRequestFullScreen
              ? t.mozRequestFullScreen()
              : t.webkitRequestFullscreen
              ? t.webkitRequestFullscreen()
              : t.msRequestFullscreen && t.msRequestFullscreen();
        },
        deactivate() {
          document.exitFullscreen
            ? document.exitFullscreen()
            : document.mozCancelFullScreen
            ? document.mozCancelFullScreen()
            : document.webkitExitFullscreen && document.webkitExitFullscreen();
        },
      };
      class I {
        constructor(t) {
          (this.fancybox = t),
            (this.active = !1),
            (this.handleVisibilityChange = this.handleVisibilityChange.bind(this));
        }
        isActive() {
          return this.active;
        }
        setTimer() {
          if (!this.active || this.timer) return;
          const t = this.fancybox.option("slideshow.delay", 3e3);
          this.timer = setTimeout(() => {
            (this.timer = null),
              this.fancybox.option("infinite") ||
              this.fancybox.getSlide().index !== this.fancybox.Carousel.slides.length - 1
                ? this.fancybox.next()
                : this.fancybox.jumpTo(0, { friction: 0 });
          }, t);
          let e = this.$progress;
          e ||
            ((e = document.createElement("div")),
            e.classList.add("fancybox__progress"),
            this.fancybox.$carousel.parentNode.insertBefore(e, this.fancybox.$carousel),
            (this.$progress = e),
            e.offsetHeight),
            (e.style.transitionDuration = `${t}ms`),
            (e.style.transform = "scaleX(1)");
        }
        clearTimer() {
          clearTimeout(this.timer),
            (this.timer = null),
            this.$progress &&
              ((this.$progress.style.transitionDuration = ""),
              (this.$progress.style.transform = ""),
              this.$progress.offsetHeight);
        }
        activate() {
          this.active ||
            ((this.active = !0),
            this.fancybox.$container.classList.add("has-slideshow"),
            "done" === this.fancybox.getSlide().state && this.setTimer(),
            document.addEventListener("visibilitychange", this.handleVisibilityChange, !1));
        }
        handleVisibilityChange() {
          this.deactivate();
        }
        deactivate() {
          (this.active = !1),
            this.clearTimer(),
            this.fancybox.$container.classList.remove("has-slideshow"),
            document.removeEventListener("visibilitychange", this.handleVisibilityChange, !1);
        }
        toggle() {
          this.active ? this.deactivate() : this.fancybox.Carousel.slides.length > 1 && this.activate();
        }
      }
      const F = {
        display: ["counter", "zoom", "slideshow", "fullscreen", "thumbs", "close"],
        autoEnable: !0,
        items: {
          counter: {
            position: "left",
            type: "div",
            class: "fancybox__counter",
            html: '<span data-fancybox-index=""></span>&nbsp;/&nbsp;<span data-fancybox-count=""></span>',
            attr: { tabindex: -1 },
          },
          prev: {
            type: "button",
            class: "fancybox__button--prev",
            label: "PREV",
            html: '<svg viewBox="0 0 24 24"><path d="M15 4l-8 8 8 8"/></svg>',
            attr: { "data-fancybox-prev": "" },
          },
          next: {
            type: "button",
            class: "fancybox__button--next",
            label: "NEXT",
            html: '<svg viewBox="0 0 24 24"><path d="M8 4l8 8-8 8"/></svg>',
            attr: { "data-fancybox-next": "" },
          },
          fullscreen: {
            type: "button",
            class: "fancybox__button--fullscreen",
            label: "TOGGLE_FULLSCREEN",
            html: '<svg viewBox="0 0 24 24">\n                <g><path d="M3 8 V3h5"></path><path d="M21 8V3h-5"></path><path d="M8 21H3v-5"></path><path d="M16 21h5v-5"></path></g>\n                <g><path d="M7 2v5H2M17 2v5h5M2 17h5v5M22 17h-5v5"/></g>\n            </svg>',
            click: function (t) {
              t.preventDefault(), O.element() ? O.deactivate() : O.activate(this.fancybox.$container);
            },
          },
          slideshow: {
            type: "button",
            class: "fancybox__button--slideshow",
            label: "TOGGLE_SLIDESHOW",
            html: '<svg viewBox="0 0 24 24">\n                <g><path d="M6 4v16"/><path d="M20 12L6 20"/><path d="M20 12L6 4"/></g>\n                <g><path d="M7 4v15M17 4v15"/></g>\n            </svg>',
            click: function (t) {
              t.preventDefault(), this.Slideshow.toggle();
            },
          },
          zoom: {
            type: "button",
            class: "fancybox__button--zoom",
            label: "TOGGLE_ZOOM",
            html: '<svg viewBox="0 0 24 24"><circle cx="10" cy="10" r="7"></circle><path d="M16 16 L21 21"></svg>',
            click: function (t) {
              t.preventDefault();
              const e = this.fancybox.getSlide().Panzoom;
              e && e.toggleZoom();
            },
          },
          download: {
            type: "link",
            label: "DOWNLOAD",
            class: "fancybox__button--download",
            html: '<svg viewBox="0 0 24 24"><path d="M12 15V3m0 12l-4-4m4 4l4-4M2 17l.62 2.48A2 2 0 004.56 21h14.88a2 2 0 001.94-1.51L22 17"/></svg>',
            click: function (t) {
              t.stopPropagation();
            },
          },
          thumbs: {
            type: "button",
            label: "TOGGLE_THUMBS",
            class: "fancybox__button--thumbs",
            html: '<svg viewBox="0 0 24 24"><circle cx="4" cy="4" r="1" /><circle cx="12" cy="4" r="1" transform="rotate(90 12 4)"/><circle cx="20" cy="4" r="1" transform="rotate(90 20 4)"/><circle cx="4" cy="12" r="1" transform="rotate(90 4 12)"/><circle cx="12" cy="12" r="1" transform="rotate(90 12 12)"/><circle cx="20" cy="12" r="1" transform="rotate(90 20 12)"/><circle cx="4" cy="20" r="1" transform="rotate(90 4 20)"/><circle cx="12" cy="20" r="1" transform="rotate(90 12 20)"/><circle cx="20" cy="20" r="1" transform="rotate(90 20 20)"/></svg>',
            click: function (t) {
              t.stopPropagation();
              const e = this.fancybox.plugins.Thumbs;
              e && e.toggle();
            },
          },
          close: {
            type: "button",
            label: "CLOSE",
            class: "fancybox__button--close",
            html: '<svg viewBox="0 0 24 24"><path d="M20 20L4 4m16 0L4 20"></path></svg>',
            attr: { "data-fancybox-close": "", tabindex: 0 },
          },
        },
      };
      class D {
        constructor(t) {
          (this.fancybox = t), (this.$container = null), (this.state = "init");
          for (const t of [
            "onInit",
            "onPrepare",
            "onDone",
            "onKeydown",
            "onClosing",
            "onChange",
            "onSettle",
            "onRefresh",
          ])
            this[t] = this[t].bind(this);
          this.events = {
            init: this.onInit,
            prepare: this.onPrepare,
            done: this.onDone,
            keydown: this.onKeydown,
            closing: this.onClosing,
            "Carousel.change": this.onChange,
            "Carousel.settle": this.onSettle,
            "Carousel.Panzoom.touchStart": () => this.onRefresh(),
            "Image.startAnimation": (t, e) => this.onRefresh(e),
            "Image.afterUpdate": (t, e) => this.onRefresh(e),
          };
        }
        onInit() {
          if (this.fancybox.option("Toolbar.autoEnable")) {
            let t = !1;
            for (const e of this.fancybox.items)
              if ("image" === e.type) {
                t = !0;
                break;
              }
            if (!t) return void (this.state = "disabled");
          }
          for (const t of this.fancybox.option("Toolbar.display"))
            if ("close" === (s(t) ? t.id : t)) {
              this.fancybox.options.closeButton = !1;
              break;
            }
        }
        onPrepare() {
          const t = this.fancybox;
          if (
            "init" === this.state &&
            (this.build(),
            this.update(),
            (this.Slideshow = new I(t)),
            !t.Carousel.prevPage &&
              (t.option("slideshow.autoStart") && this.Slideshow.activate(),
              t.option("fullscreen.autoStart") && !O.element()))
          )
            try {
              O.activate(t.$container);
            } catch (t) {}
        }
        onFsChange() {
          window.scrollTo(O.pageXOffset, O.pageYOffset);
        }
        onSettle() {
          const t = this.fancybox,
            e = this.Slideshow;
          e &&
            e.isActive() &&
            (t.getSlide().index !== t.Carousel.slides.length - 1 || t.option("infinite")
              ? "done" === t.getSlide().state && e.setTimer()
              : e.deactivate());
        }
        onChange() {
          this.update(), this.Slideshow && this.Slideshow.isActive() && this.Slideshow.clearTimer();
        }
        onDone(t, e) {
          const i = this.Slideshow;
          e.index === t.getSlide().index &&
            (this.update(),
            i &&
              i.isActive() &&
              (t.option("infinite") || e.index !== t.Carousel.slides.length - 1 ? i.setTimer() : i.deactivate()));
        }
        onRefresh(t) {
          (t && t.index !== this.fancybox.getSlide().index) ||
            (this.update(),
            !this.Slideshow || !this.Slideshow.isActive() || (t && "done" !== t.state) || this.Slideshow.deactivate());
        }
        onKeydown(t, e, i) {
          " " === e && this.Slideshow && (this.Slideshow.toggle(), i.preventDefault());
        }
        onClosing() {
          this.Slideshow && this.Slideshow.deactivate(),
            document.removeEventListener("fullscreenchange", this.onFsChange);
        }
        createElement(t) {
          let e;
          "div" === t.type
            ? (e = document.createElement("div"))
            : ((e = document.createElement("link" === t.type ? "a" : "button")), e.classList.add("carousel__button")),
            (e.innerHTML = t.html),
            e.setAttribute("tabindex", t.tabindex || 0),
            t.class && e.classList.add(...t.class.split(" "));
          for (const i in t.attr) e.setAttribute(i, t.attr[i]);
          t.label && e.setAttribute("title", this.fancybox.localize(`{{${t.label}}}`)),
            t.click && e.addEventListener("click", t.click.bind(this)),
            "prev" === t.id && e.setAttribute("data-fancybox-prev", ""),
            "next" === t.id && e.setAttribute("data-fancybox-next", "");
          const i = e.querySelector("svg");
          return (
            i &&
              (i.setAttribute("role", "img"),
              i.setAttribute("tabindex", "-1"),
              i.setAttribute("xmlns", "http://www.w3.org/2000/svg")),
            e
          );
        }
        build() {
          this.cleanup();
          const t = this.fancybox.option("Toolbar.items"),
            e = [
              { position: "left", items: [] },
              { position: "center", items: [] },
              { position: "right", items: [] },
            ],
            i = this.fancybox.plugins.Thumbs;
          for (const n of this.fancybox.option("Toolbar.display")) {
            let r, o;
            if (
              (s(n) ? ((r = n.id), (o = a({}, t[r], n))) : ((r = n), (o = t[r])),
              ["counter", "next", "prev", "slideshow"].includes(r) && this.fancybox.items.length < 2)
            )
              continue;
            if ("fullscreen" === r) {
              if (!document.fullscreenEnabled || window.fullScreen) continue;
              document.addEventListener("fullscreenchange", this.onFsChange);
            }
            if ("thumbs" === r && (!i || "disabled" === i.state)) continue;
            if (!o) continue;
            let l = o.position || "right",
              c = e.find((t) => t.position === l);
            c && c.items.push(o);
          }
          const n = document.createElement("div");
          n.classList.add("fancybox__toolbar");
          for (const t of e)
            if (t.items.length) {
              const e = document.createElement("div");
              e.classList.add("fancybox__toolbar__items"), e.classList.add(`fancybox__toolbar__items--${t.position}`);
              for (const i of t.items) e.appendChild(this.createElement(i));
              n.appendChild(e);
            }
          this.fancybox.$carousel.parentNode.insertBefore(n, this.fancybox.$carousel), (this.$container = n);
        }
        update() {
          const t = this.fancybox.getSlide(),
            e = t.index,
            i = this.fancybox.items.length,
            s = t.downloadSrc || ("image" !== t.type || t.error ? null : t.src);
          for (const t of this.fancybox.$container.querySelectorAll("a.fancybox__button--download"))
            s
              ? (t.removeAttribute("disabled"),
                t.removeAttribute("tabindex"),
                t.setAttribute("href", s),
                t.setAttribute("download", s),
                t.setAttribute("target", "_blank"))
              : (t.setAttribute("disabled", ""),
                t.setAttribute("tabindex", -1),
                t.removeAttribute("href"),
                t.removeAttribute("download"));
          const a = t.Panzoom,
            n = a && a.option("maxScale") > a.option("baseScale");
          for (const t of this.fancybox.$container.querySelectorAll(".fancybox__button--zoom"))
            n ? t.removeAttribute("disabled") : t.setAttribute("disabled", "");
          for (const e of this.fancybox.$container.querySelectorAll("[data-fancybox-index]")) e.innerHTML = t.index + 1;
          for (const t of this.fancybox.$container.querySelectorAll("[data-fancybox-count]")) t.innerHTML = i;
          if (!this.fancybox.option("infinite")) {
            for (const t of this.fancybox.$container.querySelectorAll("[data-fancybox-prev]"))
              0 === e ? t.setAttribute("disabled", "") : t.removeAttribute("disabled");
            for (const t of this.fancybox.$container.querySelectorAll("[data-fancybox-next]"))
              e === i - 1 ? t.setAttribute("disabled", "") : t.removeAttribute("disabled");
          }
        }
        cleanup() {
          this.Slideshow && this.Slideshow.isActive() && this.Slideshow.clearTimer(),
            this.$container && this.$container.remove(),
            (this.$container = null);
        }
        attach() {
          this.fancybox.on(this.events);
        }
        detach() {
          this.fancybox.off(this.events), this.cleanup();
        }
      }
      D.defaults = F;
      const z = {
          ScrollLock: class {
            constructor(t) {
              (this.fancybox = t), (this.viewport = null), (this.pendingUpdate = null);
              for (const t of ["onReady", "onResize", "onTouchstart", "onTouchmove"]) this[t] = this[t].bind(this);
            }
            onReady() {
              const t = window.visualViewport;
              t &&
                ((this.viewport = t),
                (this.startY = 0),
                t.addEventListener("resize", this.onResize),
                this.updateViewport()),
                window.addEventListener("touchstart", this.onTouchstart, { passive: !1 }),
                window.addEventListener("touchmove", this.onTouchmove, { passive: !1 }),
                window.addEventListener("wheel", this.onWheel, { passive: !1 });
            }
            onResize() {
              this.updateViewport();
            }
            updateViewport() {
              const t = this.fancybox,
                e = this.viewport,
                i = e.scale || 1,
                s = t.$container;
              if (!s) return;
              let a = "",
                n = "",
                r = "";
              i - 1 > 0.1 &&
                ((a = e.width * i + "px"),
                (n = e.height * i + "px"),
                (r = `translate3d(${e.offsetLeft}px, ${e.offsetTop}px, 0) scale(${1 / i})`)),
                (s.style.width = a),
                (s.style.height = n),
                (s.style.transform = r);
            }
            onTouchstart(t) {
              this.startY = t.touches ? t.touches[0].screenY : t.screenY;
            }
            onTouchmove(t) {
              const e = this.startY,
                i = window.innerWidth / window.document.documentElement.clientWidth;
              if (!t.cancelable) return;
              if (t.touches.length > 1 || 1 !== i) return;
              const s = r(t.composedPath()[0]);
              if (!s) return void t.preventDefault();
              const a = window.getComputedStyle(s),
                n = parseInt(a.getPropertyValue("height"), 10),
                o = t.touches ? t.touches[0].screenY : t.screenY,
                l = e <= o && 0 === s.scrollTop,
                c = e >= o && s.scrollHeight - s.scrollTop === n;
              (l || c) && t.preventDefault();
            }
            onWheel(t) {
              r(t.composedPath()[0]) || t.preventDefault();
            }
            cleanup() {
              this.pendingUpdate && (cancelAnimationFrame(this.pendingUpdate), (this.pendingUpdate = null));
              const t = this.viewport;
              t && (t.removeEventListener("resize", this.onResize), (this.viewport = null)),
                window.removeEventListener("touchstart", this.onTouchstart, !1),
                window.removeEventListener("touchmove", this.onTouchmove, !1),
                window.removeEventListener("wheel", this.onWheel, { passive: !1 });
            }
            attach() {
              this.fancybox.on("initLayout", this.onReady);
            }
            detach() {
              this.fancybox.off("initLayout", this.onReady), this.cleanup();
            }
          },
          Thumbs: A,
          Html: L,
          Toolbar: D,
          Image: P,
          Hash: M,
        },
        N = {
          startIndex: 0,
          preload: 1,
          infinite: !0,
          showClass: "fancybox-zoomInUp",
          hideClass: "fancybox-fadeOut",
          animated: !0,
          hideScrollbar: !0,
          parentEl: null,
          mainClass: null,
          autoFocus: !0,
          trapFocus: !0,
          placeFocusBack: !0,
          click: "close",
          closeButton: "inside",
          dragToClose: !0,
          keyboard: {
            Escape: "close",
            Delete: "close",
            Backspace: "close",
            PageUp: "next",
            PageDown: "prev",
            ArrowUp: "next",
            ArrowDown: "prev",
            ArrowRight: "next",
            ArrowLeft: "prev",
          },
          template: {
            closeButton:
              '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg>',
            spinner:
              '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="25 25 50 50" tabindex="-1"><circle cx="50" cy="50" r="20"/></svg>',
            main: null,
          },
          l10n: {
            CLOSE: "Close",
            NEXT: "Next",
            PREV: "Previous",
            MODAL: "You can close this modal content with the ESC key",
            ERROR: "Something Went Wrong, Please Try Again Later",
            IMAGE_ERROR: "Image Not Found",
            ELEMENT_NOT_FOUND: "HTML Element Not Found",
            AJAX_NOT_FOUND: "Error Loading AJAX : Not Found",
            AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden",
            IFRAME_ERROR: "Error Loading Page",
            TOGGLE_ZOOM: "Toggle zoom level",
            TOGGLE_THUMBS: "Toggle thumbnails",
            TOGGLE_SLIDESHOW: "Toggle slideshow",
            TOGGLE_FULLSCREEN: "Toggle full-screen mode",
            DOWNLOAD: "Download",
          },
        },
        R = new Map();
      let _ = 0;
      class B extends u {
        constructor(t, e = {}) {
          (t = t.map((t) => (t.width && (t._width = t.width), t.height && (t._height = t.height), t))),
            super(a(!0, {}, N, e)),
            this.bindHandlers(),
            (this.state = "init"),
            this.setItems(t),
            this.attachPlugins(B.Plugins),
            this.trigger("init"),
            !0 === this.option("hideScrollbar") && this.hideScrollbar(),
            this.initLayout(),
            this.initCarousel(),
            this.attachEvents(),
            R.set(this.id, this),
            this.trigger("prepare"),
            (this.state = "ready"),
            this.trigger("ready"),
            this.$container.setAttribute("aria-hidden", "false"),
            this.option("trapFocus") && this.focus();
        }
        option(t, ...e) {
          const i = this.getSlide();
          let s = i ? i[t] : void 0;
          return void 0 !== s ? ("function" == typeof s && (s = s.call(this, this, ...e)), s) : super.option(t, ...e);
        }
        bindHandlers() {
          for (const t of [
            "onMousedown",
            "onKeydown",
            "onClick",
            "onFocus",
            "onCreateSlide",
            "onSettle",
            "onTouchMove",
            "onTouchEnd",
            "onTransform",
          ])
            this[t] = this[t].bind(this);
        }
        attachEvents() {
          document.addEventListener("mousedown", this.onMousedown),
            document.addEventListener("keydown", this.onKeydown, !0),
            this.option("trapFocus") && document.addEventListener("focus", this.onFocus, !0),
            this.$container.addEventListener("click", this.onClick);
        }
        detachEvents() {
          document.removeEventListener("mousedown", this.onMousedown),
            document.removeEventListener("keydown", this.onKeydown, !0),
            document.removeEventListener("focus", this.onFocus, !0),
            this.$container.removeEventListener("click", this.onClick);
        }
        initLayout() {
          this.$root = this.option("parentEl") || document.body;
          let t = this.option("template.main");
          t &&
            (this.$root.insertAdjacentHTML("beforeend", this.localize(t)),
            (this.$container = this.$root.querySelector(".fancybox__container"))),
            this.$container ||
              ((this.$container = document.createElement("div")), this.$root.appendChild(this.$container)),
            (this.$container.onscroll = () => ((this.$container.scrollLeft = 0), !1)),
            Object.entries({
              class: "fancybox__container",
              role: "dialog",
              tabIndex: "-1",
              "aria-modal": "true",
              "aria-hidden": "true",
              "aria-label": this.localize("{{MODAL}}"),
            }).forEach((t) => this.$container.setAttribute(...t)),
            this.option("animated") && this.$container.classList.add("is-animated"),
            (this.$backdrop = this.$container.querySelector(".fancybox__backdrop")),
            this.$backdrop ||
              ((this.$backdrop = document.createElement("div")),
              this.$backdrop.classList.add("fancybox__backdrop"),
              this.$container.appendChild(this.$backdrop)),
            (this.$carousel = this.$container.querySelector(".fancybox__carousel")),
            this.$carousel ||
              ((this.$carousel = document.createElement("div")),
              this.$carousel.classList.add("fancybox__carousel"),
              this.$container.appendChild(this.$carousel)),
            (this.$container.Fancybox = this),
            (this.id = this.$container.getAttribute("id")),
            this.id || ((this.id = this.options.id || ++_), this.$container.setAttribute("id", "fancybox-" + this.id));
          const e = this.option("mainClass");
          return (
            e && this.$container.classList.add(...e.split(" ")),
            document.documentElement.classList.add("with-fancybox"),
            this.trigger("initLayout"),
            this
          );
        }
        setItems(t) {
          const e = [];
          for (const i of t) {
            const t = i.$trigger;
            if (t) {
              const e = t.dataset || {};
              (i.src = e.src || t.getAttribute("href") || i.src),
                (i.type = e.type || i.type),
                !i.src && t instanceof HTMLImageElement && (i.src = t.currentSrc || i.$trigger.src);
            }
            let s = i.$thumb;
            if (!s) {
              let t = i.$trigger && i.$trigger.origTarget;
              t && (s = t instanceof HTMLImageElement ? t : t.querySelector("img:not([aria-hidden])")),
                !s &&
                  i.$trigger &&
                  (s =
                    i.$trigger instanceof HTMLImageElement
                      ? i.$trigger
                      : i.$trigger.querySelector("img:not([aria-hidden])"));
            }
            i.$thumb = s || null;
            let a = i.thumb;
            !a && s && ((a = s.currentSrc || s.src), !a && s.dataset && (a = s.dataset.lazySrc || s.dataset.src)),
              a || "image" !== i.type || (a = i.src),
              (i.thumb = a || null),
              (i.caption = i.caption || ""),
              e.push(i);
          }
          this.items = e;
        }
        initCarousel() {
          return (
            (this.Carousel = new y(
              this.$carousel,
              a(
                !0,
                {},
                {
                  prefix: "",
                  classNames: { viewport: "fancybox__viewport", track: "fancybox__track", slide: "fancybox__slide" },
                  textSelection: !0,
                  preload: this.option("preload"),
                  friction: 0.88,
                  slides: this.items,
                  initialPage: this.options.startIndex,
                  slidesPerPage: 1,
                  infiniteX: this.option("infinite"),
                  infiniteY: !0,
                  l10n: this.option("l10n"),
                  Dots: !1,
                  Navigation: {
                    classNames: { main: "fancybox__nav", button: "carousel__button", next: "is-next", prev: "is-prev" },
                  },
                  Panzoom: {
                    textSelection: !0,
                    panOnlyZoomed: () =>
                      this.Carousel &&
                      this.Carousel.pages &&
                      this.Carousel.pages.length < 2 &&
                      !this.option("dragToClose"),
                    lockAxis: () => {
                      if (this.Carousel) {
                        let t = "x";
                        return this.option("dragToClose") && (t += "y"), t;
                      }
                    },
                  },
                  on: {
                    "*": (t, ...e) => this.trigger(`Carousel.${t}`, ...e),
                    init: (t) => (this.Carousel = t),
                    createSlide: this.onCreateSlide,
                    settle: this.onSettle,
                  },
                },
                this.option("Carousel")
              )
            )),
            this.option("dragToClose") &&
              this.Carousel.Panzoom.on({
                touchMove: this.onTouchMove,
                afterTransform: this.onTransform,
                touchEnd: this.onTouchEnd,
              }),
            this.trigger("initCarousel"),
            this
          );
        }
        onCreateSlide(t, e) {
          let i = e.caption || "";
          if (
            ("function" == typeof this.options.caption && (i = this.options.caption.call(this, this, this.Carousel, e)),
            "string" == typeof i && i.length)
          ) {
            const t = document.createElement("div"),
              s = `fancybox__caption_${this.id}_${e.index}`;
            (t.className = "fancybox__caption"),
              (t.innerHTML = i),
              t.setAttribute("id", s),
              (e.$caption = e.$el.appendChild(t)),
              e.$el.classList.add("has-caption"),
              e.$el.setAttribute("aria-labelledby", s);
          }
        }
        onSettle() {
          this.option("autoFocus") && this.focus();
        }
        onFocus(t) {
          this.isTopmost() && this.focus(t);
        }
        onClick(t) {
          if (t.defaultPrevented) return;
          let e = t.composedPath()[0];
          if (e.matches("[data-fancybox-close]")) return t.preventDefault(), void B.close(!1, t);
          if (e.matches("[data-fancybox-next]")) return t.preventDefault(), void B.next();
          if (e.matches("[data-fancybox-prev]")) return t.preventDefault(), void B.prev();
          const i = document.activeElement;
          if (i) {
            if (i.closest("[contenteditable]")) return;
            e.matches(S) || i.blur();
          }
          if (!e.closest(".fancybox__content") && !getSelection().toString().length && !1 !== this.trigger("click", t))
            switch (this.option("click")) {
              case "close":
                this.close();
                break;
              case "next":
                this.next();
            }
        }
        onTouchMove() {
          const t = this.getSlide().Panzoom;
          return !t || 1 === t.content.scale;
        }
        onTouchEnd(t) {
          const e = t.dragOffset.y;
          Math.abs(e) >= 150 || (Math.abs(e) >= 35 && t.dragOffset.time < 350)
            ? (this.option("hideClass") &&
                (this.getSlide().hideClass = "fancybox-throwOut" + (t.content.y < 0 ? "Up" : "Down")),
              this.close())
            : "y" === t.lockAxis && t.panTo({ y: 0 });
        }
        onTransform(t) {
          if (this.$backdrop) {
            const e = Math.abs(t.content.y),
              i = e < 1 ? "" : Math.max(0.33, Math.min(1, 1 - (e / t.content.fitHeight) * 1.5));
            this.$container.style.setProperty("--fancybox-ts", i ? "0s" : ""),
              this.$container.style.setProperty("--fancybox-opacity", i);
          }
        }
        onMousedown() {
          "ready" === this.state && document.body.classList.add("is-using-mouse");
        }
        onKeydown(t) {
          if (!this.isTopmost()) return;
          document.body.classList.remove("is-using-mouse");
          const e = t.key,
            i = this.option("keyboard");
          if (!i || t.ctrlKey || t.altKey || t.shiftKey) return;
          const s = t.composedPath()[0],
            a = document.activeElement && document.activeElement.classList,
            n = a && a.contains("carousel__button");
          if (
            "Escape" !== e &&
            !n &&
            (t.target.isContentEditable ||
              -1 !== ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(s.nodeName))
          )
            return;
          if (!1 === this.trigger("keydown", e, t)) return;
          const r = i[e];
          "function" == typeof this[r] && this[r]();
        }
        getSlide() {
          const t = this.Carousel;
          if (!t) return null;
          const e = null === t.page ? t.option("initialPage") : t.page,
            i = t.pages || [];
          return i.length && i[e] ? i[e].slides[0] : null;
        }
        focus(t) {
          if (B.ignoreFocusChange) return;
          if (["init", "closing", "customClosing", "destroy"].indexOf(this.state) > -1) return;
          const e = this.$container,
            i = this.getSlide(),
            s = "done" === i.state ? i.$el : null;
          if (s && s.contains(document.activeElement)) return;
          t && t.preventDefault(), (B.ignoreFocusChange = !0);
          const a = Array.from(e.querySelectorAll(S));
          let n,
            r = [];
          for (let t of a) {
            const e = t.offsetParent,
              i = s && s.contains(t),
              a = !this.Carousel.$viewport.contains(t);
            e && (i || a)
              ? (r.push(t),
                void 0 !== t.dataset.origTabindex &&
                  ((t.tabIndex = t.dataset.origTabindex), t.removeAttribute("data-orig-tabindex")),
                (t.hasAttribute("autoFocus") || (!n && i && !t.classList.contains("carousel__button"))) && (n = t))
              : ((t.dataset.origTabindex =
                  void 0 === t.dataset.origTabindex ? t.getAttribute("tabindex") : t.dataset.origTabindex),
                (t.tabIndex = -1));
          }
          t
            ? r.indexOf(t.target) > -1
              ? (this.lastFocus = t.target)
              : this.lastFocus === e
              ? C(r[r.length - 1])
              : C(e)
            : this.option("autoFocus") && n
            ? C(n)
            : r.indexOf(document.activeElement) < 0 && C(e),
            (this.lastFocus = document.activeElement),
            (B.ignoreFocusChange = !1);
        }
        hideScrollbar() {
          if (!w) return;
          const t = window.innerWidth - document.documentElement.getBoundingClientRect().width,
            e = "fancybox-style-noscroll";
          let i = document.getElementById(e);
          i ||
            (t > 0 &&
              ((i = document.createElement("style")),
              (i.id = e),
              (i.type = "text/css"),
              (i.innerHTML = `.compensate-for-scrollbar {padding-right: ${t}px;}`),
              document.getElementsByTagName("head")[0].appendChild(i),
              document.body.classList.add("compensate-for-scrollbar")));
        }
        revealScrollbar() {
          document.body.classList.remove("compensate-for-scrollbar");
          const t = document.getElementById("fancybox-style-noscroll");
          t && t.remove();
        }
        clearContent(t) {
          this.Carousel.trigger("removeSlide", t),
            t.$content && (t.$content.remove(), (t.$content = null)),
            t.$closeButton && (t.$closeButton.remove(), (t.$closeButton = null)),
            t._className && t.$el.classList.remove(t._className);
        }
        setContent(t, e, i = {}) {
          let s;
          const a = t.$el;
          if (e instanceof HTMLElement)
            ["img", "iframe", "video", "audio"].indexOf(e.nodeName.toLowerCase()) > -1
              ? ((s = document.createElement("div")), s.appendChild(e))
              : (s = e);
          else {
            const t = document.createRange().createContextualFragment(e);
            (s = document.createElement("div")), s.appendChild(t);
          }
          if ((t.filter && !t.error && (s = s.querySelector(t.filter)), s instanceof Element))
            return (
              (t._className = `has-${i.suffix || t.type || "unknown"}`),
              a.classList.add(t._className),
              s.classList.add("fancybox__content"),
              ("none" !== s.style.display && "none" !== getComputedStyle(s).getPropertyValue("display")) ||
                (s.style.display = t.display || this.option("defaultDisplay") || "flex"),
              t.id && s.setAttribute("id", t.id),
              (t.$content = s),
              a.prepend(s),
              this.manageCloseButton(t),
              "loading" !== t.state && this.revealContent(t),
              s
            );
          this.setError(t, "{{ELEMENT_NOT_FOUND}}");
        }
        manageCloseButton(t) {
          const e = void 0 === t.closeButton ? this.option("closeButton") : t.closeButton;
          if (!e || ("top" === e && this.$closeButton)) return;
          const i = document.createElement("button");
          i.classList.add("carousel__button", "is-close"),
            i.setAttribute("title", this.options.l10n.CLOSE),
            (i.innerHTML = this.option("template.closeButton")),
            i.addEventListener("click", (t) => this.close(t)),
            "inside" === e
              ? (t.$closeButton && t.$closeButton.remove(), (t.$closeButton = t.$content.appendChild(i)))
              : (this.$closeButton = this.$container.insertBefore(i, this.$container.firstChild));
        }
        revealContent(t) {
          this.trigger("reveal", t), (t.$content.style.visibility = "");
          let e = !1;
          t.error ||
            "loading" === t.state ||
            null !== this.Carousel.prevPage ||
            t.index !== this.options.startIndex ||
            (e = void 0 === t.showClass ? this.option("showClass") : t.showClass),
            e
              ? ((t.state = "animating"),
                this.animateCSS(t.$content, e, () => {
                  this.done(t);
                }))
              : this.done(t);
        }
        animateCSS(t, e, i) {
          if ((t && t.dispatchEvent(new CustomEvent("animationend", { bubbles: !0, cancelable: !0 })), !t || !e))
            return void ("function" == typeof i && i());
          const s = function (a) {
            a.currentTarget === this && (t.removeEventListener("animationend", s), i && i(), t.classList.remove(e));
          };
          t.addEventListener("animationend", s), t.classList.add(e);
        }
        done(t) {
          (t.state = "done"), this.trigger("done", t);
          const e = this.getSlide();
          e && t.index === e.index && this.option("autoFocus") && this.focus();
        }
        setError(t, e) {
          (t.error = e), this.hideLoading(t), this.clearContent(t);
          const i = document.createElement("div");
          i.classList.add("fancybox-error"),
            (i.innerHTML = this.localize(e || "<p>{{ERROR}}</p>")),
            this.setContent(t, i, { suffix: "error" });
        }
        showLoading(t) {
          (t.state = "loading"), t.$el.classList.add("is-loading");
          let e = t.$el.querySelector(".fancybox__spinner");
          e ||
            ((e = document.createElement("div")),
            e.classList.add("fancybox__spinner"),
            (e.innerHTML = this.option("template.spinner")),
            e.addEventListener("click", () => {
              this.Carousel.Panzoom.velocity || this.close();
            }),
            t.$el.prepend(e));
        }
        hideLoading(t) {
          const e = t.$el && t.$el.querySelector(".fancybox__spinner");
          e && (e.remove(), t.$el.classList.remove("is-loading")),
            "loading" === t.state && (this.trigger("load", t), (t.state = "ready"));
        }
        next() {
          const t = this.Carousel;
          t && t.pages.length > 1 && t.slideNext();
        }
        prev() {
          const t = this.Carousel;
          t && t.pages.length > 1 && t.slidePrev();
        }
        jumpTo(...t) {
          this.Carousel && this.Carousel.slideTo(...t);
        }
        isClosing() {
          return ["closing", "customClosing", "destroy"].includes(this.state);
        }
        isTopmost() {
          return B.getInstance().id == this.id;
        }
        close(t) {
          if ((t && t.preventDefault(), this.isClosing())) return;
          if (!1 === this.trigger("shouldClose", t)) return;
          if (
            ((this.state = "closing"),
            this.Carousel.Panzoom.destroy(),
            this.detachEvents(),
            this.trigger("closing", t),
            "destroy" === this.state)
          )
            return;
          this.$container.setAttribute("aria-hidden", "true"), this.$container.classList.add("is-closing");
          const e = this.getSlide();
          if (
            (this.Carousel.slides.forEach((t) => {
              t.$content && t.index !== e.index && this.Carousel.trigger("removeSlide", t);
            }),
            "closing" === this.state)
          ) {
            const t = void 0 === e.hideClass ? this.option("hideClass") : e.hideClass;
            this.animateCSS(
              e.$content,
              t,
              () => {
                this.destroy();
              },
              !0
            );
          }
        }
        destroy() {
          if ("destroy" === this.state) return;
          (this.state = "destroy"), this.trigger("destroy");
          const t = this.option("placeFocusBack") ? this.option("triggerTarget", this.getSlide().$trigger) : null;
          this.Carousel.destroy(),
            this.detachPlugins(),
            (this.Carousel = null),
            (this.options = {}),
            (this.events = {}),
            this.$container.remove(),
            (this.$container = this.$backdrop = this.$carousel = null),
            t && C(t),
            R.delete(this.id);
          const e = B.getInstance();
          e
            ? e.focus()
            : (document.documentElement.classList.remove("with-fancybox"),
              document.body.classList.remove("is-using-mouse"),
              this.revealScrollbar());
        }
        static show(t, e = {}) {
          return new B(t, e);
        }
        static fromEvent(t, e = {}) {
          if (t.defaultPrevented) return;
          if (t.button && 0 !== t.button) return;
          if (t.ctrlKey || t.metaKey || t.shiftKey) return;
          const i = t.composedPath()[0];
          let s,
            a,
            n,
            r = i;
          if (
            ((r.matches("[data-fancybox-trigger]") || (r = r.closest("[data-fancybox-trigger]"))) &&
              ((e.triggerTarget = r), (s = r && r.dataset && r.dataset.fancyboxTrigger)),
            s)
          ) {
            const t = document.querySelectorAll(`[data-fancybox="${s}"]`),
              e = parseInt(r.dataset.fancyboxIndex, 10) || 0;
            r = t.length ? t[e] : r;
          }
          Array.from(B.openers.keys())
            .reverse()
            .some((e) => {
              n = r || i;
              let s = !1;
              try {
                n instanceof Element &&
                  ("string" == typeof e || e instanceof String) &&
                  (s = n.matches(e) || (n = n.closest(e)));
              } catch (t) {}
              return !!s && (t.preventDefault(), (a = e), !0);
            });
          let o = !1;
          if (a) {
            (e.event = t), (e.target = n), (n.origTarget = i), (o = B.fromOpener(a, e));
            const s = B.getInstance();
            s && "ready" === s.state && t.detail && document.body.classList.add("is-using-mouse");
          }
          return o;
        }
        static fromOpener(t, e = {}) {
          let i = [],
            s = e.startIndex || 0,
            n = e.target || null;
          const r = void 0 !== (e = a({}, e, B.openers.get(t))).groupAll && e.groupAll,
            o = void 0 === e.groupAttr ? "data-fancybox" : e.groupAttr,
            l = o && n ? n.getAttribute(`${o}`) : "";
          if (!n || l || r) {
            const s = e.root || (n ? n.getRootNode() : document.body);
            i = [].slice.call(s.querySelectorAll(t));
          }
          if ((n && !r && (i = l ? i.filter((t) => t.getAttribute(`${o}`) === l) : [n]), !i.length)) return !1;
          const c = B.getInstance();
          return (
            !(c && i.indexOf(c.options.$trigger) > -1) &&
            ((s = n ? i.indexOf(n) : s),
            (i = i.map(function (t) {
              const e = ["false", "0", "no", "null", "undefined"],
                i = ["true", "1", "yes"],
                s = Object.assign({}, t.dataset),
                a = {};
              for (let [t, n] of Object.entries(s))
                if ("fancybox" !== t)
                  if ("width" === t || "height" === t) a[`_${t}`] = n;
                  else if ("string" == typeof n || n instanceof String)
                    if (e.indexOf(n) > -1) a[t] = !1;
                    else if (i.indexOf(a[t]) > -1) a[t] = !0;
                    else
                      try {
                        a[t] = JSON.parse(n);
                      } catch (e) {
                        a[t] = n;
                      }
                  else a[t] = n;
              return t instanceof Element && (a.$trigger = t), a;
            })),
            new B(i, a({}, e, { startIndex: s, $trigger: n })))
          );
        }
        static bind(t, e = {}) {
          function i() {
            document.body.addEventListener("click", B.fromEvent, !1);
          }
          w &&
            (B.openers.size ||
              (/complete|interactive|loaded/.test(document.readyState)
                ? i()
                : document.addEventListener("DOMContentLoaded", i)),
            B.openers.set(t, e));
        }
        static unbind(t) {
          B.openers.delete(t), B.openers.size || B.destroy();
        }
        static destroy() {
          let t;
          for (; (t = B.getInstance()); ) t.destroy();
          (B.openers = new Map()), document.body.removeEventListener("click", B.fromEvent, !1);
        }
        static getInstance(t) {
          return t
            ? R.get(t)
            : Array.from(R.values())
                .reverse()
                .find((t) => !t.isClosing() && t) || null;
        }
        static close(t = !0, e) {
          if (t) for (const t of R.values()) t.close(e);
          else {
            const t = B.getInstance();
            t && t.close(e);
          }
        }
        static next() {
          const t = B.getInstance();
          t && t.next();
        }
        static prev() {
          const t = B.getInstance();
          t && t.prev();
        }
      }
      (B.version = "4.0.31"), (B.defaults = N), (B.openers = new Map()), (B.Plugins = z), B.bind("[data-fancybox]");
      for (const [t, e] of Object.entries(B.Plugins || {})) "function" == typeof e.create && e.create(B);
    },
    599: function (t, e, i) {
      "use strict";
      i.d(e, {
        Mx: function () {
          return _;
        },
        Qr: function () {
          return j;
        },
      });
      class s {
        constructor(t, e, i) {
          (this.eventTarget = t), (this.eventName = e), (this.eventOptions = i), (this.unorderedBindings = new Set());
        }
        connect() {
          this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
        }
        disconnect() {
          this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
        }
        bindingConnected(t) {
          this.unorderedBindings.add(t);
        }
        bindingDisconnected(t) {
          this.unorderedBindings.delete(t);
        }
        handleEvent(t) {
          const e = (function (t) {
            if ("immediatePropagationStopped" in t) return t;
            {
              const { stopImmediatePropagation: e } = t;
              return Object.assign(t, {
                immediatePropagationStopped: !1,
                stopImmediatePropagation() {
                  (this.immediatePropagationStopped = !0), e.call(this);
                },
              });
            }
          })(t);
          for (const t of this.bindings) {
            if (e.immediatePropagationStopped) break;
            t.handleEvent(e);
          }
        }
        get bindings() {
          return Array.from(this.unorderedBindings).sort((t, e) => {
            const i = t.index,
              s = e.index;
            return i < s ? -1 : i > s ? 1 : 0;
          });
        }
      }
      class a {
        constructor(t) {
          (this.application = t), (this.eventListenerMaps = new Map()), (this.started = !1);
        }
        start() {
          this.started || ((this.started = !0), this.eventListeners.forEach((t) => t.connect()));
        }
        stop() {
          this.started && ((this.started = !1), this.eventListeners.forEach((t) => t.disconnect()));
        }
        get eventListeners() {
          return Array.from(this.eventListenerMaps.values()).reduce((t, e) => t.concat(Array.from(e.values())), []);
        }
        bindingConnected(t) {
          this.fetchEventListenerForBinding(t).bindingConnected(t);
        }
        bindingDisconnected(t) {
          this.fetchEventListenerForBinding(t).bindingDisconnected(t);
        }
        handleError(t, e, i = {}) {
          this.application.handleError(t, `Error ${e}`, i);
        }
        fetchEventListenerForBinding(t) {
          const { eventTarget: e, eventName: i, eventOptions: s } = t;
          return this.fetchEventListener(e, i, s);
        }
        fetchEventListener(t, e, i) {
          const s = this.fetchEventListenerMapForEventTarget(t),
            a = this.cacheKey(e, i);
          let n = s.get(a);
          return n || ((n = this.createEventListener(t, e, i)), s.set(a, n)), n;
        }
        createEventListener(t, e, i) {
          const a = new s(t, e, i);
          return this.started && a.connect(), a;
        }
        fetchEventListenerMapForEventTarget(t) {
          let e = this.eventListenerMaps.get(t);
          return e || ((e = new Map()), this.eventListenerMaps.set(t, e)), e;
        }
        cacheKey(t, e) {
          const i = [t];
          return (
            Object.keys(e)
              .sort()
              .forEach((t) => {
                i.push(`${e[t] ? "" : "!"}${t}`);
              }),
            i.join(":")
          );
        }
      }
      const n = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/;
      function r(t) {
        return t.replace(/(?:[_-])([a-z0-9])/g, (t, e) => e.toUpperCase());
      }
      function o(t) {
        return t.charAt(0).toUpperCase() + t.slice(1);
      }
      function l(t) {
        return t.replace(/([A-Z])/g, (t, e) => `-${e.toLowerCase()}`);
      }
      const c = {
        a: (t) => "click",
        button: (t) => "click",
        form: (t) => "submit",
        details: (t) => "toggle",
        input: (t) => ("submit" == t.getAttribute("type") ? "click" : "input"),
        select: (t) => "change",
        textarea: (t) => "input",
      };
      function h(t) {
        throw new Error(t);
      }
      function d(t) {
        try {
          return JSON.parse(t);
        } catch (e) {
          return t;
        }
      }
      class u {
        constructor(t, e) {
          (this.context = t), (this.action = e);
        }
        get index() {
          return this.action.index;
        }
        get eventTarget() {
          return this.action.eventTarget;
        }
        get eventOptions() {
          return this.action.eventOptions;
        }
        get identifier() {
          return this.context.identifier;
        }
        handleEvent(t) {
          this.willBeInvokedByEvent(t) && this.invokeWithEvent(t);
        }
        get eventName() {
          return this.action.eventName;
        }
        get method() {
          const t = this.controller[this.methodName];
          if ("function" == typeof t) return t;
          throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
        }
        invokeWithEvent(t) {
          const { target: e, currentTarget: i } = t;
          try {
            const { params: s } = this.action,
              a = Object.assign(t, { params: s });
            this.method.call(this.controller, a),
              this.context.logDebugActivity(this.methodName, {
                event: t,
                target: e,
                currentTarget: i,
                action: this.methodName,
              });
          } catch (e) {
            const { identifier: i, controller: s, element: a, index: n } = this,
              r = { identifier: i, controller: s, element: a, index: n, event: t };
            this.context.handleError(e, `invoking action "${this.action}"`, r);
          }
        }
        willBeInvokedByEvent(t) {
          const e = t.target;
          return (
            this.element === e ||
            (e instanceof Element && this.element.contains(e)
              ? this.scope.containsElement(e)
              : this.scope.containsElement(this.action.element))
          );
        }
        get controller() {
          return this.context.controller;
        }
        get methodName() {
          return this.action.methodName;
        }
        get element() {
          return this.scope.element;
        }
        get scope() {
          return this.context.scope;
        }
      }
      class p {
        constructor(t, e) {
          (this.mutationObserverInit = { attributes: !0, childList: !0, subtree: !0 }),
            (this.element = t),
            (this.started = !1),
            (this.delegate = e),
            (this.elements = new Set()),
            (this.mutationObserver = new MutationObserver((t) => this.processMutations(t)));
        }
        start() {
          this.started ||
            ((this.started = !0),
            this.mutationObserver.observe(this.element, this.mutationObserverInit),
            this.refresh());
        }
        pause(t) {
          this.started && (this.mutationObserver.disconnect(), (this.started = !1)),
            t(),
            this.started ||
              (this.mutationObserver.observe(this.element, this.mutationObserverInit), (this.started = !0));
        }
        stop() {
          this.started &&
            (this.mutationObserver.takeRecords(), this.mutationObserver.disconnect(), (this.started = !1));
        }
        refresh() {
          if (this.started) {
            const t = new Set(this.matchElementsInTree());
            for (const e of Array.from(this.elements)) t.has(e) || this.removeElement(e);
            for (const e of Array.from(t)) this.addElement(e);
          }
        }
        processMutations(t) {
          if (this.started) for (const e of t) this.processMutation(e);
        }
        processMutation(t) {
          "attributes" == t.type
            ? this.processAttributeChange(t.target, t.attributeName)
            : "childList" == t.type && (this.processRemovedNodes(t.removedNodes), this.processAddedNodes(t.addedNodes));
        }
        processAttributeChange(t, e) {
          const i = t;
          this.elements.has(i)
            ? this.delegate.elementAttributeChanged && this.matchElement(i)
              ? this.delegate.elementAttributeChanged(i, e)
              : this.removeElement(i)
            : this.matchElement(i) && this.addElement(i);
        }
        processRemovedNodes(t) {
          for (const e of Array.from(t)) {
            const t = this.elementFromNode(e);
            t && this.processTree(t, this.removeElement);
          }
        }
        processAddedNodes(t) {
          for (const e of Array.from(t)) {
            const t = this.elementFromNode(e);
            t && this.elementIsActive(t) && this.processTree(t, this.addElement);
          }
        }
        matchElement(t) {
          return this.delegate.matchElement(t);
        }
        matchElementsInTree(t = this.element) {
          return this.delegate.matchElementsInTree(t);
        }
        processTree(t, e) {
          for (const i of this.matchElementsInTree(t)) e.call(this, i);
        }
        elementFromNode(t) {
          if (t.nodeType == Node.ELEMENT_NODE) return t;
        }
        elementIsActive(t) {
          return t.isConnected == this.element.isConnected && this.element.contains(t);
        }
        addElement(t) {
          this.elements.has(t) ||
            (this.elementIsActive(t) &&
              (this.elements.add(t), this.delegate.elementMatched && this.delegate.elementMatched(t)));
        }
        removeElement(t) {
          this.elements.has(t) &&
            (this.elements.delete(t), this.delegate.elementUnmatched && this.delegate.elementUnmatched(t));
        }
      }
      class g {
        constructor(t, e, i) {
          (this.attributeName = e), (this.delegate = i), (this.elementObserver = new p(t, this));
        }
        get element() {
          return this.elementObserver.element;
        }
        get selector() {
          return `[${this.attributeName}]`;
        }
        start() {
          this.elementObserver.start();
        }
        pause(t) {
          this.elementObserver.pause(t);
        }
        stop() {
          this.elementObserver.stop();
        }
        refresh() {
          this.elementObserver.refresh();
        }
        get started() {
          return this.elementObserver.started;
        }
        matchElement(t) {
          return t.hasAttribute(this.attributeName);
        }
        matchElementsInTree(t) {
          const e = this.matchElement(t) ? [t] : [],
            i = Array.from(t.querySelectorAll(this.selector));
          return e.concat(i);
        }
        elementMatched(t) {
          this.delegate.elementMatchedAttribute && this.delegate.elementMatchedAttribute(t, this.attributeName);
        }
        elementUnmatched(t) {
          this.delegate.elementUnmatchedAttribute && this.delegate.elementUnmatchedAttribute(t, this.attributeName);
        }
        elementAttributeChanged(t, e) {
          this.delegate.elementAttributeValueChanged &&
            this.attributeName == e &&
            this.delegate.elementAttributeValueChanged(t, e);
        }
      }
      class f {
        constructor(t, e) {
          (this.element = t),
            (this.delegate = e),
            (this.started = !1),
            (this.stringMap = new Map()),
            (this.mutationObserver = new MutationObserver((t) => this.processMutations(t)));
        }
        start() {
          this.started ||
            ((this.started = !0),
            this.mutationObserver.observe(this.element, { attributes: !0, attributeOldValue: !0 }),
            this.refresh());
        }
        stop() {
          this.started &&
            (this.mutationObserver.takeRecords(), this.mutationObserver.disconnect(), (this.started = !1));
        }
        refresh() {
          if (this.started) for (const t of this.knownAttributeNames) this.refreshAttribute(t, null);
        }
        processMutations(t) {
          if (this.started) for (const e of t) this.processMutation(e);
        }
        processMutation(t) {
          const e = t.attributeName;
          e && this.refreshAttribute(e, t.oldValue);
        }
        refreshAttribute(t, e) {
          const i = this.delegate.getStringMapKeyForAttribute(t);
          if (null != i) {
            this.stringMap.has(t) || this.stringMapKeyAdded(i, t);
            const s = this.element.getAttribute(t);
            if ((this.stringMap.get(t) != s && this.stringMapValueChanged(s, i, e), null == s)) {
              const e = this.stringMap.get(t);
              this.stringMap.delete(t), e && this.stringMapKeyRemoved(i, t, e);
            } else this.stringMap.set(t, s);
          }
        }
        stringMapKeyAdded(t, e) {
          this.delegate.stringMapKeyAdded && this.delegate.stringMapKeyAdded(t, e);
        }
        stringMapValueChanged(t, e, i) {
          this.delegate.stringMapValueChanged && this.delegate.stringMapValueChanged(t, e, i);
        }
        stringMapKeyRemoved(t, e, i) {
          this.delegate.stringMapKeyRemoved && this.delegate.stringMapKeyRemoved(t, e, i);
        }
        get knownAttributeNames() {
          return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
        }
        get currentAttributeNames() {
          return Array.from(this.element.attributes).map((t) => t.name);
        }
        get recordedAttributeNames() {
          return Array.from(this.stringMap.keys());
        }
      }
      function m(t, e) {
        let i = t.get(e);
        return i || ((i = new Set()), t.set(e, i)), i;
      }
      class v {
        constructor() {
          this.valuesByKey = new Map();
        }
        get keys() {
          return Array.from(this.valuesByKey.keys());
        }
        get values() {
          return Array.from(this.valuesByKey.values()).reduce((t, e) => t.concat(Array.from(e)), []);
        }
        get size() {
          return Array.from(this.valuesByKey.values()).reduce((t, e) => t + e.size, 0);
        }
        add(t, e) {
          !(function (t, e, i) {
            m(t, e).add(i);
          })(this.valuesByKey, t, e);
        }
        delete(t, e) {
          !(function (t, e, i) {
            m(t, e).delete(i),
              (function (t, e) {
                const i = t.get(e);
                null != i && 0 == i.size && t.delete(e);
              })(t, e);
          })(this.valuesByKey, t, e);
        }
        has(t, e) {
          const i = this.valuesByKey.get(t);
          return null != i && i.has(e);
        }
        hasKey(t) {
          return this.valuesByKey.has(t);
        }
        hasValue(t) {
          return Array.from(this.valuesByKey.values()).some((e) => e.has(t));
        }
        getValuesForKey(t) {
          const e = this.valuesByKey.get(t);
          return e ? Array.from(e) : [];
        }
        getKeysForValue(t) {
          return Array.from(this.valuesByKey)
            .filter(([e, i]) => i.has(t))
            .map(([t, e]) => t);
        }
      }
      class x {
        constructor(t, e, i) {
          (this.attributeObserver = new g(t, e, this)), (this.delegate = i), (this.tokensByElement = new v());
        }
        get started() {
          return this.attributeObserver.started;
        }
        start() {
          this.attributeObserver.start();
        }
        pause(t) {
          this.attributeObserver.pause(t);
        }
        stop() {
          this.attributeObserver.stop();
        }
        refresh() {
          this.attributeObserver.refresh();
        }
        get element() {
          return this.attributeObserver.element;
        }
        get attributeName() {
          return this.attributeObserver.attributeName;
        }
        elementMatchedAttribute(t) {
          this.tokensMatched(this.readTokensForElement(t));
        }
        elementAttributeValueChanged(t) {
          const [e, i] = this.refreshTokensForElement(t);
          this.tokensUnmatched(e), this.tokensMatched(i);
        }
        elementUnmatchedAttribute(t) {
          this.tokensUnmatched(this.tokensByElement.getValuesForKey(t));
        }
        tokensMatched(t) {
          t.forEach((t) => this.tokenMatched(t));
        }
        tokensUnmatched(t) {
          t.forEach((t) => this.tokenUnmatched(t));
        }
        tokenMatched(t) {
          this.delegate.tokenMatched(t), this.tokensByElement.add(t.element, t);
        }
        tokenUnmatched(t) {
          this.delegate.tokenUnmatched(t), this.tokensByElement.delete(t.element, t);
        }
        refreshTokensForElement(t) {
          const e = this.tokensByElement.getValuesForKey(t),
            i = this.readTokensForElement(t),
            s = (function (t, e) {
              const i = Math.max(t.length, e.length);
              return Array.from({ length: i }, (i, s) => [t[s], e[s]]);
            })(e, i).findIndex(([t, e]) => {
              return (s = e), !((i = t) && s && i.index == s.index && i.content == s.content);
              var i, s;
            });
          return -1 == s ? [[], []] : [e.slice(s), i.slice(s)];
        }
        readTokensForElement(t) {
          const e = this.attributeName;
          return (function (t, e, i) {
            return t
              .trim()
              .split(/\s+/)
              .filter((t) => t.length)
              .map((t, s) => ({ element: e, attributeName: i, content: t, index: s }));
          })(t.getAttribute(e) || "", t, e);
        }
      }
      class b {
        constructor(t, e, i) {
          (this.tokenListObserver = new x(t, e, this)),
            (this.delegate = i),
            (this.parseResultsByToken = new WeakMap()),
            (this.valuesByTokenByElement = new WeakMap());
        }
        get started() {
          return this.tokenListObserver.started;
        }
        start() {
          this.tokenListObserver.start();
        }
        stop() {
          this.tokenListObserver.stop();
        }
        refresh() {
          this.tokenListObserver.refresh();
        }
        get element() {
          return this.tokenListObserver.element;
        }
        get attributeName() {
          return this.tokenListObserver.attributeName;
        }
        tokenMatched(t) {
          const { element: e } = t,
            { value: i } = this.fetchParseResultForToken(t);
          i && (this.fetchValuesByTokenForElement(e).set(t, i), this.delegate.elementMatchedValue(e, i));
        }
        tokenUnmatched(t) {
          const { element: e } = t,
            { value: i } = this.fetchParseResultForToken(t);
          i && (this.fetchValuesByTokenForElement(e).delete(t), this.delegate.elementUnmatchedValue(e, i));
        }
        fetchParseResultForToken(t) {
          let e = this.parseResultsByToken.get(t);
          return e || ((e = this.parseToken(t)), this.parseResultsByToken.set(t, e)), e;
        }
        fetchValuesByTokenForElement(t) {
          let e = this.valuesByTokenByElement.get(t);
          return e || ((e = new Map()), this.valuesByTokenByElement.set(t, e)), e;
        }
        parseToken(t) {
          try {
            return { value: this.delegate.parseValueForToken(t) };
          } catch (t) {
            return { error: t };
          }
        }
      }
      class y {
        constructor(t, e) {
          (this.context = t), (this.delegate = e), (this.bindingsByAction = new Map());
        }
        start() {
          this.valueListObserver ||
            ((this.valueListObserver = new b(this.element, this.actionAttribute, this)),
            this.valueListObserver.start());
        }
        stop() {
          this.valueListObserver &&
            (this.valueListObserver.stop(), delete this.valueListObserver, this.disconnectAllActions());
        }
        get element() {
          return this.context.element;
        }
        get identifier() {
          return this.context.identifier;
        }
        get actionAttribute() {
          return this.schema.actionAttribute;
        }
        get schema() {
          return this.context.schema;
        }
        get bindings() {
          return Array.from(this.bindingsByAction.values());
        }
        connectAction(t) {
          const e = new u(this.context, t);
          this.bindingsByAction.set(t, e), this.delegate.bindingConnected(e);
        }
        disconnectAction(t) {
          const e = this.bindingsByAction.get(t);
          e && (this.bindingsByAction.delete(t), this.delegate.bindingDisconnected(e));
        }
        disconnectAllActions() {
          this.bindings.forEach((t) => this.delegate.bindingDisconnected(t)), this.bindingsByAction.clear();
        }
        parseValueForToken(t) {
          const e = class {
            constructor(t, e, i) {
              (this.element = t),
                (this.index = e),
                (this.eventTarget = i.eventTarget || t),
                (this.eventName =
                  i.eventName ||
                  (function (t) {
                    const e = t.tagName.toLowerCase();
                    if (e in c) return c[e](t);
                  })(t) ||
                  h("missing event name")),
                (this.eventOptions = i.eventOptions || {}),
                (this.identifier = i.identifier || h("missing identifier")),
                (this.methodName = i.methodName || h("missing method name"));
            }
            static forToken(t) {
              return new this(
                t.element,
                t.index,
                (function (t) {
                  const e = t.trim().match(n) || [];
                  return {
                    eventTarget: ((i = e[4]), "window" == i ? window : "document" == i ? document : void 0),
                    eventName: e[2],
                    eventOptions: e[9]
                      ? ((s = e[9]),
                        s.split(":").reduce((t, e) => Object.assign(t, { [e.replace(/^!/, "")]: !/^!/.test(e) }), {}))
                      : {},
                    identifier: e[5],
                    methodName: e[7],
                  };
                  var i, s;
                })(t.content)
              );
            }
            toString() {
              const t = this.eventTargetName ? `@${this.eventTargetName}` : "";
              return `${this.eventName}${t}->${this.identifier}#${this.methodName}`;
            }
            get params() {
              return this.eventTarget instanceof Element
                ? this.getParamsFromEventTargetAttributes(this.eventTarget)
                : {};
            }
            getParamsFromEventTargetAttributes(t) {
              const e = {},
                i = new RegExp(`^data-${this.identifier}-(.+)-param$`);
              return (
                Array.from(t.attributes).forEach(({ name: t, value: s }) => {
                  const a = t.match(i),
                    n = a && a[1];
                  n && Object.assign(e, { [r(n)]: d(s) });
                }),
                e
              );
            }
            get eventTargetName() {
              return (t = this.eventTarget) == window ? "window" : t == document ? "document" : void 0;
              var t;
            }
          }.forToken(t);
          if (e.identifier == this.identifier) return e;
        }
        elementMatchedValue(t, e) {
          this.connectAction(e);
        }
        elementUnmatchedValue(t, e) {
          this.disconnectAction(e);
        }
      }
      class w {
        constructor(t, e) {
          (this.context = t),
            (this.receiver = e),
            (this.stringMapObserver = new f(this.element, this)),
            (this.valueDescriptorMap = this.controller.valueDescriptorMap),
            this.invokeChangedCallbacksForDefaultValues();
        }
        start() {
          this.stringMapObserver.start();
        }
        stop() {
          this.stringMapObserver.stop();
        }
        get element() {
          return this.context.element;
        }
        get controller() {
          return this.context.controller;
        }
        getStringMapKeyForAttribute(t) {
          if (t in this.valueDescriptorMap) return this.valueDescriptorMap[t].name;
        }
        stringMapKeyAdded(t, e) {
          const i = this.valueDescriptorMap[e];
          this.hasValue(t) || this.invokeChangedCallback(t, i.writer(this.receiver[t]), i.writer(i.defaultValue));
        }
        stringMapValueChanged(t, e, i) {
          const s = this.valueDescriptorNameMap[e];
          null !== t && (null === i && (i = s.writer(s.defaultValue)), this.invokeChangedCallback(e, t, i));
        }
        stringMapKeyRemoved(t, e, i) {
          const s = this.valueDescriptorNameMap[t];
          this.hasValue(t)
            ? this.invokeChangedCallback(t, s.writer(this.receiver[t]), i)
            : this.invokeChangedCallback(t, s.writer(s.defaultValue), i);
        }
        invokeChangedCallbacksForDefaultValues() {
          for (const { key: t, name: e, defaultValue: i, writer: s } of this.valueDescriptors)
            null == i || this.controller.data.has(t) || this.invokeChangedCallback(e, s(i), void 0);
        }
        invokeChangedCallback(t, e, i) {
          const s = `${t}Changed`,
            a = this.receiver[s];
          if ("function" == typeof a) {
            const s = this.valueDescriptorNameMap[t],
              n = s.reader(e);
            let r = i;
            i && (r = s.reader(i)), a.call(this.receiver, n, r);
          }
        }
        get valueDescriptors() {
          const { valueDescriptorMap: t } = this;
          return Object.keys(t).map((e) => t[e]);
        }
        get valueDescriptorNameMap() {
          const t = {};
          return (
            Object.keys(this.valueDescriptorMap).forEach((e) => {
              const i = this.valueDescriptorMap[e];
              t[i.name] = i;
            }),
            t
          );
        }
        hasValue(t) {
          const e = `has${o(this.valueDescriptorNameMap[t].name)}`;
          return this.receiver[e];
        }
      }
      class k {
        constructor(t, e) {
          (this.context = t), (this.delegate = e), (this.targetsByName = new v());
        }
        start() {
          this.tokenListObserver ||
            ((this.tokenListObserver = new x(this.element, this.attributeName, this)), this.tokenListObserver.start());
        }
        stop() {
          this.tokenListObserver &&
            (this.disconnectAllTargets(), this.tokenListObserver.stop(), delete this.tokenListObserver);
        }
        tokenMatched({ element: t, content: e }) {
          this.scope.containsElement(t) && this.connectTarget(t, e);
        }
        tokenUnmatched({ element: t, content: e }) {
          this.disconnectTarget(t, e);
        }
        connectTarget(t, e) {
          var i;
          this.targetsByName.has(e, t) ||
            (this.targetsByName.add(e, t),
            null === (i = this.tokenListObserver) ||
              void 0 === i ||
              i.pause(() => this.delegate.targetConnected(t, e)));
        }
        disconnectTarget(t, e) {
          var i;
          this.targetsByName.has(e, t) &&
            (this.targetsByName.delete(e, t),
            null === (i = this.tokenListObserver) ||
              void 0 === i ||
              i.pause(() => this.delegate.targetDisconnected(t, e)));
        }
        disconnectAllTargets() {
          for (const t of this.targetsByName.keys)
            for (const e of this.targetsByName.getValuesForKey(t)) this.disconnectTarget(e, t);
        }
        get attributeName() {
          return `data-${this.context.identifier}-target`;
        }
        get element() {
          return this.context.element;
        }
        get scope() {
          return this.context.scope;
        }
      }
      class S {
        constructor(t, e) {
          (this.logDebugActivity = (t, e = {}) => {
            const { identifier: i, controller: s, element: a } = this;
            (e = Object.assign({ identifier: i, controller: s, element: a }, e)),
              this.application.logDebugActivity(this.identifier, t, e);
          }),
            (this.module = t),
            (this.scope = e),
            (this.controller = new t.controllerConstructor(this)),
            (this.bindingObserver = new y(this, this.dispatcher)),
            (this.valueObserver = new w(this, this.controller)),
            (this.targetObserver = new k(this, this));
          try {
            this.controller.initialize(), this.logDebugActivity("initialize");
          } catch (t) {
            this.handleError(t, "initializing controller");
          }
        }
        connect() {
          this.bindingObserver.start(), this.valueObserver.start(), this.targetObserver.start();
          try {
            this.controller.connect(), this.logDebugActivity("connect");
          } catch (t) {
            this.handleError(t, "connecting controller");
          }
        }
        disconnect() {
          try {
            this.controller.disconnect(), this.logDebugActivity("disconnect");
          } catch (t) {
            this.handleError(t, "disconnecting controller");
          }
          this.targetObserver.stop(), this.valueObserver.stop(), this.bindingObserver.stop();
        }
        get application() {
          return this.module.application;
        }
        get identifier() {
          return this.module.identifier;
        }
        get schema() {
          return this.application.schema;
        }
        get dispatcher() {
          return this.application.dispatcher;
        }
        get element() {
          return this.scope.element;
        }
        get parentElement() {
          return this.element.parentElement;
        }
        handleError(t, e, i = {}) {
          const { identifier: s, controller: a, element: n } = this;
          (i = Object.assign({ identifier: s, controller: a, element: n }, i)),
            this.application.handleError(t, `Error ${e}`, i);
        }
        targetConnected(t, e) {
          this.invokeControllerMethod(`${e}TargetConnected`, t);
        }
        targetDisconnected(t, e) {
          this.invokeControllerMethod(`${e}TargetDisconnected`, t);
        }
        invokeControllerMethod(t, ...e) {
          const i = this.controller;
          "function" == typeof i[t] && i[t](...e);
        }
      }
      function C(t, e) {
        const i = A(t);
        return Array.from(
          i.reduce(
            (t, i) => (
              (function (t, e) {
                const i = t[e];
                return Array.isArray(i) ? i : [];
              })(i, e).forEach((e) => t.add(e)),
              t
            ),
            new Set()
          )
        );
      }
      function A(t) {
        const e = [];
        for (; t; ) e.push(t), (t = Object.getPrototypeOf(t));
        return e.reverse();
      }
      const E =
          "function" == typeof Object.getOwnPropertySymbols
            ? (t) => [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)]
            : Object.getOwnPropertyNames,
        T = (() => {
          function t(t) {
            function e() {
              return Reflect.construct(t, arguments, new.target);
            }
            return (
              (e.prototype = Object.create(t.prototype, { constructor: { value: e } })), Reflect.setPrototypeOf(e, t), e
            );
          }
          try {
            return (
              (function () {
                const e = t(function () {
                  this.a.call(this);
                });
                (e.prototype.a = function () {}), new e();
              })(),
              t
            );
          } catch (t) {
            return (t) => class extends t {};
          }
        })();
      class L {
        constructor(t, e) {
          (this.application = t),
            (this.definition = (function (t) {
              return {
                identifier: t.identifier,
                controllerConstructor:
                  ((e = t.controllerConstructor),
                  (function (t, e) {
                    const i = T(t),
                      s = (function (t, e) {
                        return E(e).reduce((i, s) => {
                          const a = (function (t, e, i) {
                            const s = Object.getOwnPropertyDescriptor(t, i);
                            if (!s || !("value" in s)) {
                              const t = Object.getOwnPropertyDescriptor(e, i).value;
                              return s && ((t.get = s.get || t.get), (t.set = s.set || t.set)), t;
                            }
                          })(t, e, s);
                          return a && Object.assign(i, { [s]: a }), i;
                        }, {});
                      })(t.prototype, e);
                    return Object.defineProperties(i.prototype, s), i;
                  })(
                    e,
                    (function (t) {
                      return C(t, "blessings").reduce((e, i) => {
                        const s = i(t);
                        for (const t in s) {
                          const i = e[t] || {};
                          e[t] = Object.assign(i, s[t]);
                        }
                        return e;
                      }, {});
                    })(e)
                  )),
              };
              var e;
            })(e)),
            (this.contextsByScope = new WeakMap()),
            (this.connectedContexts = new Set());
        }
        get identifier() {
          return this.definition.identifier;
        }
        get controllerConstructor() {
          return this.definition.controllerConstructor;
        }
        get contexts() {
          return Array.from(this.connectedContexts);
        }
        connectContextForScope(t) {
          const e = this.fetchContextForScope(t);
          this.connectedContexts.add(e), e.connect();
        }
        disconnectContextForScope(t) {
          const e = this.contextsByScope.get(t);
          e && (this.connectedContexts.delete(e), e.disconnect());
        }
        fetchContextForScope(t) {
          let e = this.contextsByScope.get(t);
          return e || ((e = new S(this, t)), this.contextsByScope.set(t, e)), e;
        }
      }
      class P {
        constructor(t) {
          this.scope = t;
        }
        has(t) {
          return this.data.has(this.getDataKey(t));
        }
        get(t) {
          return this.getAll(t)[0];
        }
        getAll(t) {
          return (this.data.get(this.getDataKey(t)) || "").match(/[^\s]+/g) || [];
        }
        getAttributeName(t) {
          return this.data.getAttributeNameForKey(this.getDataKey(t));
        }
        getDataKey(t) {
          return `${t}-class`;
        }
        get data() {
          return this.scope.data;
        }
      }
      class M {
        constructor(t) {
          this.scope = t;
        }
        get element() {
          return this.scope.element;
        }
        get identifier() {
          return this.scope.identifier;
        }
        get(t) {
          const e = this.getAttributeNameForKey(t);
          return this.element.getAttribute(e);
        }
        set(t, e) {
          const i = this.getAttributeNameForKey(t);
          return this.element.setAttribute(i, e), this.get(t);
        }
        has(t) {
          const e = this.getAttributeNameForKey(t);
          return this.element.hasAttribute(e);
        }
        delete(t) {
          if (this.has(t)) {
            const e = this.getAttributeNameForKey(t);
            return this.element.removeAttribute(e), !0;
          }
          return !1;
        }
        getAttributeNameForKey(t) {
          return `data-${this.identifier}-${l(t)}`;
        }
      }
      class O {
        constructor(t) {
          (this.warnedKeysByObject = new WeakMap()), (this.logger = t);
        }
        warn(t, e, i) {
          let s = this.warnedKeysByObject.get(t);
          s || ((s = new Set()), this.warnedKeysByObject.set(t, s)), s.has(e) || (s.add(e), this.logger.warn(i, t));
        }
      }
      function I(t, e) {
        return `[${t}~="${e}"]`;
      }
      class F {
        constructor(t) {
          this.scope = t;
        }
        get element() {
          return this.scope.element;
        }
        get identifier() {
          return this.scope.identifier;
        }
        get schema() {
          return this.scope.schema;
        }
        has(t) {
          return null != this.find(t);
        }
        find(...t) {
          return t.reduce((t, e) => t || this.findTarget(e) || this.findLegacyTarget(e), void 0);
        }
        findAll(...t) {
          return t.reduce((t, e) => [...t, ...this.findAllTargets(e), ...this.findAllLegacyTargets(e)], []);
        }
        findTarget(t) {
          const e = this.getSelectorForTargetName(t);
          return this.scope.findElement(e);
        }
        findAllTargets(t) {
          const e = this.getSelectorForTargetName(t);
          return this.scope.findAllElements(e);
        }
        getSelectorForTargetName(t) {
          return I(this.schema.targetAttributeForScope(this.identifier), t);
        }
        findLegacyTarget(t) {
          const e = this.getLegacySelectorForTargetName(t);
          return this.deprecate(this.scope.findElement(e), t);
        }
        findAllLegacyTargets(t) {
          const e = this.getLegacySelectorForTargetName(t);
          return this.scope.findAllElements(e).map((e) => this.deprecate(e, t));
        }
        getLegacySelectorForTargetName(t) {
          const e = `${this.identifier}.${t}`;
          return I(this.schema.targetAttribute, e);
        }
        deprecate(t, e) {
          if (t) {
            const { identifier: i } = this,
              s = this.schema.targetAttribute,
              a = this.schema.targetAttributeForScope(i);
            this.guide.warn(
              t,
              `target:${e}`,
              `Please replace ${s}="${i}.${e}" with ${a}="${e}". The ${s} attribute is deprecated and will be removed in a future version of Stimulus.`
            );
          }
          return t;
        }
        get guide() {
          return this.scope.guide;
        }
      }
      class D {
        constructor(t, e, i, s) {
          (this.targets = new F(this)),
            (this.classes = new P(this)),
            (this.data = new M(this)),
            (this.containsElement = (t) => t.closest(this.controllerSelector) === this.element),
            (this.schema = t),
            (this.element = e),
            (this.identifier = i),
            (this.guide = new O(s));
        }
        findElement(t) {
          return this.element.matches(t) ? this.element : this.queryElements(t).find(this.containsElement);
        }
        findAllElements(t) {
          return [
            ...(this.element.matches(t) ? [this.element] : []),
            ...this.queryElements(t).filter(this.containsElement),
          ];
        }
        queryElements(t) {
          return Array.from(this.element.querySelectorAll(t));
        }
        get controllerSelector() {
          return I(this.schema.controllerAttribute, this.identifier);
        }
      }
      class z {
        constructor(t, e, i) {
          (this.element = t),
            (this.schema = e),
            (this.delegate = i),
            (this.valueListObserver = new b(this.element, this.controllerAttribute, this)),
            (this.scopesByIdentifierByElement = new WeakMap()),
            (this.scopeReferenceCounts = new WeakMap());
        }
        start() {
          this.valueListObserver.start();
        }
        stop() {
          this.valueListObserver.stop();
        }
        get controllerAttribute() {
          return this.schema.controllerAttribute;
        }
        parseValueForToken(t) {
          const { element: e, content: i } = t,
            s = this.fetchScopesByIdentifierForElement(e);
          let a = s.get(i);
          return a || ((a = this.delegate.createScopeForElementAndIdentifier(e, i)), s.set(i, a)), a;
        }
        elementMatchedValue(t, e) {
          const i = (this.scopeReferenceCounts.get(e) || 0) + 1;
          this.scopeReferenceCounts.set(e, i), 1 == i && this.delegate.scopeConnected(e);
        }
        elementUnmatchedValue(t, e) {
          const i = this.scopeReferenceCounts.get(e);
          i && (this.scopeReferenceCounts.set(e, i - 1), 1 == i && this.delegate.scopeDisconnected(e));
        }
        fetchScopesByIdentifierForElement(t) {
          let e = this.scopesByIdentifierByElement.get(t);
          return e || ((e = new Map()), this.scopesByIdentifierByElement.set(t, e)), e;
        }
      }
      class N {
        constructor(t) {
          (this.application = t),
            (this.scopeObserver = new z(this.element, this.schema, this)),
            (this.scopesByIdentifier = new v()),
            (this.modulesByIdentifier = new Map());
        }
        get element() {
          return this.application.element;
        }
        get schema() {
          return this.application.schema;
        }
        get logger() {
          return this.application.logger;
        }
        get controllerAttribute() {
          return this.schema.controllerAttribute;
        }
        get modules() {
          return Array.from(this.modulesByIdentifier.values());
        }
        get contexts() {
          return this.modules.reduce((t, e) => t.concat(e.contexts), []);
        }
        start() {
          this.scopeObserver.start();
        }
        stop() {
          this.scopeObserver.stop();
        }
        loadDefinition(t) {
          this.unloadIdentifier(t.identifier);
          const e = new L(this.application, t);
          this.connectModule(e);
        }
        unloadIdentifier(t) {
          const e = this.modulesByIdentifier.get(t);
          e && this.disconnectModule(e);
        }
        getContextForElementAndIdentifier(t, e) {
          const i = this.modulesByIdentifier.get(e);
          if (i) return i.contexts.find((e) => e.element == t);
        }
        handleError(t, e, i) {
          this.application.handleError(t, e, i);
        }
        createScopeForElementAndIdentifier(t, e) {
          return new D(this.schema, t, e, this.logger);
        }
        scopeConnected(t) {
          this.scopesByIdentifier.add(t.identifier, t);
          const e = this.modulesByIdentifier.get(t.identifier);
          e && e.connectContextForScope(t);
        }
        scopeDisconnected(t) {
          this.scopesByIdentifier.delete(t.identifier, t);
          const e = this.modulesByIdentifier.get(t.identifier);
          e && e.disconnectContextForScope(t);
        }
        connectModule(t) {
          this.modulesByIdentifier.set(t.identifier, t),
            this.scopesByIdentifier.getValuesForKey(t.identifier).forEach((e) => t.connectContextForScope(e));
        }
        disconnectModule(t) {
          this.modulesByIdentifier.delete(t.identifier),
            this.scopesByIdentifier.getValuesForKey(t.identifier).forEach((e) => t.disconnectContextForScope(e));
        }
      }
      const R = {
        controllerAttribute: "data-controller",
        actionAttribute: "data-action",
        targetAttribute: "data-target",
        targetAttributeForScope: (t) => `data-${t}-target`,
      };
      class _ {
        constructor(t = document.documentElement, e = R) {
          (this.logger = console),
            (this.debug = !1),
            (this.logDebugActivity = (t, e, i = {}) => {
              this.debug && this.logFormattedMessage(t, e, i);
            }),
            (this.element = t),
            (this.schema = e),
            (this.dispatcher = new a(this)),
            (this.router = new N(this));
        }
        static start(t, e) {
          const i = new _(t, e);
          return i.start(), i;
        }
        async start() {
          await new Promise((t) => {
            "loading" == document.readyState ? document.addEventListener("DOMContentLoaded", () => t()) : t();
          }),
            this.logDebugActivity("application", "starting"),
            this.dispatcher.start(),
            this.router.start(),
            this.logDebugActivity("application", "start");
        }
        stop() {
          this.logDebugActivity("application", "stopping"),
            this.dispatcher.stop(),
            this.router.stop(),
            this.logDebugActivity("application", "stop");
        }
        register(t, e) {
          e.shouldLoad && this.load({ identifier: t, controllerConstructor: e });
        }
        load(t, ...e) {
          (Array.isArray(t) ? t : [t, ...e]).forEach((t) => this.router.loadDefinition(t));
        }
        unload(t, ...e) {
          (Array.isArray(t) ? t : [t, ...e]).forEach((t) => this.router.unloadIdentifier(t));
        }
        get controllers() {
          return this.router.contexts.map((t) => t.controller);
        }
        getControllerForElementAndIdentifier(t, e) {
          const i = this.router.getContextForElementAndIdentifier(t, e);
          return i ? i.controller : null;
        }
        handleError(t, e, i) {
          var s;
          this.logger.error("%s\n\n%o\n\n%o", e, t, i),
            null === (s = window.onerror) || void 0 === s || s.call(window, e, "", 0, 0, t);
        }
        logFormattedMessage(t, e, i = {}) {
          (i = Object.assign({ application: this }, i)),
            this.logger.groupCollapsed(`${t} #${e}`),
            this.logger.log("details:", Object.assign({}, i)),
            this.logger.groupEnd();
        }
      }
      function B([t, e]) {
        return (function (t, e) {
          const i = `${l(t)}-value`,
            s = (function (t) {
              const e = (function (t) {
                  const e = X(t.type);
                  if (e) {
                    const i = H(t.default);
                    if (e !== i)
                      throw new Error(
                        `Type "${e}" must match the type of the default value. Given default value: "${t.default}" as "${i}"`
                      );
                    return e;
                  }
                })(t),
                i = H(t),
                s = X(t),
                a = e || i || s;
              if (a) return a;
              throw new Error(`Unknown value type "${t}"`);
            })(e);
          return {
            type: s,
            key: i,
            name: r(i),
            get defaultValue() {
              return (function (t) {
                const e = X(t);
                if (e) return Y[e];
                const i = t.default;
                return void 0 !== i ? i : t;
              })(e);
            },
            get hasCustomDefaultValue() {
              return void 0 !== H(e);
            },
            reader: W[s],
            writer: $[s] || $.default,
          };
        })(t, e);
      }
      function X(t) {
        switch (t) {
          case Array:
            return "array";
          case Boolean:
            return "boolean";
          case Number:
            return "number";
          case Object:
            return "object";
          case String:
            return "string";
        }
      }
      function H(t) {
        switch (typeof t) {
          case "boolean":
            return "boolean";
          case "number":
            return "number";
          case "string":
            return "string";
        }
        return Array.isArray(t) ? "array" : "[object Object]" === Object.prototype.toString.call(t) ? "object" : void 0;
      }
      const Y = {
          get array() {
            return [];
          },
          boolean: !1,
          number: 0,
          get object() {
            return {};
          },
          string: "",
        },
        W = {
          array(t) {
            const e = JSON.parse(t);
            if (!Array.isArray(e)) throw new TypeError("Expected array");
            return e;
          },
          boolean: (t) => !("0" == t || "false" == t),
          number: (t) => Number(t),
          object(t) {
            const e = JSON.parse(t);
            if (null === e || "object" != typeof e || Array.isArray(e)) throw new TypeError("Expected object");
            return e;
          },
          string: (t) => t,
        },
        $ = {
          default: function (t) {
            return `${t}`;
          },
          array: V,
          object: V,
        };
      function V(t) {
        return JSON.stringify(t);
      }
      class j {
        constructor(t) {
          this.context = t;
        }
        static get shouldLoad() {
          return !0;
        }
        get application() {
          return this.context.application;
        }
        get scope() {
          return this.context.scope;
        }
        get element() {
          return this.scope.element;
        }
        get identifier() {
          return this.scope.identifier;
        }
        get targets() {
          return this.scope.targets;
        }
        get classes() {
          return this.scope.classes;
        }
        get data() {
          return this.scope.data;
        }
        initialize() {}
        connect() {}
        disconnect() {}
        dispatch(
          t,
          {
            target: e = this.element,
            detail: i = {},
            prefix: s = this.identifier,
            bubbles: a = !0,
            cancelable: n = !0,
          } = {}
        ) {
          const r = new CustomEvent(s ? `${s}:${t}` : t, { detail: i, bubbles: a, cancelable: n });
          return e.dispatchEvent(r), r;
        }
      }
      (j.blessings = [
        function (t) {
          return C(t, "classes").reduce((t, e) => {
            return Object.assign(t, {
              [`${(i = e)}Class`]: {
                get() {
                  const { classes: t } = this;
                  if (t.has(i)) return t.get(i);
                  {
                    const e = t.getAttributeName(i);
                    throw new Error(`Missing attribute "${e}"`);
                  }
                },
              },
              [`${i}Classes`]: {
                get() {
                  return this.classes.getAll(i);
                },
              },
              [`has${o(i)}Class`]: {
                get() {
                  return this.classes.has(i);
                },
              },
            });
            var i;
          }, {});
        },
        function (t) {
          return C(t, "targets").reduce((t, e) => {
            return Object.assign(t, {
              [`${(i = e)}Target`]: {
                get() {
                  const t = this.targets.find(i);
                  if (t) return t;
                  throw new Error(`Missing target element "${i}" for "${this.identifier}" controller`);
                },
              },
              [`${i}Targets`]: {
                get() {
                  return this.targets.findAll(i);
                },
              },
              [`has${o(i)}Target`]: {
                get() {
                  return this.targets.has(i);
                },
              },
            });
            var i;
          }, {});
        },
        function (t) {
          const e = (function (t, e) {
              return A(t).reduce(
                (t, i) => (
                  t.push(
                    ...(function (t, e) {
                      const i = t[e];
                      return i ? Object.keys(i).map((t) => [t, i[t]]) : [];
                    })(i, e)
                  ),
                  t
                ),
                []
              );
            })(t, "values"),
            i = {
              valueDescriptorMap: {
                get() {
                  return e.reduce((t, e) => {
                    const i = B(e),
                      s = this.data.getAttributeNameForKey(i.key);
                    return Object.assign(t, { [s]: i });
                  }, {});
                },
              },
            };
          return e.reduce(
            (t, e) =>
              Object.assign(
                t,
                (function (t) {
                  const e = B(t),
                    { key: i, name: s, reader: a, writer: n } = e;
                  return {
                    [s]: {
                      get() {
                        const t = this.data.get(i);
                        return null !== t ? a(t) : e.defaultValue;
                      },
                      set(t) {
                        void 0 === t ? this.data.delete(i) : this.data.set(i, n(t));
                      },
                    },
                    [`has${o(s)}`]: {
                      get() {
                        return this.data.has(i) || e.hasCustomDefaultValue;
                      },
                    },
                  };
                })(e)
              ),
            i
          );
        },
      ]),
        (j.targets = []),
        (j.values = {});
    },
    927: function (t, e, i) {
      "use strict";
      var s;
      function a(t, e) {
        var i = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var s = Object.getOwnPropertySymbols(t);
          e &&
            (s = s.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            i.push.apply(i, s);
        }
        return i;
      }
      function n(t) {
        for (var e = 1; e < arguments.length; e++) {
          var i = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? a(Object(i), !0).forEach(function (e) {
                h(t, e, i[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i))
            : a(Object(i)).forEach(function (e) {
                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));
              });
        }
        return t;
      }
      function r(t) {
        return (
          (r =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                }),
          r(t)
        );
      }
      function o(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
      }
      function l(t, e) {
        for (var i = 0; i < e.length; i++) {
          var s = e[i];
          (s.enumerable = s.enumerable || !1),
            (s.configurable = !0),
            "value" in s && (s.writable = !0),
            Object.defineProperty(t, s.key, s);
        }
      }
      function c(t, e, i) {
        return e && l(t.prototype, e), i && l(t, i), t;
      }
      function h(t, e, i) {
        return (
          e in t
            ? Object.defineProperty(t, e, { value: i, enumerable: !0, configurable: !0, writable: !0 })
            : (t[e] = i),
          t
        );
      }
      function d(t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError("Super expression must either be null or a function");
        (t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } })),
          e && p(t, e);
      }
      function u(t) {
        return (
          (u = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t);
              }),
          u(t)
        );
      }
      function p(t, e) {
        return (
          (p =
            Object.setPrototypeOf ||
            function (t, e) {
              return (t.__proto__ = e), t;
            }),
          p(t, e)
        );
      }
      function g(t, e) {
        if (e && ("object" == typeof e || "function" == typeof e)) return e;
        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
        return (function (t) {
          if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t;
        })(t);
      }
      function f(t) {
        var e = (function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        })();
        return function () {
          var i,
            s = u(t);
          if (e) {
            var a = u(this).constructor;
            i = Reflect.construct(s, arguments, a);
          } else i = s.apply(this, arguments);
          return g(this, i);
        };
      }
      function m(t) {
        return (
          (function (t) {
            if (Array.isArray(t)) return x(t);
          })(t) ||
          (function (t) {
            if (("undefined" != typeof Symbol && null != t[Symbol.iterator]) || null != t["@@iterator"])
              return Array.from(t);
          })(t) ||
          v(t) ||
          (function () {
            throw new TypeError(
              "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          })()
        );
      }
      function v(t, e) {
        if (t) {
          if ("string" == typeof t) return x(t, e);
          var i = Object.prototype.toString.call(t).slice(8, -1);
          return (
            "Object" === i && t.constructor && (i = t.constructor.name),
            "Map" === i || "Set" === i
              ? Array.from(t)
              : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)
              ? x(t, e)
              : void 0
          );
        }
      }
      function x(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var i = 0, s = new Array(e); i < e; i++) s[i] = t[i];
        return s;
      }
      var b = (function () {
          function t() {
            o(this, t);
          }
          return (
            c(
              t,
              [
                {
                  key: "shadeRGBColor",
                  value: function (t, e) {
                    var i = e.split(","),
                      s = t < 0 ? 0 : 255,
                      a = t < 0 ? -1 * t : t,
                      n = parseInt(i[0].slice(4), 10),
                      r = parseInt(i[1], 10),
                      o = parseInt(i[2], 10);
                    return (
                      "rgb(" +
                      (Math.round((s - n) * a) + n) +
                      "," +
                      (Math.round((s - r) * a) + r) +
                      "," +
                      (Math.round((s - o) * a) + o) +
                      ")"
                    );
                  },
                },
                {
                  key: "shadeHexColor",
                  value: function (t, e) {
                    var i = parseInt(e.slice(1), 16),
                      s = t < 0 ? 0 : 255,
                      a = t < 0 ? -1 * t : t,
                      n = i >> 16,
                      r = (i >> 8) & 255,
                      o = 255 & i;
                    return (
                      "#" +
                      (
                        16777216 +
                        65536 * (Math.round((s - n) * a) + n) +
                        256 * (Math.round((s - r) * a) + r) +
                        (Math.round((s - o) * a) + o)
                      )
                        .toString(16)
                        .slice(1)
                    );
                  },
                },
                {
                  key: "shadeColor",
                  value: function (e, i) {
                    return t.isColorHex(i) ? this.shadeHexColor(e, i) : this.shadeRGBColor(e, i);
                  },
                },
              ],
              [
                {
                  key: "bind",
                  value: function (t, e) {
                    return function () {
                      return t.apply(e, arguments);
                    };
                  },
                },
                {
                  key: "isObject",
                  value: function (t) {
                    return t && "object" === r(t) && !Array.isArray(t) && null != t;
                  },
                },
                {
                  key: "is",
                  value: function (t, e) {
                    return Object.prototype.toString.call(e) === "[object " + t + "]";
                  },
                },
                {
                  key: "listToArray",
                  value: function (t) {
                    var e,
                      i = [];
                    for (e = 0; e < t.length; e++) i[e] = t[e];
                    return i;
                  },
                },
                {
                  key: "extend",
                  value: function (t, e) {
                    var i = this;
                    "function" != typeof Object.assign &&
                      (Object.assign = function (t) {
                        if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                        for (var e = Object(t), i = 1; i < arguments.length; i++) {
                          var s = arguments[i];
                          if (null != s) for (var a in s) s.hasOwnProperty(a) && (e[a] = s[a]);
                        }
                        return e;
                      });
                    var s = Object.assign({}, t);
                    return (
                      this.isObject(t) &&
                        this.isObject(e) &&
                        Object.keys(e).forEach(function (a) {
                          i.isObject(e[a]) && a in t ? (s[a] = i.extend(t[a], e[a])) : Object.assign(s, h({}, a, e[a]));
                        }),
                      s
                    );
                  },
                },
                {
                  key: "extendArray",
                  value: function (e, i) {
                    var s = [];
                    return (
                      e.map(function (e) {
                        s.push(t.extend(i, e));
                      }),
                      s
                    );
                  },
                },
                {
                  key: "monthMod",
                  value: function (t) {
                    return t % 12;
                  },
                },
                {
                  key: "clone",
                  value: function (e) {
                    if (t.is("Array", e)) {
                      for (var i = [], s = 0; s < e.length; s++) i[s] = this.clone(e[s]);
                      return i;
                    }
                    if (t.is("Null", e)) return null;
                    if (t.is("Date", e)) return e;
                    if ("object" === r(e)) {
                      var a = {};
                      for (var n in e) e.hasOwnProperty(n) && (a[n] = this.clone(e[n]));
                      return a;
                    }
                    return e;
                  },
                },
                {
                  key: "log10",
                  value: function (t) {
                    return Math.log(t) / Math.LN10;
                  },
                },
                {
                  key: "roundToBase10",
                  value: function (t) {
                    return Math.pow(10, Math.floor(Math.log10(t)));
                  },
                },
                {
                  key: "roundToBase",
                  value: function (t, e) {
                    return Math.pow(e, Math.floor(Math.log(t) / Math.log(e)));
                  },
                },
                {
                  key: "parseNumber",
                  value: function (t) {
                    return null === t ? t : parseFloat(t);
                  },
                },
                {
                  key: "randomId",
                  value: function () {
                    return (Math.random() + 1).toString(36).substring(4);
                  },
                },
                {
                  key: "noExponents",
                  value: function (t) {
                    var e = String(t).split(/[eE]/);
                    if (1 === e.length) return e[0];
                    var i = "",
                      s = t < 0 ? "-" : "",
                      a = e[0].replace(".", ""),
                      n = Number(e[1]) + 1;
                    if (n < 0) {
                      for (i = s + "0."; n++; ) i += "0";
                      return i + a.replace(/^-/, "");
                    }
                    for (n -= a.length; n--; ) i += "0";
                    return a + i;
                  },
                },
                {
                  key: "getDimensions",
                  value: function (t) {
                    var e = getComputedStyle(t, null),
                      i = t.clientHeight,
                      s = t.clientWidth;
                    return (
                      (i -= parseFloat(e.paddingTop) + parseFloat(e.paddingBottom)),
                      [(s -= parseFloat(e.paddingLeft) + parseFloat(e.paddingRight)), i]
                    );
                  },
                },
                {
                  key: "getBoundingClientRect",
                  value: function (t) {
                    var e = t.getBoundingClientRect();
                    return {
                      top: e.top,
                      right: e.right,
                      bottom: e.bottom,
                      left: e.left,
                      width: t.clientWidth,
                      height: t.clientHeight,
                      x: e.left,
                      y: e.top,
                    };
                  },
                },
                {
                  key: "getLargestStringFromArr",
                  value: function (t) {
                    return t.reduce(function (t, e) {
                      return (
                        Array.isArray(e) &&
                          (e = e.reduce(function (t, e) {
                            return t.length > e.length ? t : e;
                          })),
                        t.length > e.length ? t : e
                      );
                    }, 0);
                  },
                },
                {
                  key: "hexToRgba",
                  value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999",
                      e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.6;
                    "#" !== t.substring(0, 1) && (t = "#999999");
                    var i = t.replace("#", "");
                    i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));
                    for (var s = 0; s < i.length; s++) i[s] = parseInt(1 === i[s].length ? i[s] + i[s] : i[s], 16);
                    return void 0 !== e && i.push(e), "rgba(" + i.join(",") + ")";
                  },
                },
                {
                  key: "getOpacityFromRGBA",
                  value: function (t) {
                    return parseFloat(t.replace(/^.*,(.+)\)/, "$1"));
                  },
                },
                {
                  key: "rgb2hex",
                  value: function (t) {
                    return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) &&
                      4 === t.length
                      ? "#" +
                          ("0" + parseInt(t[1], 10).toString(16)).slice(-2) +
                          ("0" + parseInt(t[2], 10).toString(16)).slice(-2) +
                          ("0" + parseInt(t[3], 10).toString(16)).slice(-2)
                      : "";
                  },
                },
                {
                  key: "isColorHex",
                  value: function (t) {
                    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t);
                  },
                },
                {
                  key: "getPolygonPos",
                  value: function (t, e) {
                    for (var i = [], s = (2 * Math.PI) / e, a = 0; a < e; a++) {
                      var n = {};
                      (n.x = t * Math.sin(a * s)), (n.y = -t * Math.cos(a * s)), i.push(n);
                    }
                    return i;
                  },
                },
                {
                  key: "polarToCartesian",
                  value: function (t, e, i, s) {
                    var a = ((s - 90) * Math.PI) / 180;
                    return { x: t + i * Math.cos(a), y: e + i * Math.sin(a) };
                  },
                },
                {
                  key: "escapeString",
                  value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x",
                      i = t.toString().slice();
                    return i.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, e);
                  },
                },
                {
                  key: "negToZero",
                  value: function (t) {
                    return t < 0 ? 0 : t;
                  },
                },
                {
                  key: "moveIndexInArray",
                  value: function (t, e, i) {
                    if (i >= t.length) for (var s = i - t.length + 1; s--; ) t.push(void 0);
                    return t.splice(i, 0, t.splice(e, 1)[0]), t;
                  },
                },
                {
                  key: "extractNumber",
                  value: function (t) {
                    return parseFloat(t.replace(/[^\d.]*/g, ""));
                  },
                },
                {
                  key: "findAncestor",
                  value: function (t, e) {
                    for (; (t = t.parentElement) && !t.classList.contains(e); );
                    return t;
                  },
                },
                {
                  key: "setELstyles",
                  value: function (t, e) {
                    for (var i in e) e.hasOwnProperty(i) && (t.style.key = e[i]);
                  },
                },
                {
                  key: "isNumber",
                  value: function (t) {
                    return !isNaN(t) && parseFloat(Number(t)) === t && !isNaN(parseInt(t, 10));
                  },
                },
                {
                  key: "isFloat",
                  value: function (t) {
                    return Number(t) === t && t % 1 != 0;
                  },
                },
                {
                  key: "isSafari",
                  value: function () {
                    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                  },
                },
                {
                  key: "isFirefox",
                  value: function () {
                    return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
                  },
                },
                {
                  key: "isIE11",
                  value: function () {
                    if (
                      -1 !== window.navigator.userAgent.indexOf("MSIE") ||
                      window.navigator.appVersion.indexOf("Trident/") > -1
                    )
                      return !0;
                  },
                },
                {
                  key: "isIE",
                  value: function () {
                    var t = window.navigator.userAgent,
                      e = t.indexOf("MSIE ");
                    if (e > 0) return parseInt(t.substring(e + 5, t.indexOf(".", e)), 10);
                    if (t.indexOf("Trident/") > 0) {
                      var i = t.indexOf("rv:");
                      return parseInt(t.substring(i + 3, t.indexOf(".", i)), 10);
                    }
                    var s = t.indexOf("Edge/");
                    return s > 0 && parseInt(t.substring(s + 5, t.indexOf(".", s)), 10);
                  },
                },
              ]
            ),
            t
          );
        })(),
        y = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w), this.setEasingFunctions();
          }
          return (
            c(t, [
              {
                key: "setEasingFunctions",
                value: function () {
                  var t;
                  if (!this.w.globals.easing) {
                    switch (this.w.config.chart.animations.easing) {
                      case "linear":
                        t = "-";
                        break;
                      case "easein":
                        t = "<";
                        break;
                      case "easeout":
                        t = ">";
                        break;
                      case "easeinout":
                      default:
                        t = "<>";
                        break;
                      case "swing":
                        t = function (t) {
                          var e = 1.70158;
                          return (t -= 1) * t * ((e + 1) * t + e) + 1;
                        };
                        break;
                      case "bounce":
                        t = function (t) {
                          return t < 1 / 2.75
                            ? 7.5625 * t * t
                            : t < 2 / 2.75
                            ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75
                            : t < 2.5 / 2.75
                            ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375
                            : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
                        };
                        break;
                      case "elastic":
                        t = function (t) {
                          return t === !!t
                            ? t
                            : Math.pow(2, -10 * t) * Math.sin(((t - 0.075) * (2 * Math.PI)) / 0.3) + 1;
                        };
                    }
                    this.w.globals.easing = t;
                  }
                },
              },
              {
                key: "animateLine",
                value: function (t, e, i, s) {
                  t.attr(e).animate(s).attr(i);
                },
              },
              {
                key: "animateMarker",
                value: function (t, e, i, s, a, n) {
                  e || (e = 0),
                    t
                      .attr({ r: e, width: e, height: e })
                      .animate(s, a)
                      .attr({ r: i, width: i.width, height: i.height })
                      .afterAll(function () {
                        n();
                      });
                },
              },
              {
                key: "animateCircle",
                value: function (t, e, i, s, a) {
                  t.attr({ r: e.r, cx: e.cx, cy: e.cy }).animate(s, a).attr({ r: i.r, cx: i.cx, cy: i.cy });
                },
              },
              {
                key: "animateRect",
                value: function (t, e, i, s, a) {
                  t.attr(e)
                    .animate(s)
                    .attr(i)
                    .afterAll(function () {
                      return a();
                    });
                },
              },
              {
                key: "animatePathsGradually",
                value: function (t) {
                  var e = t.el,
                    i = t.realIndex,
                    s = t.j,
                    a = t.fill,
                    n = t.pathFrom,
                    r = t.pathTo,
                    o = t.speed,
                    l = t.delay,
                    c = this.w,
                    h = 0;
                  c.config.chart.animations.animateGradually.enabled &&
                    (h = c.config.chart.animations.animateGradually.delay),
                    c.config.chart.animations.dynamicAnimation.enabled &&
                      c.globals.dataChanged &&
                      "bar" !== c.config.chart.type &&
                      (h = 0),
                    this.morphSVG(
                      e,
                      i,
                      s,
                      "line" !== c.config.chart.type || c.globals.comboCharts ? a : "stroke",
                      n,
                      r,
                      o,
                      l * h
                    );
                },
              },
              {
                key: "showDelayedElements",
                value: function () {
                  this.w.globals.delayedElements.forEach(function (t) {
                    t.el.classList.remove("apexcharts-element-hidden");
                  });
                },
              },
              {
                key: "animationCompleted",
                value: function (t) {
                  var e = this.w;
                  e.globals.animationEnded ||
                    ((e.globals.animationEnded = !0),
                    this.showDelayedElements(),
                    "function" == typeof e.config.chart.events.animationEnd &&
                      e.config.chart.events.animationEnd(this.ctx, { el: t, w: e }));
                },
              },
              {
                key: "morphSVG",
                value: function (t, e, i, s, a, n, r, o) {
                  var l = this,
                    c = this.w;
                  a || (a = t.attr("pathFrom")), n || (n = t.attr("pathTo"));
                  var h = function (t) {
                    return "radar" === c.config.chart.type && (r = 1), "M 0 ".concat(c.globals.gridHeight);
                  };
                  (!a || a.indexOf("undefined") > -1 || a.indexOf("NaN") > -1) && (a = h()),
                    (!n || n.indexOf("undefined") > -1 || n.indexOf("NaN") > -1) && (n = h()),
                    c.globals.shouldAnimate || (r = 1),
                    t
                      .plot(a)
                      .animate(1, c.globals.easing, o)
                      .plot(a)
                      .animate(r, c.globals.easing, o)
                      .plot(n)
                      .afterAll(function () {
                        b.isNumber(i)
                          ? i === c.globals.series[c.globals.maxValsInArrayIndex].length - 2 &&
                            c.globals.shouldAnimate &&
                            l.animationCompleted(t)
                          : "none" !== s &&
                            c.globals.shouldAnimate &&
                            ((!c.globals.comboCharts && e === c.globals.series.length - 1) || c.globals.comboCharts) &&
                            l.animationCompleted(t),
                          l.showDelayedElements();
                      });
                },
              },
            ]),
            t
          );
        })(),
        w = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "getDefaultFilter",
                value: function (t, e) {
                  var i = this.w;
                  t.unfilter(!0),
                    new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"),
                    "none" !== i.config.states.normal.filter
                      ? this.applyFilter(t, e, i.config.states.normal.filter.type, i.config.states.normal.filter.value)
                      : i.config.chart.dropShadow.enabled && this.dropShadow(t, i.config.chart.dropShadow, e);
                },
              },
              {
                key: "addNormalFilter",
                value: function (t, e) {
                  var i = this.w;
                  i.config.chart.dropShadow.enabled &&
                    !t.node.classList.contains("apexcharts-marker") &&
                    this.dropShadow(t, i.config.chart.dropShadow, e);
                },
              },
              {
                key: "addLightenFilter",
                value: function (t, e, i) {
                  var s = this,
                    a = this.w,
                    n = i.intensity;
                  t.unfilter(!0),
                    new window.SVG.Filter(),
                    t.filter(function (t) {
                      var i = a.config.chart.dropShadow;
                      (i.enabled ? s.addShadow(t, e, i) : t).componentTransfer({
                        rgb: { type: "linear", slope: 1.5, intercept: n },
                      });
                    }),
                    t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"),
                    this._scaleFilterSize(t.filterer.node);
                },
              },
              {
                key: "addDarkenFilter",
                value: function (t, e, i) {
                  var s = this,
                    a = this.w,
                    n = i.intensity;
                  t.unfilter(!0),
                    new window.SVG.Filter(),
                    t.filter(function (t) {
                      var i = a.config.chart.dropShadow;
                      (i.enabled ? s.addShadow(t, e, i) : t).componentTransfer({ rgb: { type: "linear", slope: n } });
                    }),
                    t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"),
                    this._scaleFilterSize(t.filterer.node);
                },
              },
              {
                key: "applyFilter",
                value: function (t, e, i) {
                  var s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5;
                  switch (i) {
                    case "none":
                      this.addNormalFilter(t, e);
                      break;
                    case "lighten":
                      this.addLightenFilter(t, e, { intensity: s });
                      break;
                    case "darken":
                      this.addDarkenFilter(t, e, { intensity: s });
                  }
                },
              },
              {
                key: "addShadow",
                value: function (t, e, i) {
                  var s = i.blur,
                    a = i.top,
                    n = i.left,
                    r = i.color,
                    o = i.opacity,
                    l = t
                      .flood(Array.isArray(r) ? r[e] : r, o)
                      .composite(t.sourceAlpha, "in")
                      .offset(n, a)
                      .gaussianBlur(s)
                      .merge(t.source);
                  return t.blend(t.source, l);
                },
              },
              {
                key: "dropShadow",
                value: function (t, e) {
                  var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    s = e.top,
                    a = e.left,
                    n = e.blur,
                    r = e.color,
                    o = e.opacity,
                    l = e.noUserSpaceOnUse,
                    c = this.w;
                  return (
                    t.unfilter(!0),
                    (b.isIE() && "radialBar" === c.config.chart.type) ||
                      ((r = Array.isArray(r) ? r[i] : r),
                      t.filter(function (t) {
                        var e;
                        (e =
                          b.isSafari() || b.isFirefox() || b.isIE()
                            ? t.flood(r, o).composite(t.sourceAlpha, "in").offset(a, s).gaussianBlur(n)
                            : t
                                .flood(r, o)
                                .composite(t.sourceAlpha, "in")
                                .offset(a, s)
                                .gaussianBlur(n)
                                .merge(t.source)),
                          t.blend(t.source, e);
                      }),
                      l || t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"),
                      this._scaleFilterSize(t.filterer.node)),
                    t
                  );
                },
              },
              {
                key: "setSelectionFilter",
                value: function (t, e, i) {
                  var s = this.w;
                  if (void 0 !== s.globals.selectedDataPoints[e] && s.globals.selectedDataPoints[e].indexOf(i) > -1) {
                    t.node.setAttribute("selected", !0);
                    var a = s.config.states.active.filter;
                    "none" !== a && this.applyFilter(t, e, a.type, a.value);
                  }
                },
              },
              {
                key: "_scaleFilterSize",
                value: function (t) {
                  !(function (e) {
                    for (var i in e) e.hasOwnProperty(i) && t.setAttribute(i, e[i]);
                  })({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
                },
              },
            ]),
            t
          );
        })(),
        k = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(
              t,
              [
                {
                  key: "roundPathCorners",
                  value: function (t, e) {
                    function i(t, e, i) {
                      var a = e.x - t.x,
                        n = e.y - t.y,
                        r = Math.sqrt(a * a + n * n);
                      return s(t, e, Math.min(1, i / r));
                    }
                    function s(t, e, i) {
                      return { x: t.x + (e.x - t.x) * i, y: t.y + (e.y - t.y) * i };
                    }
                    function a(t, e) {
                      t.length > 2 && ((t[t.length - 2] = e.x), (t[t.length - 1] = e.y));
                    }
                    function n(t) {
                      return { x: parseFloat(t[t.length - 2]), y: parseFloat(t[t.length - 1]) };
                    }
                    var r = t
                        .split(/[,\s]/)
                        .reduce(function (t, e) {
                          var i = e.match("([a-zA-Z])(.+)");
                          return i ? (t.push(i[1]), t.push(i[2])) : t.push(e), t;
                        }, [])
                        .reduce(function (t, e) {
                          return parseFloat(e) == e && t.length ? t[t.length - 1].push(e) : t.push([e]), t;
                        }, []),
                      o = [];
                    if (r.length > 1) {
                      var l = n(r[0]),
                        c = null;
                      "Z" == r[r.length - 1][0] && r[0].length > 2 && ((c = ["L", l.x, l.y]), (r[r.length - 1] = c)),
                        o.push(r[0]);
                      for (var h = 1; h < r.length; h++) {
                        var d = o[o.length - 1],
                          u = r[h],
                          p = u == c ? r[1] : r[h + 1];
                        if (p && d && d.length > 2 && "L" == u[0] && p.length > 2 && "L" == p[0]) {
                          var g,
                            f,
                            m = n(d),
                            v = n(u),
                            x = n(p);
                          (g = i(v, m, e)), (f = i(v, x, e)), a(u, g), (u.origPoint = v), o.push(u);
                          var b = s(g, v, 0.5),
                            y = s(v, f, 0.5),
                            w = ["C", b.x, b.y, y.x, y.y, f.x, f.y];
                          (w.origPoint = v), o.push(w);
                        } else o.push(u);
                      }
                      if (c) {
                        var k = n(o[o.length - 1]);
                        o.push(["Z"]), a(o[0], k);
                      }
                    } else o = r;
                    return o.reduce(function (t, e) {
                      return t + e.join(" ") + " ";
                    }, "");
                  },
                },
                {
                  key: "drawLine",
                  value: function (t, e, i, s) {
                    var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8",
                      n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                      r = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
                      o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt",
                      l = this.w,
                      c = l.globals.dom.Paper.line().attr({
                        x1: t,
                        y1: e,
                        x2: i,
                        y2: s,
                        stroke: a,
                        "stroke-dasharray": n,
                        "stroke-width": r,
                        "stroke-linecap": o,
                      });
                    return c;
                  },
                },
                {
                  key: "drawRect",
                  value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                      e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                      s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                      a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                      n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe",
                      r = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1,
                      o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
                      l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null,
                      c = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0,
                      h = this.w,
                      d = h.globals.dom.Paper.rect();
                    return (
                      d.attr({
                        x: t,
                        y: e,
                        width: i > 0 ? i : 0,
                        height: s > 0 ? s : 0,
                        rx: a,
                        ry: a,
                        opacity: r,
                        "stroke-width": null !== o ? o : 0,
                        stroke: null !== l ? l : "none",
                        "stroke-dasharray": c,
                      }),
                      d.node.setAttribute("fill", n),
                      d
                    );
                  },
                },
                {
                  key: "drawPolygon",
                  value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1",
                      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                      s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none",
                      a = this.w,
                      n = a.globals.dom.Paper.polygon(t).attr({ fill: s, stroke: e, "stroke-width": i });
                    return n;
                  },
                },
                {
                  key: "drawCircle",
                  value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                      i = this.w;
                    t < 0 && (t = 0);
                    var s = i.globals.dom.Paper.circle(2 * t);
                    return null !== e && s.attr(e), s;
                  },
                },
                {
                  key: "drawPath",
                  value: function (t) {
                    var e = t.d,
                      i = void 0 === e ? "" : e,
                      s = t.stroke,
                      a = void 0 === s ? "#a8a8a8" : s,
                      n = t.strokeWidth,
                      r = void 0 === n ? 1 : n,
                      o = t.fill,
                      l = t.fillOpacity,
                      c = void 0 === l ? 1 : l,
                      h = t.strokeOpacity,
                      d = void 0 === h ? 1 : h,
                      u = t.classes,
                      p = t.strokeLinecap,
                      g = void 0 === p ? null : p,
                      f = t.strokeDashArray,
                      m = void 0 === f ? 0 : f,
                      v = this.w;
                    return (
                      null === g && (g = v.config.stroke.lineCap),
                      (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) &&
                        (i = "M 0 ".concat(v.globals.gridHeight)),
                      v.globals.dom.Paper.path(i).attr({
                        fill: o,
                        "fill-opacity": c,
                        stroke: a,
                        "stroke-opacity": d,
                        "stroke-linecap": g,
                        "stroke-width": r,
                        "stroke-dasharray": m,
                        class: u,
                      })
                    );
                  },
                },
                {
                  key: "group",
                  value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                      e = this.w,
                      i = e.globals.dom.Paper.group();
                    return null !== t && i.attr(t), i;
                  },
                },
                {
                  key: "move",
                  value: function (t, e) {
                    return ["M", t, e].join(" ");
                  },
                },
                {
                  key: "line",
                  value: function (t, e) {
                    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                      s = null;
                    return (
                      null === i
                        ? (s = [" L", t, e].join(" "))
                        : "H" === i
                        ? (s = [" H", t].join(" "))
                        : "V" === i && (s = [" V", e].join(" ")),
                      s
                    );
                  },
                },
                {
                  key: "curve",
                  value: function (t, e, i, s, a, n) {
                    return ["C", t, e, i, s, a, n].join(" ");
                  },
                },
                {
                  key: "quadraticCurve",
                  value: function (t, e, i, s) {
                    return ["Q", t, e, i, s].join(" ");
                  },
                },
                {
                  key: "arc",
                  value: function (t, e, i, s, a, n, r) {
                    var o = arguments.length > 7 && void 0 !== arguments[7] && arguments[7],
                      l = "A";
                    o && (l = "a");
                    var c = [l, t, e, i, s, a, n, r].join(" ");
                    return c;
                  },
                },
                {
                  key: "renderPaths",
                  value: function (t) {
                    var e,
                      i = t.j,
                      s = t.realIndex,
                      a = t.pathFrom,
                      r = t.pathTo,
                      o = t.stroke,
                      l = t.strokeWidth,
                      c = t.strokeLinecap,
                      h = t.fill,
                      d = t.animationDelay,
                      u = t.initialSpeed,
                      p = t.dataChangeSpeed,
                      g = t.className,
                      f = t.shouldClipToGrid,
                      m = void 0 === f || f,
                      v = t.bindEventsOnPaths,
                      x = void 0 === v || v,
                      b = t.drawShadow,
                      k = void 0 === b || b,
                      S = this.w,
                      C = new w(this.ctx),
                      A = new y(this.ctx),
                      E = this.w.config.chart.animations.enabled,
                      T = E && this.w.config.chart.animations.dynamicAnimation.enabled,
                      L = !!((E && !S.globals.resized) || (T && S.globals.dataChanged && S.globals.shouldAnimate));
                    L ? (e = a) : ((e = r), (S.globals.animationEnded = !0));
                    var P,
                      M = S.config.stroke.dashArray;
                    P = Array.isArray(M) ? M[s] : S.config.stroke.dashArray;
                    var O = this.drawPath({
                      d: e,
                      stroke: o,
                      strokeWidth: l,
                      fill: h,
                      fillOpacity: 1,
                      classes: g,
                      strokeLinecap: c,
                      strokeDashArray: P,
                    });
                    if (
                      (O.attr("index", s),
                      m && O.attr({ "clip-path": "url(#gridRectMask".concat(S.globals.cuid, ")") }),
                      "none" !== S.config.states.normal.filter.type)
                    )
                      C.getDefaultFilter(O, s);
                    else if (
                      S.config.chart.dropShadow.enabled &&
                      k &&
                      (!S.config.chart.dropShadow.enabledOnSeries ||
                        (S.config.chart.dropShadow.enabledOnSeries &&
                          -1 !== S.config.chart.dropShadow.enabledOnSeries.indexOf(s)))
                    ) {
                      var I = S.config.chart.dropShadow;
                      C.dropShadow(O, I, s);
                    }
                    x &&
                      (O.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, O)),
                      O.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, O)),
                      O.node.addEventListener("mousedown", this.pathMouseDown.bind(this, O))),
                      O.attr({ pathTo: r, pathFrom: a });
                    var F = { el: O, j: i, realIndex: s, pathFrom: a, pathTo: r, fill: h, strokeWidth: l, delay: d };
                    return (
                      !E || S.globals.resized || S.globals.dataChanged
                        ? (!S.globals.resized && S.globals.dataChanged) || A.showDelayedElements()
                        : A.animatePathsGradually(n(n({}, F), {}, { speed: u })),
                      S.globals.dataChanged && T && L && A.animatePathsGradually(n(n({}, F), {}, { speed: p })),
                      O
                    );
                  },
                },
                {
                  key: "drawPattern",
                  value: function (t, e, i) {
                    var s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8",
                      a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                      n = this.w,
                      r = n.globals.dom.Paper.pattern(e, i, function (n) {
                        "horizontalLines" === t
                          ? n.line(0, 0, i, 0).stroke({ color: s, width: a + 1 })
                          : "verticalLines" === t
                          ? n.line(0, 0, 0, e).stroke({ color: s, width: a + 1 })
                          : "slantedLines" === t
                          ? n.line(0, 0, e, i).stroke({ color: s, width: a })
                          : "squares" === t
                          ? n.rect(e, i).fill("none").stroke({ color: s, width: a })
                          : "circles" === t && n.circle(e).fill("none").stroke({ color: s, width: a });
                      });
                    return r;
                  },
                },
                {
                  key: "drawGradient",
                  value: function (t, e, i, s, a) {
                    var n,
                      r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
                      o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
                      l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
                      c = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
                      h = this.w;
                    e.length < 9 && 0 === e.indexOf("#") && (e = b.hexToRgba(e, s)),
                      i.length < 9 && 0 === i.indexOf("#") && (i = b.hexToRgba(i, a));
                    var d = 0,
                      u = 1,
                      p = 1,
                      g = null;
                    null !== o &&
                      ((d = void 0 !== o[0] ? o[0] / 100 : 0),
                      (u = void 0 !== o[1] ? o[1] / 100 : 1),
                      (p = void 0 !== o[2] ? o[2] / 100 : 1),
                      (g = void 0 !== o[3] ? o[3] / 100 : null));
                    var f = !(
                      "donut" !== h.config.chart.type &&
                      "pie" !== h.config.chart.type &&
                      "polarArea" !== h.config.chart.type &&
                      "bubble" !== h.config.chart.type
                    );
                    if (
                      ((n =
                        null === l || 0 === l.length
                          ? h.globals.dom.Paper.gradient(f ? "radial" : "linear", function (t) {
                              t.at(d, e, s), t.at(u, i, a), t.at(p, i, a), null !== g && t.at(g, e, s);
                            })
                          : h.globals.dom.Paper.gradient(f ? "radial" : "linear", function (t) {
                              (Array.isArray(l[c]) ? l[c] : l).forEach(function (e) {
                                t.at(e.offset / 100, e.color, e.opacity);
                              });
                            })),
                      f)
                    ) {
                      var m = h.globals.gridWidth / 2,
                        v = h.globals.gridHeight / 2;
                      "bubble" !== h.config.chart.type
                        ? n.attr({ gradientUnits: "userSpaceOnUse", cx: m, cy: v, r: r })
                        : n.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
                    } else
                      "vertical" === t
                        ? n.from(0, 0).to(0, 1)
                        : "diagonal" === t
                        ? n.from(0, 0).to(1, 1)
                        : "horizontal" === t
                        ? n.from(0, 1).to(1, 1)
                        : "diagonal2" === t && n.from(1, 0).to(0, 1);
                    return n;
                  },
                },
                {
                  key: "getTextBasedOnMaxWidth",
                  value: function (t) {
                    var e = t.text,
                      i = t.maxWidth,
                      s = t.fontSize,
                      a = t.fontFamily,
                      n = this.getTextRects(e, s, a),
                      r = n.width / e.length,
                      o = Math.floor(i / r);
                    return i < n.width ? e.slice(0, o - 3) + "..." : e;
                  },
                },
                {
                  key: "drawText",
                  value: function (t) {
                    var e = this,
                      i = t.x,
                      s = t.y,
                      a = t.text,
                      r = t.textAnchor,
                      o = t.fontSize,
                      l = t.fontFamily,
                      c = t.fontWeight,
                      h = t.foreColor,
                      d = t.opacity,
                      u = t.maxWidth,
                      p = t.cssClass,
                      g = void 0 === p ? "" : p,
                      f = t.isPlainText,
                      m = void 0 === f || f,
                      v = this.w;
                    void 0 === a && (a = "");
                    var x = a;
                    r || (r = "start"),
                      (h && h.length) || (h = v.config.chart.foreColor),
                      (l = l || v.config.chart.fontFamily),
                      (c = c || "regular");
                    var b,
                      y = { maxWidth: u, fontSize: (o = o || "11px"), fontFamily: l };
                    return (
                      Array.isArray(a)
                        ? (b = v.globals.dom.Paper.text(function (t) {
                            for (var i = 0; i < a.length; i++)
                              (x = a[i]),
                                u && (x = e.getTextBasedOnMaxWidth(n({ text: a[i] }, y))),
                                0 === i ? t.tspan(x) : t.tspan(x).newLine();
                          }))
                        : (u && (x = this.getTextBasedOnMaxWidth(n({ text: a }, y))),
                          (b = m
                            ? v.globals.dom.Paper.plain(a)
                            : v.globals.dom.Paper.text(function (t) {
                                return t.tspan(x);
                              }))),
                      b.attr({
                        x: i,
                        y: s,
                        "text-anchor": r,
                        "dominant-baseline": "auto",
                        "font-size": o,
                        "font-family": l,
                        "font-weight": c,
                        fill: h,
                        class: "apexcharts-text " + g,
                      }),
                      (b.node.style.fontFamily = l),
                      (b.node.style.opacity = d),
                      b
                    );
                  },
                },
                {
                  key: "drawMarker",
                  value: function (t, e, i) {
                    t = t || 0;
                    var s = i.pSize || 0,
                      a = null;
                    if ("square" === i.shape || "rect" === i.shape) {
                      var n = void 0 === i.pRadius ? s / 2 : i.pRadius;
                      (null !== e && s) || ((s = 0), (n = 0));
                      var r = 1.2 * s + n,
                        o = this.drawRect(r, r, r, r, n);
                      o.attr({
                        x: t - r / 2,
                        y: e - r / 2,
                        cx: t,
                        cy: e,
                        class: i.class ? i.class : "",
                        fill: i.pointFillColor,
                        "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
                        stroke: i.pointStrokeColor,
                        "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
                        "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1,
                      }),
                        (a = o);
                    } else
                      ("circle" !== i.shape && i.shape) ||
                        (b.isNumber(e) || ((s = 0), (e = 0)),
                        (a = this.drawCircle(s, {
                          cx: t,
                          cy: e,
                          class: i.class ? i.class : "",
                          stroke: i.pointStrokeColor,
                          fill: i.pointFillColor,
                          "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
                          "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
                          "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1,
                        })));
                    return a;
                  },
                },
                {
                  key: "pathMouseEnter",
                  value: function (t, e) {
                    var i = this.w,
                      s = new w(this.ctx),
                      a = parseInt(t.node.getAttribute("index"), 10),
                      n = parseInt(t.node.getAttribute("j"), 10);
                    if (
                      ("function" == typeof i.config.chart.events.dataPointMouseEnter &&
                        i.config.chart.events.dataPointMouseEnter(e, this.ctx, {
                          seriesIndex: a,
                          dataPointIndex: n,
                          w: i,
                        }),
                      this.ctx.events.fireEvent("dataPointMouseEnter", [
                        e,
                        this.ctx,
                        { seriesIndex: a, dataPointIndex: n, w: i },
                      ]),
                      ("none" === i.config.states.active.filter.type || "true" !== t.node.getAttribute("selected")) &&
                        "none" !== i.config.states.hover.filter.type &&
                        !i.globals.isTouchDevice)
                    ) {
                      var r = i.config.states.hover.filter;
                      s.applyFilter(t, a, r.type, r.value);
                    }
                  },
                },
                {
                  key: "pathMouseLeave",
                  value: function (t, e) {
                    var i = this.w,
                      s = new w(this.ctx),
                      a = parseInt(t.node.getAttribute("index"), 10),
                      n = parseInt(t.node.getAttribute("j"), 10);
                    "function" == typeof i.config.chart.events.dataPointMouseLeave &&
                      i.config.chart.events.dataPointMouseLeave(e, this.ctx, {
                        seriesIndex: a,
                        dataPointIndex: n,
                        w: i,
                      }),
                      this.ctx.events.fireEvent("dataPointMouseLeave", [
                        e,
                        this.ctx,
                        { seriesIndex: a, dataPointIndex: n, w: i },
                      ]),
                      ("none" !== i.config.states.active.filter.type && "true" === t.node.getAttribute("selected")) ||
                        ("none" !== i.config.states.hover.filter.type && s.getDefaultFilter(t, a));
                  },
                },
                {
                  key: "pathMouseDown",
                  value: function (t, e) {
                    var i = this.w,
                      s = new w(this.ctx),
                      a = parseInt(t.node.getAttribute("index"), 10),
                      n = parseInt(t.node.getAttribute("j"), 10),
                      r = "false";
                    if ("true" === t.node.getAttribute("selected")) {
                      if ((t.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[a].indexOf(n) > -1)) {
                        var o = i.globals.selectedDataPoints[a].indexOf(n);
                        i.globals.selectedDataPoints[a].splice(o, 1);
                      }
                    } else {
                      if (
                        !i.config.states.active.allowMultipleDataPointsSelection &&
                        i.globals.selectedDataPoints.length > 0
                      ) {
                        i.globals.selectedDataPoints = [];
                        var l = i.globals.dom.Paper.select(".apexcharts-series path").members,
                          c = i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members,
                          h = function (t) {
                            Array.prototype.forEach.call(t, function (t) {
                              t.node.setAttribute("selected", "false"), s.getDefaultFilter(t, a);
                            });
                          };
                        h(l), h(c);
                      }
                      t.node.setAttribute("selected", "true"),
                        (r = "true"),
                        void 0 === i.globals.selectedDataPoints[a] && (i.globals.selectedDataPoints[a] = []),
                        i.globals.selectedDataPoints[a].push(n);
                    }
                    if ("true" === r) {
                      var d = i.config.states.active.filter;
                      if ("none" !== d) s.applyFilter(t, a, d.type, d.value);
                      else if ("none" !== i.config.states.hover.filter && !i.globals.isTouchDevice) {
                        var u = i.config.states.hover.filter;
                        s.applyFilter(t, a, u.type, u.value);
                      }
                    } else
                      "none" !== i.config.states.active.filter.type &&
                        ("none" === i.config.states.hover.filter.type || i.globals.isTouchDevice
                          ? s.getDefaultFilter(t, a)
                          : ((u = i.config.states.hover.filter), s.applyFilter(t, a, u.type, u.value)));
                    "function" == typeof i.config.chart.events.dataPointSelection &&
                      i.config.chart.events.dataPointSelection(e, this.ctx, {
                        selectedDataPoints: i.globals.selectedDataPoints,
                        seriesIndex: a,
                        dataPointIndex: n,
                        w: i,
                      }),
                      e &&
                        this.ctx.events.fireEvent("dataPointSelection", [
                          e,
                          this.ctx,
                          { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: a, dataPointIndex: n, w: i },
                        ]);
                  },
                },
                {
                  key: "rotateAroundCenter",
                  value: function (t) {
                    var e = {};
                    return (
                      t && "function" == typeof t.getBBox && (e = t.getBBox()),
                      { x: e.x + e.width / 2, y: e.y + e.height / 2 }
                    );
                  },
                },
                {
                  key: "getTextRects",
                  value: function (t, e, i, s) {
                    var a = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                      n = this.w,
                      r = this.drawText({
                        x: -200,
                        y: -200,
                        text: t,
                        textAnchor: "start",
                        fontSize: e,
                        fontFamily: i,
                        foreColor: "#fff",
                        opacity: 0,
                      });
                    s && r.attr("transform", s), n.globals.dom.Paper.add(r);
                    var o = r.bbox();
                    return a || (o = r.node.getBoundingClientRect()), r.remove(), { width: o.width, height: o.height };
                  },
                },
                {
                  key: "placeTextWithEllipsis",
                  value: function (t, e, i) {
                    if (
                      "function" == typeof t.getComputedTextLength &&
                      ((t.textContent = e), e.length > 0 && t.getComputedTextLength() >= i / 1.1)
                    ) {
                      for (var s = e.length - 3; s > 0; s -= 3)
                        if (t.getSubStringLength(0, s) <= i / 1.1)
                          return void (t.textContent = e.substring(0, s) + "...");
                      t.textContent = ".";
                    }
                  },
                },
              ],
              [
                {
                  key: "setAttrs",
                  value: function (t, e) {
                    for (var i in e) e.hasOwnProperty(i) && t.setAttribute(i, e[i]);
                  },
                },
              ]
            ),
            t
          );
        })(),
        S = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(
              t,
              [
                {
                  key: "getStackedSeriesTotals",
                  value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                      e = this.w,
                      i = [];
                    if (0 === e.globals.series.length) return i;
                    for (var s = 0; s < e.globals.series[e.globals.maxValsInArrayIndex].length; s++) {
                      for (var a = 0, n = 0; n < e.globals.series.length; n++)
                        void 0 !== e.globals.series[n][s] && -1 === t.indexOf(n) && (a += e.globals.series[n][s]);
                      i.push(a);
                    }
                    return i;
                  },
                },
                {
                  key: "getSeriesTotalByIndex",
                  value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                    return null === t
                      ? this.w.config.series.reduce(function (t, e) {
                          return t + e;
                        }, 0)
                      : this.w.globals.series[t].reduce(function (t, e) {
                          return t + e;
                        }, 0);
                  },
                },
                {
                  key: "isSeriesNull",
                  value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                    return (
                      0 ===
                      (null === t
                        ? this.w.config.series.filter(function (t) {
                            return null !== t;
                          })
                        : this.w.config.series[t].data.filter(function (t) {
                            return null !== t;
                          })
                      ).length
                    );
                  },
                },
                {
                  key: "seriesHaveSameValues",
                  value: function (t) {
                    return this.w.globals.series[t].every(function (t, e, i) {
                      return t === i[0];
                    });
                  },
                },
                {
                  key: "getCategoryLabels",
                  value: function (t) {
                    var e = this.w,
                      i = t.slice();
                    return (
                      e.config.xaxis.convertedCatToNumeric &&
                        (i = t.map(function (t, i) {
                          return e.config.xaxis.labels.formatter(t - e.globals.minX + 1);
                        })),
                      i
                    );
                  },
                },
                {
                  key: "getLargestSeries",
                  value: function () {
                    var t = this.w;
                    t.globals.maxValsInArrayIndex = t.globals.series
                      .map(function (t) {
                        return t.length;
                      })
                      .indexOf(
                        Math.max.apply(
                          Math,
                          t.globals.series.map(function (t) {
                            return t.length;
                          })
                        )
                      );
                  },
                },
                {
                  key: "getLargestMarkerSize",
                  value: function () {
                    var t = this.w,
                      e = 0;
                    return (
                      t.globals.markers.size.forEach(function (t) {
                        e = Math.max(e, t);
                      }),
                      t.config.markers.discrete &&
                        t.config.markers.discrete.length &&
                        t.config.markers.discrete.forEach(function (t) {
                          e = Math.max(e, t.size);
                        }),
                      e > 0 && (e += t.config.markers.hover.sizeOffset + 1),
                      (t.globals.markers.largestSize = e),
                      e
                    );
                  },
                },
                {
                  key: "getSeriesTotals",
                  value: function () {
                    var t = this.w;
                    t.globals.seriesTotals = t.globals.series.map(function (t, e) {
                      var i = 0;
                      if (Array.isArray(t)) for (var s = 0; s < t.length; s++) i += t[s];
                      else i += t;
                      return i;
                    });
                  },
                },
                {
                  key: "getSeriesTotalsXRange",
                  value: function (t, e) {
                    var i = this.w;
                    return i.globals.series.map(function (s, a) {
                      for (var n = 0, r = 0; r < s.length; r++)
                        i.globals.seriesX[a][r] > t && i.globals.seriesX[a][r] < e && (n += s[r]);
                      return n;
                    });
                  },
                },
                {
                  key: "getPercentSeries",
                  value: function () {
                    var t = this.w;
                    t.globals.seriesPercent = t.globals.series.map(function (e, i) {
                      var s = [];
                      if (Array.isArray(e))
                        for (var a = 0; a < e.length; a++) {
                          var n = t.globals.stackedSeriesTotals[a],
                            r = 0;
                          n && (r = (100 * e[a]) / n), s.push(r);
                        }
                      else {
                        var o =
                          (100 * e) /
                          t.globals.seriesTotals.reduce(function (t, e) {
                            return t + e;
                          }, 0);
                        s.push(o);
                      }
                      return s;
                    });
                  },
                },
                {
                  key: "getCalculatedRatios",
                  value: function () {
                    var t,
                      e,
                      i,
                      s,
                      a = this.w.globals,
                      n = [],
                      r = 0,
                      o = [],
                      l = 0.1,
                      c = 0;
                    if (((a.yRange = []), a.isMultipleYAxis))
                      for (var h = 0; h < a.minYArr.length; h++)
                        a.yRange.push(Math.abs(a.minYArr[h] - a.maxYArr[h])), o.push(0);
                    else a.yRange.push(Math.abs(a.minY - a.maxY));
                    (a.xRange = Math.abs(a.maxX - a.minX)), (a.zRange = Math.abs(a.maxZ - a.minZ));
                    for (var d = 0; d < a.yRange.length; d++) n.push(a.yRange[d] / a.gridHeight);
                    if (
                      ((e = a.xRange / a.gridWidth),
                      (i = Math.abs(a.initialMaxX - a.initialMinX) / a.gridWidth),
                      (t = a.yRange / a.gridWidth),
                      (s = a.xRange / a.gridHeight),
                      (r = (a.zRange / a.gridHeight) * 16) || (r = 1),
                      a.minY !== Number.MIN_VALUE && 0 !== Math.abs(a.minY) && (a.hasNegs = !0),
                      a.isMultipleYAxis)
                    ) {
                      o = [];
                      for (var u = 0; u < n.length; u++) o.push(-a.minYArr[u] / n[u]);
                    } else
                      o.push(-a.minY / n[0]),
                        a.minY !== Number.MIN_VALUE && 0 !== Math.abs(a.minY) && ((l = -a.minY / t), (c = a.minX / e));
                    return {
                      yRatio: n,
                      invertedYRatio: t,
                      zRatio: r,
                      xRatio: e,
                      initialXRatio: i,
                      invertedXRatio: s,
                      baseLineInvertedY: l,
                      baseLineY: o,
                      baseLineX: c,
                    };
                  },
                },
                {
                  key: "getLogSeries",
                  value: function (t) {
                    var e = this,
                      i = this.w;
                    return (
                      (i.globals.seriesLog = t.map(function (t, s) {
                        return i.config.yaxis[s] && i.config.yaxis[s].logarithmic
                          ? t.map(function (t) {
                              return null === t ? null : e.getLogVal(i.config.yaxis[s].logBase, t, s);
                            })
                          : t;
                      })),
                      i.globals.invalidLogScale ? t : i.globals.seriesLog
                    );
                  },
                },
                {
                  key: "getBaseLog",
                  value: function (t, e) {
                    return Math.log(e) / Math.log(t);
                  },
                },
                {
                  key: "getLogVal",
                  value: function (t, e, i) {
                    if (0 === e) return 0;
                    var s = this.w,
                      a = 0 === s.globals.minYArr[i] ? -1 : this.getBaseLog(t, s.globals.minYArr[i]),
                      n = (0 === s.globals.maxYArr[i] ? 0 : this.getBaseLog(t, s.globals.maxYArr[i])) - a;
                    return e < 1 ? e / n : (this.getBaseLog(t, e) - a) / n;
                  },
                },
                {
                  key: "getLogYRatios",
                  value: function (t) {
                    var e = this,
                      i = this.w,
                      s = this.w.globals;
                    return (
                      (s.yLogRatio = t.slice()),
                      (s.logYRange = s.yRange.map(function (t, a) {
                        if (i.config.yaxis[a] && e.w.config.yaxis[a].logarithmic) {
                          var n,
                            r = -Number.MAX_VALUE,
                            o = Number.MIN_VALUE;
                          return (
                            s.seriesLog.forEach(function (t, e) {
                              t.forEach(function (t) {
                                i.config.yaxis[e] &&
                                  i.config.yaxis[e].logarithmic &&
                                  ((r = Math.max(t, r)), (o = Math.min(t, o)));
                              });
                            }),
                            (n = Math.pow(s.yRange[a], Math.abs(o - r) / s.yRange[a])),
                            (s.yLogRatio[a] = n / s.gridHeight),
                            n
                          );
                        }
                      })),
                      s.invalidLogScale ? t.slice() : s.yLogRatio
                    );
                  },
                },
              ],
              [
                {
                  key: "checkComboSeries",
                  value: function (t) {
                    var e = !1,
                      i = 0,
                      s = 0;
                    return (
                      t.length &&
                        void 0 !== t[0].type &&
                        t.forEach(function (t) {
                          ("bar" !== t.type &&
                            "column" !== t.type &&
                            "candlestick" !== t.type &&
                            "boxPlot" !== t.type) ||
                            i++,
                            void 0 !== t.type && s++;
                        }),
                      s > 0 && (e = !0),
                      { comboBarCount: i, comboCharts: e }
                    );
                  },
                },
                {
                  key: "extendArrayProps",
                  value: function (t, e, i) {
                    return (
                      e.yaxis && (e = t.extendYAxis(e, i)),
                      e.annotations &&
                        (e.annotations.yaxis && (e = t.extendYAxisAnnotations(e)),
                        e.annotations.xaxis && (e = t.extendXAxisAnnotations(e)),
                        e.annotations.points && (e = t.extendPointAnnotations(e))),
                      e
                    );
                  },
                },
              ]
            ),
            t
          );
        })(),
        C = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.annoCtx = e);
          }
          return (
            c(t, [
              {
                key: "setOrientations",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                    i = this.w;
                  if ("vertical" === t.label.orientation) {
                    var s = null !== e ? e : 0,
                      a = i.globals.dom.baseEl.querySelector(
                        ".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(s, "']")
                      );
                    if (null !== a) {
                      var n = a.getBoundingClientRect();
                      a.setAttribute("x", parseFloat(a.getAttribute("x")) - n.height + 4),
                        "top" === t.label.position
                          ? a.setAttribute("y", parseFloat(a.getAttribute("y")) + n.width)
                          : a.setAttribute("y", parseFloat(a.getAttribute("y")) - n.width);
                      var r = this.annoCtx.graphics.rotateAroundCenter(a),
                        o = r.x,
                        l = r.y;
                      a.setAttribute("transform", "rotate(-90 ".concat(o, " ").concat(l, ")"));
                    }
                  }
                },
              },
              {
                key: "addBackgroundToAnno",
                value: function (t, e) {
                  var i = this.w;
                  if (!t || void 0 === e.label.text || (void 0 !== e.label.text && !String(e.label.text).trim()))
                    return null;
                  var s = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(),
                    a = t.getBoundingClientRect(),
                    n = e.label.style.padding.left,
                    r = e.label.style.padding.right,
                    o = e.label.style.padding.top,
                    l = e.label.style.padding.bottom;
                  "vertical" === e.label.orientation &&
                    ((o = e.label.style.padding.left),
                    (l = e.label.style.padding.right),
                    (n = e.label.style.padding.top),
                    (r = e.label.style.padding.bottom));
                  var c = a.left - s.left - n,
                    h = a.top - s.top - o,
                    d = this.annoCtx.graphics.drawRect(
                      c - i.globals.barPadForNumericAxis,
                      h,
                      a.width + n + r,
                      a.height + o + l,
                      e.label.borderRadius,
                      e.label.style.background,
                      1,
                      e.label.borderWidth,
                      e.label.borderColor,
                      0
                    );
                  return e.id && d.node.classList.add(e.id), d;
                },
              },
              {
                key: "annotationsBackground",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = function (i, s, a) {
                      var n = e.globals.dom.baseEl.querySelector(
                        ".apexcharts-"
                          .concat(a, "-annotations .apexcharts-")
                          .concat(a, "-annotation-label[rel='")
                          .concat(s, "']")
                      );
                      if (n) {
                        var r = n.parentNode,
                          o = t.addBackgroundToAnno(n, i);
                        o &&
                          (r.insertBefore(o.node, n),
                          i.label.mouseEnter && o.node.addEventListener("mouseenter", i.label.mouseEnter.bind(t, i)),
                          i.label.mouseLeave && o.node.addEventListener("mouseleave", i.label.mouseLeave.bind(t, i)),
                          i.label.click && o.node.addEventListener("click", i.label.click.bind(t, i)));
                      }
                    };
                  e.config.annotations.xaxis.map(function (t, e) {
                    i(t, e, "xaxis");
                  }),
                    e.config.annotations.yaxis.map(function (t, e) {
                      i(t, e, "yaxis");
                    }),
                    e.config.annotations.points.map(function (t, e) {
                      i(t, e, "point");
                    });
                },
              },
              {
                key: "getY1Y2",
                value: function (t, e) {
                  var i,
                    s = "y1" === t ? e.y : e.y2,
                    a = this.w;
                  if (this.annoCtx.invertAxis) {
                    var n = a.globals.labels.indexOf(s);
                    a.config.xaxis.convertedCatToNumeric && (n = a.globals.categoryLabels.indexOf(s));
                    var r = a.globals.dom.baseEl.querySelector(
                      ".apexcharts-yaxis-texts-g text:nth-child(" + (n + 1) + ")"
                    );
                    r && (i = parseFloat(r.getAttribute("y")));
                  } else {
                    var o;
                    (o = a.config.yaxis[e.yAxisIndex].logarithmic
                      ? (s = new S(this.annoCtx.ctx).getLogVal(s, e.yAxisIndex)) / a.globals.yLogRatio[e.yAxisIndex]
                      : (s - a.globals.minYArr[e.yAxisIndex]) /
                        (a.globals.yRange[e.yAxisIndex] / a.globals.gridHeight)),
                      (i = a.globals.gridHeight - o),
                      !e.marker || (void 0 !== e.y && null !== e.y) || (i = 0),
                      a.config.yaxis[e.yAxisIndex] && a.config.yaxis[e.yAxisIndex].reversed && (i = o);
                  }
                  return "string" == typeof s && s.indexOf("px") > -1 && (i = parseFloat(s)), i;
                },
              },
              {
                key: "getX1X2",
                value: function (t, e) {
                  var i = this.w,
                    s = this.annoCtx.invertAxis ? i.globals.minY : i.globals.minX,
                    a = this.annoCtx.invertAxis ? i.globals.maxY : i.globals.maxX,
                    n = this.annoCtx.invertAxis ? i.globals.yRange[0] : i.globals.xRange,
                    r = (e.x - s) / (n / i.globals.gridWidth);
                  this.annoCtx.inversedReversedAxis && (r = (a - e.x) / (n / i.globals.gridWidth)),
                    ("category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric) ||
                      this.annoCtx.invertAxis ||
                      i.globals.dataFormatXNumeric ||
                      (r = this.getStringX(e.x));
                  var o = (e.x2 - s) / (n / i.globals.gridWidth);
                  return (
                    this.annoCtx.inversedReversedAxis && (o = (a - e.x2) / (n / i.globals.gridWidth)),
                    ("category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric) ||
                      this.annoCtx.invertAxis ||
                      i.globals.dataFormatXNumeric ||
                      (o = this.getStringX(e.x2)),
                    (void 0 !== e.x && null !== e.x) || !e.marker || (r = i.globals.gridWidth),
                    "x1" === t && "string" == typeof e.x && e.x.indexOf("px") > -1 && (r = parseFloat(e.x)),
                    "x2" === t && "string" == typeof e.x2 && e.x2.indexOf("px") > -1 && (o = parseFloat(e.x2)),
                    "x1" === t ? r : o
                  );
                },
              },
              {
                key: "getStringX",
                value: function (t) {
                  var e = this.w,
                    i = t;
                  e.config.xaxis.convertedCatToNumeric &&
                    e.globals.categoryLabels.length &&
                    (t = e.globals.categoryLabels.indexOf(t) + 1);
                  var s = e.globals.labels.indexOf(t),
                    a = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (s + 1) + ")");
                  return a && (i = parseFloat(a.getAttribute("x"))), i;
                },
              },
            ]),
            t
          );
        })(),
        A = (function () {
          function t(e) {
            o(this, t),
              (this.w = e.w),
              (this.annoCtx = e),
              (this.invertAxis = this.annoCtx.invertAxis),
              (this.helpers = new C(this.annoCtx));
          }
          return (
            c(t, [
              {
                key: "addXaxisAnnotation",
                value: function (t, e, i) {
                  var s,
                    a = this.w,
                    n = this.helpers.getX1X2("x1", t),
                    r = t.label.text,
                    o = t.strokeDashArray;
                  if (b.isNumber(n)) {
                    if (null === t.x2 || void 0 === t.x2) {
                      var l = this.annoCtx.graphics.drawLine(
                        n + t.offsetX,
                        0 + t.offsetY,
                        n + t.offsetX,
                        a.globals.gridHeight + t.offsetY,
                        t.borderColor,
                        o,
                        t.borderWidth
                      );
                      e.appendChild(l.node), t.id && l.node.classList.add(t.id);
                    } else {
                      if ((s = this.helpers.getX1X2("x2", t)) < n) {
                        var c = n;
                        (n = s), (s = c);
                      }
                      var h = this.annoCtx.graphics.drawRect(
                        n + t.offsetX,
                        0 + t.offsetY,
                        s - n,
                        a.globals.gridHeight + t.offsetY,
                        0,
                        t.fillColor,
                        t.opacity,
                        1,
                        t.borderColor,
                        o
                      );
                      h.node.classList.add("apexcharts-annotation-rect"),
                        h.attr("clip-path", "url(#gridRectMask".concat(a.globals.cuid, ")")),
                        e.appendChild(h.node),
                        t.id && h.node.classList.add(t.id);
                    }
                    var d = this.annoCtx.graphics.getTextRects(r, parseFloat(t.label.style.fontSize)),
                      u =
                        "top" === t.label.position
                          ? 4
                          : "center" === t.label.position
                          ? a.globals.gridHeight / 2 + ("vertical" === t.label.orientation ? d.width / 2 : 0)
                          : a.globals.gridHeight,
                      p = this.annoCtx.graphics.drawText({
                        x: n + t.label.offsetX,
                        y:
                          u +
                          t.label.offsetY -
                          ("vertical" === t.label.orientation
                            ? "top" === t.label.position
                              ? d.width / 2 - 12
                              : -d.width / 2
                            : 0),
                        text: r,
                        textAnchor: t.label.textAnchor,
                        fontSize: t.label.style.fontSize,
                        fontFamily: t.label.style.fontFamily,
                        fontWeight: t.label.style.fontWeight,
                        foreColor: t.label.style.color,
                        cssClass: "apexcharts-xaxis-annotation-label "
                          .concat(t.label.style.cssClass, " ")
                          .concat(t.id ? t.id : ""),
                      });
                    p.attr({ rel: i }), e.appendChild(p.node), this.annoCtx.helpers.setOrientations(t, i);
                  }
                },
              },
              {
                key: "drawXAxisAnnotations",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
                  return (
                    e.config.annotations.xaxis.map(function (e, s) {
                      t.addXaxisAnnotation(e, i.node, s);
                    }),
                    i
                  );
                },
              },
            ]),
            t
          );
        })(),
        E = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.annoCtx = e), (this.helpers = new C(this.annoCtx));
          }
          return (
            c(t, [
              {
                key: "addYaxisAnnotation",
                value: function (t, e, i) {
                  var s,
                    a = this.w,
                    n = t.strokeDashArray,
                    r = this.helpers.getY1Y2("y1", t),
                    o = t.label.text;
                  if (null === t.y2 || void 0 === t.y2) {
                    var l = this.annoCtx.graphics.drawLine(
                      0 + t.offsetX,
                      r + t.offsetY,
                      this._getYAxisAnnotationWidth(t),
                      r + t.offsetY,
                      t.borderColor,
                      n,
                      t.borderWidth
                    );
                    e.appendChild(l.node), t.id && l.node.classList.add(t.id);
                  } else {
                    if ((s = this.helpers.getY1Y2("y2", t)) > r) {
                      var c = r;
                      (r = s), (s = c);
                    }
                    var h = this.annoCtx.graphics.drawRect(
                      0 + t.offsetX,
                      s + t.offsetY,
                      this._getYAxisAnnotationWidth(t),
                      r - s,
                      0,
                      t.fillColor,
                      t.opacity,
                      1,
                      t.borderColor,
                      n
                    );
                    h.node.classList.add("apexcharts-annotation-rect"),
                      h.attr("clip-path", "url(#gridRectMask".concat(a.globals.cuid, ")")),
                      e.appendChild(h.node),
                      t.id && h.node.classList.add(t.id);
                  }
                  var d =
                      "right" === t.label.position
                        ? a.globals.gridWidth
                        : "center" === t.label.position
                        ? a.globals.gridWidth / 2
                        : 0,
                    u = this.annoCtx.graphics.drawText({
                      x: d + t.label.offsetX,
                      y: (null != s ? s : r) + t.label.offsetY - 3,
                      text: o,
                      textAnchor: t.label.textAnchor,
                      fontSize: t.label.style.fontSize,
                      fontFamily: t.label.style.fontFamily,
                      fontWeight: t.label.style.fontWeight,
                      foreColor: t.label.style.color,
                      cssClass: "apexcharts-yaxis-annotation-label "
                        .concat(t.label.style.cssClass, " ")
                        .concat(t.id ? t.id : ""),
                    });
                  u.attr({ rel: i }), e.appendChild(u.node);
                },
              },
              {
                key: "_getYAxisAnnotationWidth",
                value: function (t) {
                  var e = this.w;
                  return (
                    e.globals.gridWidth,
                    (t.width.indexOf("%") > -1
                      ? (e.globals.gridWidth * parseInt(t.width, 10)) / 100
                      : parseInt(t.width, 10)) + t.offsetX
                  );
                },
              },
              {
                key: "drawYAxisAnnotations",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
                  return (
                    e.config.annotations.yaxis.map(function (e, s) {
                      t.addYaxisAnnotation(e, i.node, s);
                    }),
                    i
                  );
                },
              },
            ]),
            t
          );
        })(),
        T = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.annoCtx = e), (this.helpers = new C(this.annoCtx));
          }
          return (
            c(t, [
              {
                key: "addPointAnnotation",
                value: function (t, e, i) {
                  this.w;
                  var s = this.helpers.getX1X2("x1", t),
                    a = this.helpers.getY1Y2("y1", t);
                  if (b.isNumber(s)) {
                    var n = {
                        pSize: t.marker.size,
                        pointStrokeWidth: t.marker.strokeWidth,
                        pointFillColor: t.marker.fillColor,
                        pointStrokeColor: t.marker.strokeColor,
                        shape: t.marker.shape,
                        pRadius: t.marker.radius,
                        class: "apexcharts-point-annotation-marker "
                          .concat(t.marker.cssClass, " ")
                          .concat(t.id ? t.id : ""),
                      },
                      r = this.annoCtx.graphics.drawMarker(s + t.marker.offsetX, a + t.marker.offsetY, n);
                    e.appendChild(r.node);
                    var o = t.label.text ? t.label.text : "",
                      l = this.annoCtx.graphics.drawText({
                        x: s + t.label.offsetX,
                        y: a + t.label.offsetY - t.marker.size - parseFloat(t.label.style.fontSize) / 1.6,
                        text: o,
                        textAnchor: t.label.textAnchor,
                        fontSize: t.label.style.fontSize,
                        fontFamily: t.label.style.fontFamily,
                        fontWeight: t.label.style.fontWeight,
                        foreColor: t.label.style.color,
                        cssClass: "apexcharts-point-annotation-label "
                          .concat(t.label.style.cssClass, " ")
                          .concat(t.id ? t.id : ""),
                      });
                    if ((l.attr({ rel: i }), e.appendChild(l.node), t.customSVG.SVG)) {
                      var c = this.annoCtx.graphics.group({
                        class: "apexcharts-point-annotations-custom-svg " + t.customSVG.cssClass,
                      });
                      c.attr({
                        transform: "translate("
                          .concat(s + t.customSVG.offsetX, ", ")
                          .concat(a + t.customSVG.offsetY, ")"),
                      }),
                        (c.node.innerHTML = t.customSVG.SVG),
                        e.appendChild(c.node);
                    }
                    if (t.image.path) {
                      var h = t.image.width ? t.image.width : 20,
                        d = t.image.height ? t.image.height : 20;
                      r = this.annoCtx.addImage({
                        x: s + t.image.offsetX - h / 2,
                        y: a + t.image.offsetY - d / 2,
                        width: h,
                        height: d,
                        path: t.image.path,
                        appendTo: ".apexcharts-point-annotations",
                      });
                    }
                    t.mouseEnter && r.node.addEventListener("mouseenter", t.mouseEnter.bind(this, t)),
                      t.mouseLeave && r.node.addEventListener("mouseleave", t.mouseLeave.bind(this, t)),
                      t.click && r.node.addEventListener("click", t.click.bind(this, t));
                  }
                },
              },
              {
                key: "drawPointAnnotations",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
                  return (
                    e.config.annotations.points.map(function (e, s) {
                      t.addPointAnnotation(e, i.node, s);
                    }),
                    i
                  );
                },
              },
            ]),
            t
          );
        })(),
        L = {
          name: "en",
          options: {
            months: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December",
            ],
            shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            toolbar: {
              exportToSVG: "Download SVG",
              exportToPNG: "Download PNG",
              exportToCSV: "Download CSV",
              menu: "Menu",
              selection: "Selection",
              selectionZoom: "Selection Zoom",
              zoomIn: "Zoom In",
              zoomOut: "Zoom Out",
              pan: "Panning",
              reset: "Reset Zoom",
            },
          },
        },
        P = (function () {
          function t() {
            o(this, t),
              (this.yAxis = {
                show: !0,
                showAlways: !1,
                showForNullSeries: !0,
                seriesName: void 0,
                opposite: !1,
                reversed: !1,
                logarithmic: !1,
                logBase: 10,
                tickAmount: void 0,
                forceNiceScale: !1,
                max: void 0,
                min: void 0,
                floating: !1,
                decimalsInFloat: void 0,
                labels: {
                  show: !0,
                  minWidth: 0,
                  maxWidth: 160,
                  offsetX: 0,
                  offsetY: 0,
                  align: void 0,
                  rotate: 0,
                  padding: 20,
                  style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" },
                  formatter: void 0,
                },
                axisBorder: { show: !1, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 },
                axisTicks: { show: !1, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 },
                title: {
                  text: void 0,
                  rotate: -90,
                  offsetY: 0,
                  offsetX: 0,
                  style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" },
                },
                tooltip: { enabled: !1, offsetX: 0 },
                crosshairs: { show: !0, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } },
              }),
              (this.pointAnnotation = {
                id: void 0,
                x: 0,
                y: null,
                yAxisIndex: 0,
                seriesIndex: 0,
                mouseEnter: void 0,
                mouseLeave: void 0,
                click: void 0,
                marker: {
                  size: 4,
                  fillColor: "#fff",
                  strokeWidth: 2,
                  strokeColor: "#333",
                  shape: "circle",
                  offsetX: 0,
                  offsetY: 0,
                  radius: 2,
                  cssClass: "",
                },
                label: {
                  borderColor: "#c2c2c2",
                  borderWidth: 1,
                  borderRadius: 2,
                  text: void 0,
                  textAnchor: "middle",
                  offsetX: 0,
                  offsetY: 0,
                  mouseEnter: void 0,
                  mouseLeave: void 0,
                  click: void 0,
                  style: {
                    background: "#fff",
                    color: void 0,
                    fontSize: "11px",
                    fontFamily: void 0,
                    fontWeight: 400,
                    cssClass: "",
                    padding: { left: 5, right: 5, top: 2, bottom: 2 },
                  },
                },
                customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 },
                image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 },
              }),
              (this.yAxisAnnotation = {
                id: void 0,
                y: 0,
                y2: null,
                strokeDashArray: 1,
                fillColor: "#c2c2c2",
                borderColor: "#c2c2c2",
                borderWidth: 1,
                opacity: 0.3,
                offsetX: 0,
                offsetY: 0,
                width: "100%",
                yAxisIndex: 0,
                label: {
                  borderColor: "#c2c2c2",
                  borderWidth: 1,
                  borderRadius: 2,
                  text: void 0,
                  textAnchor: "end",
                  position: "right",
                  offsetX: 0,
                  offsetY: -3,
                  mouseEnter: void 0,
                  mouseLeave: void 0,
                  click: void 0,
                  style: {
                    background: "#fff",
                    color: void 0,
                    fontSize: "11px",
                    fontFamily: void 0,
                    fontWeight: 400,
                    cssClass: "",
                    padding: { left: 5, right: 5, top: 2, bottom: 2 },
                  },
                },
              }),
              (this.xAxisAnnotation = {
                id: void 0,
                x: 0,
                x2: null,
                strokeDashArray: 1,
                fillColor: "#c2c2c2",
                borderColor: "#c2c2c2",
                borderWidth: 1,
                opacity: 0.3,
                offsetX: 0,
                offsetY: 0,
                label: {
                  borderColor: "#c2c2c2",
                  borderWidth: 1,
                  borderRadius: 2,
                  text: void 0,
                  textAnchor: "middle",
                  orientation: "vertical",
                  position: "top",
                  offsetX: 0,
                  offsetY: 0,
                  mouseEnter: void 0,
                  mouseLeave: void 0,
                  click: void 0,
                  style: {
                    background: "#fff",
                    color: void 0,
                    fontSize: "11px",
                    fontFamily: void 0,
                    fontWeight: 400,
                    cssClass: "",
                    padding: { left: 5, right: 5, top: 2, bottom: 2 },
                  },
                },
              }),
              (this.text = {
                x: 0,
                y: 0,
                text: "",
                textAnchor: "start",
                foreColor: void 0,
                fontSize: "13px",
                fontFamily: void 0,
                fontWeight: 400,
                appendTo: ".apexcharts-annotations",
                backgroundColor: "transparent",
                borderColor: "#c2c2c2",
                borderRadius: 0,
                borderWidth: 0,
                paddingLeft: 4,
                paddingRight: 4,
                paddingTop: 2,
                paddingBottom: 2,
              });
          }
          return (
            c(t, [
              {
                key: "init",
                value: function () {
                  return {
                    annotations: {
                      position: "front",
                      yaxis: [this.yAxisAnnotation],
                      xaxis: [this.xAxisAnnotation],
                      points: [this.pointAnnotation],
                      texts: [],
                      images: [],
                      shapes: [],
                    },
                    chart: {
                      animations: {
                        enabled: !0,
                        easing: "easeinout",
                        speed: 800,
                        animateGradually: { delay: 150, enabled: !0 },
                        dynamicAnimation: { enabled: !0, speed: 350 },
                      },
                      background: "transparent",
                      locales: [L],
                      defaultLocale: "en",
                      dropShadow: {
                        enabled: !1,
                        enabledOnSeries: void 0,
                        top: 2,
                        left: 2,
                        blur: 4,
                        color: "#000",
                        opacity: 0.35,
                      },
                      events: {
                        animationEnd: void 0,
                        beforeMount: void 0,
                        mounted: void 0,
                        updated: void 0,
                        click: void 0,
                        mouseMove: void 0,
                        mouseLeave: void 0,
                        xAxisLabelClick: void 0,
                        legendClick: void 0,
                        markerClick: void 0,
                        selection: void 0,
                        dataPointSelection: void 0,
                        dataPointMouseEnter: void 0,
                        dataPointMouseLeave: void 0,
                        beforeZoom: void 0,
                        beforeResetZoom: void 0,
                        zoomed: void 0,
                        scrolled: void 0,
                        brushScrolled: void 0,
                      },
                      foreColor: "#373d3f",
                      fontFamily: "Helvetica, Arial, sans-serif",
                      height: "auto",
                      parentHeightOffset: 15,
                      redrawOnParentResize: !0,
                      redrawOnWindowResize: !0,
                      id: void 0,
                      group: void 0,
                      offsetX: 0,
                      offsetY: 0,
                      selection: {
                        enabled: !1,
                        type: "x",
                        fill: { color: "#24292e", opacity: 0.1 },
                        stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 },
                        xaxis: { min: void 0, max: void 0 },
                        yaxis: { min: void 0, max: void 0 },
                      },
                      sparkline: { enabled: !1 },
                      brush: { enabled: !1, autoScaleYaxis: !0, target: void 0 },
                      stacked: !1,
                      stackType: "normal",
                      toolbar: {
                        show: !0,
                        offsetX: 0,
                        offsetY: 0,
                        tools: {
                          download: !0,
                          selection: !0,
                          zoom: !0,
                          zoomin: !0,
                          zoomout: !0,
                          pan: !0,
                          reset: !0,
                          customIcons: [],
                        },
                        export: {
                          csv: {
                            filename: void 0,
                            columnDelimiter: ",",
                            headerCategory: "category",
                            headerValue: "value",
                            dateFormatter: function (t) {
                              return new Date(t).toDateString();
                            },
                          },
                          png: { filename: void 0 },
                          svg: { filename: void 0 },
                        },
                        autoSelected: "zoom",
                      },
                      type: "line",
                      width: "100%",
                      zoom: {
                        enabled: !0,
                        type: "x",
                        autoScaleYaxis: !1,
                        zoomedArea: {
                          fill: { color: "#90CAF9", opacity: 0.4 },
                          stroke: { color: "#0D47A1", opacity: 0.4, width: 1 },
                        },
                      },
                    },
                    plotOptions: {
                      area: { fillTo: "origin" },
                      bar: {
                        horizontal: !1,
                        columnWidth: "70%",
                        barHeight: "70%",
                        distributed: !1,
                        borderRadius: 0,
                        borderRadiusApplication: "around",
                        borderRadiusWhenStacked: "last",
                        rangeBarOverlap: !0,
                        rangeBarGroupRows: !1,
                        colors: {
                          ranges: [],
                          backgroundBarColors: [],
                          backgroundBarOpacity: 1,
                          backgroundBarRadius: 0,
                        },
                        dataLabels: {
                          position: "top",
                          maxItems: 100,
                          hideOverflowingLabels: !0,
                          orientation: "horizontal",
                          total: {
                            enabled: !1,
                            formatter: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 },
                          },
                        },
                      },
                      bubble: { zScaling: !0, minBubbleRadius: void 0, maxBubbleRadius: void 0 },
                      candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: !0 } },
                      boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } },
                      heatmap: {
                        radius: 2,
                        enableShades: !0,
                        shadeIntensity: 0.5,
                        reverseNegativeShade: !1,
                        distributed: !1,
                        useFillColorAsStroke: !1,
                        colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 },
                      },
                      treemap: {
                        enableShades: !0,
                        shadeIntensity: 0.5,
                        distributed: !1,
                        reverseNegativeShade: !1,
                        useFillColorAsStroke: !1,
                        colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 },
                      },
                      radialBar: {
                        inverseOrder: !1,
                        startAngle: 0,
                        endAngle: 360,
                        offsetX: 0,
                        offsetY: 0,
                        hollow: {
                          margin: 5,
                          size: "50%",
                          background: "transparent",
                          image: void 0,
                          imageWidth: 150,
                          imageHeight: 150,
                          imageOffsetX: 0,
                          imageOffsetY: 0,
                          imageClipped: !0,
                          position: "front",
                          dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 },
                        },
                        track: {
                          show: !0,
                          startAngle: void 0,
                          endAngle: void 0,
                          background: "#f2f2f2",
                          strokeWidth: "97%",
                          opacity: 1,
                          margin: 5,
                          dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 },
                        },
                        dataLabels: {
                          show: !0,
                          name: {
                            show: !0,
                            fontSize: "16px",
                            fontFamily: void 0,
                            fontWeight: 600,
                            color: void 0,
                            offsetY: 0,
                            formatter: function (t) {
                              return t;
                            },
                          },
                          value: {
                            show: !0,
                            fontSize: "14px",
                            fontFamily: void 0,
                            fontWeight: 400,
                            color: void 0,
                            offsetY: 16,
                            formatter: function (t) {
                              return t + "%";
                            },
                          },
                          total: {
                            show: !1,
                            label: "Total",
                            fontSize: "16px",
                            fontWeight: 600,
                            fontFamily: void 0,
                            color: void 0,
                            formatter: function (t) {
                              return (
                                t.globals.seriesTotals.reduce(function (t, e) {
                                  return t + e;
                                }, 0) /
                                  t.globals.series.length +
                                "%"
                              );
                            },
                          },
                        },
                      },
                      pie: {
                        customScale: 1,
                        offsetX: 0,
                        offsetY: 0,
                        startAngle: 0,
                        endAngle: 360,
                        expandOnClick: !0,
                        dataLabels: { offset: 0, minAngleToShowLabel: 10 },
                        donut: {
                          size: "65%",
                          background: "transparent",
                          labels: {
                            show: !1,
                            name: {
                              show: !0,
                              fontSize: "16px",
                              fontFamily: void 0,
                              fontWeight: 600,
                              color: void 0,
                              offsetY: -10,
                              formatter: function (t) {
                                return t;
                              },
                            },
                            value: {
                              show: !0,
                              fontSize: "20px",
                              fontFamily: void 0,
                              fontWeight: 400,
                              color: void 0,
                              offsetY: 10,
                              formatter: function (t) {
                                return t;
                              },
                            },
                            total: {
                              show: !1,
                              showAlways: !1,
                              label: "Total",
                              fontSize: "16px",
                              fontWeight: 400,
                              fontFamily: void 0,
                              color: void 0,
                              formatter: function (t) {
                                return t.globals.seriesTotals.reduce(function (t, e) {
                                  return t + e;
                                }, 0);
                              },
                            },
                          },
                        },
                      },
                      polarArea: {
                        rings: { strokeWidth: 1, strokeColor: "#e8e8e8" },
                        spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" },
                      },
                      radar: {
                        size: void 0,
                        offsetX: 0,
                        offsetY: 0,
                        polygons: {
                          strokeWidth: 1,
                          strokeColors: "#e8e8e8",
                          connectorColors: "#e8e8e8",
                          fill: { colors: void 0 },
                        },
                      },
                    },
                    colors: void 0,
                    dataLabels: {
                      enabled: !0,
                      enabledOnSeries: void 0,
                      formatter: function (t) {
                        return null !== t ? t : "";
                      },
                      textAnchor: "middle",
                      distributed: !1,
                      offsetX: 0,
                      offsetY: 0,
                      style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 },
                      background: {
                        enabled: !0,
                        foreColor: "#fff",
                        borderRadius: 2,
                        padding: 4,
                        opacity: 0.9,
                        borderWidth: 1,
                        borderColor: "#fff",
                        dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 },
                      },
                      dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 },
                    },
                    fill: {
                      type: "solid",
                      colors: void 0,
                      opacity: 0.85,
                      gradient: {
                        shade: "dark",
                        type: "horizontal",
                        shadeIntensity: 0.5,
                        gradientToColors: void 0,
                        inverseColors: !0,
                        opacityFrom: 1,
                        opacityTo: 1,
                        stops: [0, 50, 100],
                        colorStops: [],
                      },
                      image: { src: [], width: void 0, height: void 0 },
                      pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 },
                    },
                    forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 },
                    grid: {
                      show: !0,
                      borderColor: "#e0e0e0",
                      strokeDashArray: 0,
                      position: "back",
                      xaxis: { lines: { show: !1 } },
                      yaxis: { lines: { show: !0 } },
                      row: { colors: void 0, opacity: 0.5 },
                      column: { colors: void 0, opacity: 0.5 },
                      padding: { top: 0, right: 10, bottom: 0, left: 12 },
                    },
                    labels: [],
                    legend: {
                      show: !0,
                      showForSingleSeries: !1,
                      showForNullSeries: !0,
                      showForZeroSeries: !0,
                      floating: !1,
                      position: "bottom",
                      horizontalAlign: "center",
                      inverseOrder: !1,
                      fontSize: "12px",
                      fontFamily: void 0,
                      fontWeight: 400,
                      width: void 0,
                      height: void 0,
                      formatter: void 0,
                      tooltipHoverFormatter: void 0,
                      offsetX: -20,
                      offsetY: 4,
                      customLegendItems: [],
                      labels: { colors: void 0, useSeriesColors: !1 },
                      markers: {
                        width: 12,
                        height: 12,
                        strokeWidth: 0,
                        fillColors: void 0,
                        strokeColor: "#fff",
                        radius: 12,
                        customHTML: void 0,
                        offsetX: 0,
                        offsetY: 0,
                        onClick: void 0,
                      },
                      itemMargin: { horizontal: 5, vertical: 2 },
                      onItemClick: { toggleDataSeries: !0 },
                      onItemHover: { highlightDataSeries: !0 },
                    },
                    markers: {
                      discrete: [],
                      size: 0,
                      colors: void 0,
                      strokeColors: "#fff",
                      strokeWidth: 2,
                      strokeOpacity: 0.9,
                      strokeDashArray: 0,
                      fillOpacity: 1,
                      shape: "circle",
                      width: 8,
                      height: 8,
                      radius: 2,
                      offsetX: 0,
                      offsetY: 0,
                      onClick: void 0,
                      onDblClick: void 0,
                      showNullDataPoints: !0,
                      hover: { size: void 0, sizeOffset: 3 },
                    },
                    noData: {
                      text: void 0,
                      align: "center",
                      verticalAlign: "middle",
                      offsetX: 0,
                      offsetY: 0,
                      style: { color: void 0, fontSize: "14px", fontFamily: void 0 },
                    },
                    responsive: [],
                    series: void 0,
                    states: {
                      normal: { filter: { type: "none", value: 0 } },
                      hover: { filter: { type: "lighten", value: 0.1 } },
                      active: { allowMultipleDataPointsSelection: !1, filter: { type: "darken", value: 0.5 } },
                    },
                    title: {
                      text: void 0,
                      align: "left",
                      margin: 5,
                      offsetX: 0,
                      offsetY: 0,
                      floating: !1,
                      style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 },
                    },
                    subtitle: {
                      text: void 0,
                      align: "left",
                      margin: 5,
                      offsetX: 0,
                      offsetY: 30,
                      floating: !1,
                      style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 },
                    },
                    stroke: {
                      show: !0,
                      curve: "smooth",
                      lineCap: "butt",
                      width: 2,
                      colors: void 0,
                      dashArray: 0,
                      fill: {
                        type: "solid",
                        colors: void 0,
                        opacity: 0.85,
                        gradient: {
                          shade: "dark",
                          type: "horizontal",
                          shadeIntensity: 0.5,
                          gradientToColors: void 0,
                          inverseColors: !0,
                          opacityFrom: 1,
                          opacityTo: 1,
                          stops: [0, 50, 100],
                          colorStops: [],
                        },
                      },
                    },
                    tooltip: {
                      enabled: !0,
                      enabledOnSeries: void 0,
                      shared: !0,
                      followCursor: !1,
                      intersect: !1,
                      inverseOrder: !1,
                      custom: void 0,
                      fillSeriesColor: !1,
                      theme: "light",
                      cssClass: "",
                      style: { fontSize: "12px", fontFamily: void 0 },
                      onDatasetHover: { highlightDataSeries: !1 },
                      x: { show: !0, format: "dd MMM", formatter: void 0 },
                      y: {
                        formatter: void 0,
                        title: {
                          formatter: function (t) {
                            return t ? t + ": " : "";
                          },
                        },
                      },
                      z: { formatter: void 0, title: "Size: " },
                      marker: { show: !0, fillColors: void 0 },
                      items: { display: "flex" },
                      fixed: { enabled: !1, position: "topRight", offsetX: 0, offsetY: 0 },
                    },
                    xaxis: {
                      type: "category",
                      categories: [],
                      convertedCatToNumeric: !1,
                      offsetX: 0,
                      offsetY: 0,
                      overwriteCategories: void 0,
                      labels: {
                        show: !0,
                        rotate: -45,
                        rotateAlways: !1,
                        hideOverlappingLabels: !0,
                        trim: !1,
                        minHeight: void 0,
                        maxHeight: 120,
                        showDuplicates: !0,
                        style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" },
                        offsetX: 0,
                        offsetY: 0,
                        format: void 0,
                        formatter: void 0,
                        datetimeUTC: !0,
                        datetimeFormatter: {
                          year: "yyyy",
                          month: "MMM 'yy",
                          day: "dd MMM",
                          hour: "HH:mm",
                          minute: "HH:mm:ss",
                          second: "HH:mm:ss",
                        },
                      },
                      group: {
                        groups: [],
                        style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" },
                      },
                      axisBorder: { show: !0, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 },
                      axisTicks: { show: !0, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 },
                      tickAmount: void 0,
                      tickPlacement: "on",
                      min: void 0,
                      max: void 0,
                      range: void 0,
                      floating: !1,
                      decimalsInFloat: void 0,
                      position: "bottom",
                      title: {
                        text: void 0,
                        offsetX: 0,
                        offsetY: 0,
                        style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" },
                      },
                      crosshairs: {
                        show: !0,
                        width: 1,
                        position: "back",
                        opacity: 0.9,
                        stroke: { color: "#b6b6b6", width: 1, dashArray: 3 },
                        fill: {
                          type: "solid",
                          color: "#B1B9C4",
                          gradient: {
                            colorFrom: "#D8E3F0",
                            colorTo: "#BED1E6",
                            stops: [0, 100],
                            opacityFrom: 0.4,
                            opacityTo: 0.5,
                          },
                        },
                        dropShadow: { enabled: !1, left: 0, top: 0, blur: 1, opacity: 0.4 },
                      },
                      tooltip: {
                        enabled: !0,
                        offsetY: 0,
                        formatter: void 0,
                        style: { fontSize: "12px", fontFamily: void 0 },
                      },
                    },
                    yaxis: this.yAxis,
                    theme: {
                      mode: "light",
                      palette: "palette1",
                      monochrome: { enabled: !1, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 },
                    },
                  };
                },
              },
            ]),
            t
          );
        })(),
        M = (function () {
          function t(e) {
            o(this, t),
              (this.ctx = e),
              (this.w = e.w),
              (this.graphics = new k(this.ctx)),
              this.w.globals.isBarHorizontal && (this.invertAxis = !0),
              (this.helpers = new C(this)),
              (this.xAxisAnnotations = new A(this)),
              (this.yAxisAnnotations = new E(this)),
              (this.pointsAnnotations = new T(this)),
              this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0),
              (this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints);
          }
          return (
            c(t, [
              {
                key: "drawAxesAnnotations",
                value: function () {
                  var t = this.w;
                  if (t.globals.axisCharts) {
                    for (
                      var e = this.yAxisAnnotations.drawYAxisAnnotations(),
                        i = this.xAxisAnnotations.drawXAxisAnnotations(),
                        s = this.pointsAnnotations.drawPointAnnotations(),
                        a = t.config.chart.animations.enabled,
                        n = [e, i, s],
                        r = [i.node, e.node, s.node],
                        o = 0;
                      o < 3;
                      o++
                    )
                      t.globals.dom.elGraphical.add(n[o]),
                        !a ||
                          t.globals.resized ||
                          t.globals.dataChanged ||
                          ("scatter" !== t.config.chart.type &&
                            "bubble" !== t.config.chart.type &&
                            t.globals.dataPoints > 1 &&
                            r[o].classList.add("apexcharts-element-hidden")),
                        t.globals.delayedElements.push({ el: r[o], index: 0 });
                    this.helpers.annotationsBackground();
                  }
                },
              },
              {
                key: "drawImageAnnos",
                value: function () {
                  var t = this;
                  this.w.config.annotations.images.map(function (e, i) {
                    t.addImage(e, i);
                  });
                },
              },
              {
                key: "drawTextAnnos",
                value: function () {
                  var t = this;
                  this.w.config.annotations.texts.map(function (e, i) {
                    t.addText(e, i);
                  });
                },
              },
              {
                key: "addXaxisAnnotation",
                value: function (t, e, i) {
                  this.xAxisAnnotations.addXaxisAnnotation(t, e, i);
                },
              },
              {
                key: "addYaxisAnnotation",
                value: function (t, e, i) {
                  this.yAxisAnnotations.addYaxisAnnotation(t, e, i);
                },
              },
              {
                key: "addPointAnnotation",
                value: function (t, e, i) {
                  this.pointsAnnotations.addPointAnnotation(t, e, i);
                },
              },
              {
                key: "addText",
                value: function (t, e) {
                  var i = t.x,
                    s = t.y,
                    a = t.text,
                    n = t.textAnchor,
                    r = t.foreColor,
                    o = t.fontSize,
                    l = t.fontFamily,
                    c = t.fontWeight,
                    h = t.cssClass,
                    d = t.backgroundColor,
                    u = t.borderWidth,
                    p = t.strokeDashArray,
                    g = t.borderRadius,
                    f = t.borderColor,
                    m = t.appendTo,
                    v = void 0 === m ? ".apexcharts-annotations" : m,
                    x = t.paddingLeft,
                    b = void 0 === x ? 4 : x,
                    y = t.paddingRight,
                    w = void 0 === y ? 4 : y,
                    k = t.paddingBottom,
                    S = void 0 === k ? 2 : k,
                    C = t.paddingTop,
                    A = void 0 === C ? 2 : C,
                    E = this.w,
                    T = this.graphics.drawText({
                      x: i,
                      y: s,
                      text: a,
                      textAnchor: n || "start",
                      fontSize: o || "12px",
                      fontWeight: c || "regular",
                      fontFamily: l || E.config.chart.fontFamily,
                      foreColor: r || E.config.chart.foreColor,
                      cssClass: h,
                    }),
                    L = E.globals.dom.baseEl.querySelector(v);
                  L && L.appendChild(T.node);
                  var P = T.bbox();
                  if (a) {
                    var M = this.graphics.drawRect(
                      P.x - b,
                      P.y - A,
                      P.width + b + w,
                      P.height + S + A,
                      g,
                      d || "transparent",
                      1,
                      u,
                      f,
                      p
                    );
                    L.insertBefore(M.node, T.node);
                  }
                },
              },
              {
                key: "addImage",
                value: function (t, e) {
                  var i = this.w,
                    s = t.path,
                    a = t.x,
                    n = void 0 === a ? 0 : a,
                    r = t.y,
                    o = void 0 === r ? 0 : r,
                    l = t.width,
                    c = void 0 === l ? 20 : l,
                    h = t.height,
                    d = void 0 === h ? 20 : h,
                    u = t.appendTo,
                    p = void 0 === u ? ".apexcharts-annotations" : u,
                    g = i.globals.dom.Paper.image(s);
                  g.size(c, d).move(n, o);
                  var f = i.globals.dom.baseEl.querySelector(p);
                  return f && f.appendChild(g.node), g;
                },
              },
              {
                key: "addXaxisAnnotationExternal",
                value: function (t, e, i) {
                  return (
                    this.addAnnotationExternal({
                      params: t,
                      pushToMemory: e,
                      context: i,
                      type: "xaxis",
                      contextMethod: i.addXaxisAnnotation,
                    }),
                    i
                  );
                },
              },
              {
                key: "addYaxisAnnotationExternal",
                value: function (t, e, i) {
                  return (
                    this.addAnnotationExternal({
                      params: t,
                      pushToMemory: e,
                      context: i,
                      type: "yaxis",
                      contextMethod: i.addYaxisAnnotation,
                    }),
                    i
                  );
                },
              },
              {
                key: "addPointAnnotationExternal",
                value: function (t, e, i) {
                  return (
                    void 0 === this.invertAxis && (this.invertAxis = i.w.globals.isBarHorizontal),
                    this.addAnnotationExternal({
                      params: t,
                      pushToMemory: e,
                      context: i,
                      type: "point",
                      contextMethod: i.addPointAnnotation,
                    }),
                    i
                  );
                },
              },
              {
                key: "addAnnotationExternal",
                value: function (t) {
                  var e = t.params,
                    i = t.pushToMemory,
                    s = t.context,
                    a = t.type,
                    n = t.contextMethod,
                    r = s,
                    o = r.w,
                    l = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(a, "-annotations")),
                    c = l.childNodes.length + 1,
                    h = new P(),
                    d = Object.assign(
                      {},
                      "xaxis" === a ? h.xAxisAnnotation : "yaxis" === a ? h.yAxisAnnotation : h.pointAnnotation
                    ),
                    u = b.extend(d, e);
                  switch (a) {
                    case "xaxis":
                      this.addXaxisAnnotation(u, l, c);
                      break;
                    case "yaxis":
                      this.addYaxisAnnotation(u, l, c);
                      break;
                    case "point":
                      this.addPointAnnotation(u, l, c);
                  }
                  var p = o.globals.dom.baseEl.querySelector(
                      ".apexcharts-"
                        .concat(a, "-annotations .apexcharts-")
                        .concat(a, "-annotation-label[rel='")
                        .concat(c, "']")
                    ),
                    g = this.helpers.addBackgroundToAnno(p, u);
                  return (
                    g && l.insertBefore(g.node, p),
                    i &&
                      o.globals.memory.methodsToExec.push({
                        context: r,
                        id: u.id ? u.id : b.randomId(),
                        method: n,
                        label: "addAnnotation",
                        params: e,
                      }),
                    s
                  );
                },
              },
              {
                key: "clearAnnotations",
                value: function (t) {
                  var e = t.w,
                    i = e.globals.dom.baseEl.querySelectorAll(
                      ".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations"
                    );
                  e.globals.memory.methodsToExec.map(function (t, i) {
                    ("addText" !== t.label && "addAnnotation" !== t.label) ||
                      e.globals.memory.methodsToExec.splice(i, 1);
                  }),
                    (i = b.listToArray(i)),
                    Array.prototype.forEach.call(i, function (t) {
                      for (; t.firstChild; ) t.removeChild(t.firstChild);
                    });
                },
              },
              {
                key: "removeAnnotation",
                value: function (t, e) {
                  var i = t.w,
                    s = i.globals.dom.baseEl.querySelectorAll(".".concat(e));
                  s &&
                    (i.globals.memory.methodsToExec.map(function (t, s) {
                      t.id === e && i.globals.memory.methodsToExec.splice(s, 1);
                    }),
                    Array.prototype.forEach.call(s, function (t) {
                      t.parentElement.removeChild(t);
                    }));
                },
              },
            ]),
            t
          );
        })(),
        O = (function () {
          function t(e) {
            o(this, t),
              (this.ctx = e),
              (this.w = e.w),
              (this.months31 = [1, 3, 5, 7, 8, 10, 12]),
              (this.months30 = [2, 4, 6, 9, 11]),
              (this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]);
          }
          return (
            c(t, [
              {
                key: "isValidDate",
                value: function (t) {
                  return !isNaN(this.parseDate(t));
                },
              },
              {
                key: "getTimeStamp",
                value: function (t) {
                  return Date.parse(t)
                    ? this.w.config.xaxis.labels.datetimeUTC
                      ? new Date(new Date(t).toISOString().substr(0, 25)).getTime()
                      : new Date(t).getTime()
                    : t;
                },
              },
              {
                key: "getDate",
                value: function (t) {
                  return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toUTCString()) : new Date(t);
                },
              },
              {
                key: "parseDate",
                value: function (t) {
                  var e = Date.parse(t);
                  if (!isNaN(e)) return this.getTimeStamp(t);
                  var i = Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
                  return this.getTimeStamp(i);
                },
              },
              {
                key: "parseDateWithTimezone",
                value: function (t) {
                  return Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
                },
              },
              {
                key: "formatDate",
                value: function (t, e) {
                  var i = this.w.globals.locale,
                    s = this.w.config.xaxis.labels.datetimeUTC,
                    a = ["\0"].concat(m(i.months)),
                    n = [""].concat(m(i.shortMonths)),
                    r = [""].concat(m(i.days)),
                    o = [""].concat(m(i.shortDays));
                  function l(t, e) {
                    var i = t + "";
                    for (e = e || 2; i.length < e; ) i = "0" + i;
                    return i;
                  }
                  var c = s ? t.getUTCFullYear() : t.getFullYear();
                  e = (e = (e = e.replace(/(^|[^\\])yyyy+/g, "$1" + c)).replace(
                    /(^|[^\\])yy/g,
                    "$1" + c.toString().substr(2, 2)
                  )).replace(/(^|[^\\])y/g, "$1" + c);
                  var h = (s ? t.getUTCMonth() : t.getMonth()) + 1;
                  e = (e = (e = (e = e.replace(/(^|[^\\])MMMM+/g, "$1" + a[0])).replace(
                    /(^|[^\\])MMM/g,
                    "$1" + n[0]
                  )).replace(/(^|[^\\])MM/g, "$1" + l(h))).replace(/(^|[^\\])M/g, "$1" + h);
                  var d = s ? t.getUTCDate() : t.getDate();
                  e = (e = (e = (e = e.replace(/(^|[^\\])dddd+/g, "$1" + r[0])).replace(
                    /(^|[^\\])ddd/g,
                    "$1" + o[0]
                  )).replace(/(^|[^\\])dd/g, "$1" + l(d))).replace(/(^|[^\\])d/g, "$1" + d);
                  var u = s ? t.getUTCHours() : t.getHours(),
                    p = u > 12 ? u - 12 : 0 === u ? 12 : u;
                  e = (e = (e = (e = e.replace(/(^|[^\\])HH+/g, "$1" + l(u))).replace(/(^|[^\\])H/g, "$1" + u)).replace(
                    /(^|[^\\])hh+/g,
                    "$1" + l(p)
                  )).replace(/(^|[^\\])h/g, "$1" + p);
                  var g = s ? t.getUTCMinutes() : t.getMinutes();
                  e = (e = e.replace(/(^|[^\\])mm+/g, "$1" + l(g))).replace(/(^|[^\\])m/g, "$1" + g);
                  var f = s ? t.getUTCSeconds() : t.getSeconds();
                  e = (e = e.replace(/(^|[^\\])ss+/g, "$1" + l(f))).replace(/(^|[^\\])s/g, "$1" + f);
                  var v = s ? t.getUTCMilliseconds() : t.getMilliseconds();
                  (e = e.replace(/(^|[^\\])fff+/g, "$1" + l(v, 3))),
                    (v = Math.round(v / 10)),
                    (e = e.replace(/(^|[^\\])ff/g, "$1" + l(v))),
                    (v = Math.round(v / 10));
                  var x = u < 12 ? "AM" : "PM";
                  e = (e = (e = e.replace(/(^|[^\\])f/g, "$1" + v)).replace(/(^|[^\\])TT+/g, "$1" + x)).replace(
                    /(^|[^\\])T/g,
                    "$1" + x.charAt(0)
                  );
                  var b = x.toLowerCase();
                  e = (e = e.replace(/(^|[^\\])tt+/g, "$1" + b)).replace(/(^|[^\\])t/g, "$1" + b.charAt(0));
                  var y = -t.getTimezoneOffset(),
                    w = s || !y ? "Z" : y > 0 ? "+" : "-";
                  if (!s) {
                    var k = (y = Math.abs(y)) % 60;
                    w += l(Math.floor(y / 60)) + ":" + l(k);
                  }
                  e = e.replace(/(^|[^\\])K/g, "$1" + w);
                  var S = (s ? t.getUTCDay() : t.getDay()) + 1;
                  return (e = (e = (e = (e = e.replace(new RegExp(r[0], "g"), r[S])).replace(
                    new RegExp(o[0], "g"),
                    o[S]
                  )).replace(new RegExp(a[0], "g"), a[h])).replace(new RegExp(n[0], "g"), n[h])).replace(
                    /\\(.)/g,
                    "$1"
                  );
                },
              },
              {
                key: "getTimeUnitsfromTimestamp",
                value: function (t, e, i) {
                  var s = this.w;
                  void 0 !== s.config.xaxis.min && (t = s.config.xaxis.min),
                    void 0 !== s.config.xaxis.max && (e = s.config.xaxis.max);
                  var a = this.getDate(t),
                    n = this.getDate(e),
                    r = this.formatDate(a, "yyyy MM dd HH mm ss fff").split(" "),
                    o = this.formatDate(n, "yyyy MM dd HH mm ss fff").split(" ");
                  return {
                    minMillisecond: parseInt(r[6], 10),
                    maxMillisecond: parseInt(o[6], 10),
                    minSecond: parseInt(r[5], 10),
                    maxSecond: parseInt(o[5], 10),
                    minMinute: parseInt(r[4], 10),
                    maxMinute: parseInt(o[4], 10),
                    minHour: parseInt(r[3], 10),
                    maxHour: parseInt(o[3], 10),
                    minDate: parseInt(r[2], 10),
                    maxDate: parseInt(o[2], 10),
                    minMonth: parseInt(r[1], 10) - 1,
                    maxMonth: parseInt(o[1], 10) - 1,
                    minYear: parseInt(r[0], 10),
                    maxYear: parseInt(o[0], 10),
                  };
                },
              },
              {
                key: "isLeapYear",
                value: function (t) {
                  return (t % 4 == 0 && t % 100 != 0) || t % 400 == 0;
                },
              },
              {
                key: "calculcateLastDaysOfMonth",
                value: function (t, e, i) {
                  return this.determineDaysOfMonths(t, e) - i;
                },
              },
              {
                key: "determineDaysOfYear",
                value: function (t) {
                  var e = 365;
                  return this.isLeapYear(t) && (e = 366), e;
                },
              },
              {
                key: "determineRemainingDaysOfYear",
                value: function (t, e, i) {
                  var s = this.daysCntOfYear[e] + i;
                  return e > 1 && this.isLeapYear() && s++, s;
                },
              },
              {
                key: "determineDaysOfMonths",
                value: function (t, e) {
                  var i = 30;
                  switch (((t = b.monthMod(t)), !0)) {
                    case this.months30.indexOf(t) > -1:
                      2 === t && (i = this.isLeapYear(e) ? 29 : 28);
                      break;
                    case this.months31.indexOf(t) > -1:
                    default:
                      i = 31;
                  }
                  return i;
                },
              },
            ]),
            t
          );
        })(),
        I = function (t) {
          var e,
            i = t.ctx,
            s = t.seriesIndex,
            a = t.dataPointIndex,
            n = t.y1,
            r = t.y2,
            o = t.w,
            l = o.globals.seriesRangeStart[s][a],
            c = o.globals.seriesRangeEnd[s][a],
            h = o.globals.labels[a],
            d = o.config.series[s].name ? o.config.series[s].name : "",
            u = o.config.tooltip.y.formatter,
            p = o.config.tooltip.y.title.formatter,
            g = { w: o, seriesIndex: s, dataPointIndex: a, start: l, end: c };
          "function" == typeof p && (d = p(d, g)),
            null !== (e = o.config.series[s].data[a]) &&
              void 0 !== e &&
              e.x &&
              (h = o.config.series[s].data[a].x + ":"),
            "function" == typeof u && (h = u(h, g)),
            Number.isFinite(n) && Number.isFinite(r) && ((l = n), (c = r));
          var f = "",
            m = "",
            v = o.globals.colors[s];
          if (void 0 === o.config.tooltip.x.formatter)
            if ("datetime" === o.config.xaxis.type) {
              var x = new O(i);
              (f = x.formatDate(x.getDate(l), o.config.tooltip.x.format)),
                (m = x.formatDate(x.getDate(c), o.config.tooltip.x.format));
            } else (f = l), (m = c);
          else (f = o.config.tooltip.x.formatter(l)), (m = o.config.tooltip.x.formatter(c));
          return { start: l, end: c, startVal: f, endVal: m, ylabel: h, color: v, seriesName: d };
        },
        F = function (t) {
          var e = t.color,
            i = t.seriesName,
            s = t.ylabel,
            a = t.start,
            n = t.end,
            r = t.seriesIndex,
            o = t.dataPointIndex,
            l = t.ctx.tooltip.tooltipLabels.getFormatters(r);
          (a = l.yLbFormatter(a)), (n = l.yLbFormatter(n));
          var c = l.yLbFormatter(t.w.globals.series[r][o]),
            h = '<span class="value start-value">\n  '
              .concat(a, '\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ')
              .concat(n, "\n  </span>");
          return (
            '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' +
            e +
            '">' +
            (i || "") +
            '</span></div><div> <span class="category">' +
            s +
            " </span> " +
            (t.w.globals.comboCharts
              ? "rangeArea" === t.w.config.series[r].type || "rangeBar" === t.w.config.series[r].type
                ? h
                : "<span>".concat(c, "</span>")
              : h) +
            " </div></div>"
          );
        },
        D = (function () {
          function t(e) {
            o(this, t), (this.opts = e);
          }
          return (
            c(t, [
              {
                key: "line",
                value: function () {
                  return {
                    chart: { animations: { easing: "swing" } },
                    dataLabels: { enabled: !1 },
                    stroke: { width: 5, curve: "straight" },
                    markers: { size: 0, hover: { sizeOffset: 6 } },
                    xaxis: { crosshairs: { width: 1 } },
                  };
                },
              },
              {
                key: "sparkline",
                value: function (t) {
                  return (
                    (this.opts.yaxis[0].show = !1),
                    (this.opts.yaxis[0].title.text = ""),
                    (this.opts.yaxis[0].axisBorder.show = !1),
                    (this.opts.yaxis[0].axisTicks.show = !1),
                    (this.opts.yaxis[0].floating = !0),
                    b.extend(t, {
                      grid: { show: !1, padding: { left: 0, right: 0, top: 0, bottom: 0 } },
                      legend: { show: !1 },
                      xaxis: {
                        labels: { show: !1 },
                        tooltip: { enabled: !1 },
                        axisBorder: { show: !1 },
                        axisTicks: { show: !1 },
                      },
                      chart: { toolbar: { show: !1 }, zoom: { enabled: !1 } },
                      dataLabels: { enabled: !1 },
                    })
                  );
                },
              },
              {
                key: "bar",
                value: function () {
                  return {
                    chart: { stacked: !1, animations: { easing: "swing" } },
                    plotOptions: { bar: { dataLabels: { position: "center" } } },
                    dataLabels: { style: { colors: ["#fff"] }, background: { enabled: !1 } },
                    stroke: { width: 0, lineCap: "round" },
                    fill: { opacity: 0.85 },
                    legend: { markers: { shape: "square", radius: 2, size: 8 } },
                    tooltip: { shared: !1, intersect: !0 },
                    xaxis: {
                      tooltip: { enabled: !1 },
                      tickPlacement: "between",
                      crosshairs: {
                        width: "barWidth",
                        position: "back",
                        fill: { type: "gradient" },
                        dropShadow: { enabled: !1 },
                        stroke: { width: 0 },
                      },
                    },
                  };
                },
              },
              {
                key: "candlestick",
                value: function () {
                  var t = this;
                  return {
                    stroke: { width: 1, colors: ["#333"] },
                    fill: { opacity: 1 },
                    dataLabels: { enabled: !1 },
                    tooltip: {
                      shared: !0,
                      custom: function (e) {
                        var i = e.seriesIndex,
                          s = e.dataPointIndex,
                          a = e.w;
                        return t._getBoxTooltip(a, i, s, ["Open", "High", "", "Low", "Close"], "candlestick");
                      },
                    },
                    states: { active: { filter: { type: "none" } } },
                    xaxis: { crosshairs: { width: 1 } },
                  };
                },
              },
              {
                key: "boxPlot",
                value: function () {
                  var t = this;
                  return {
                    chart: { animations: { dynamicAnimation: { enabled: !1 } } },
                    stroke: { width: 1, colors: ["#24292e"] },
                    dataLabels: { enabled: !1 },
                    tooltip: {
                      shared: !0,
                      custom: function (e) {
                        var i = e.seriesIndex,
                          s = e.dataPointIndex,
                          a = e.w;
                        return t._getBoxTooltip(a, i, s, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
                      },
                    },
                    markers: { size: 5, strokeWidth: 1, strokeColors: "#111" },
                    xaxis: { crosshairs: { width: 1 } },
                  };
                },
              },
              {
                key: "rangeBar",
                value: function () {
                  return {
                    stroke: { width: 0, lineCap: "square" },
                    plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } },
                    dataLabels: {
                      enabled: !1,
                      formatter: function (t, e) {
                        e.ctx;
                        var i = e.seriesIndex,
                          s = e.dataPointIndex,
                          a = e.w,
                          n = function () {
                            var t = a.globals.seriesRangeStart[i][s];
                            return a.globals.seriesRangeEnd[i][s] - t;
                          };
                        return a.globals.comboCharts
                          ? "rangeBar" === a.config.series[i].type || "rangeArea" === a.config.series[i].type
                            ? n()
                            : t
                          : n();
                      },
                      background: { enabled: !1 },
                      style: { colors: ["#fff"] },
                    },
                    tooltip: {
                      shared: !1,
                      followCursor: !0,
                      custom: function (t) {
                        return t.w.config.plotOptions &&
                          t.w.config.plotOptions.bar &&
                          t.w.config.plotOptions.bar.horizontal
                          ? (function (t) {
                              var e = I(t),
                                i = e.color,
                                s = e.seriesName,
                                a = e.ylabel,
                                r = e.startVal,
                                o = e.endVal;
                              return F(n(n({}, t), {}, { color: i, seriesName: s, ylabel: a, start: r, end: o }));
                            })(t)
                          : (function (t) {
                              var e = I(t),
                                i = e.color,
                                s = e.seriesName,
                                a = e.ylabel,
                                r = e.start,
                                o = e.end;
                              return F(n(n({}, t), {}, { color: i, seriesName: s, ylabel: a, start: r, end: o }));
                            })(t);
                      },
                    },
                    xaxis: { tickPlacement: "between", tooltip: { enabled: !1 }, crosshairs: { stroke: { width: 0 } } },
                  };
                },
              },
              {
                key: "area",
                value: function () {
                  return {
                    stroke: {
                      width: 4,
                      fill: {
                        type: "solid",
                        gradient: {
                          inverseColors: !1,
                          shade: "light",
                          type: "vertical",
                          opacityFrom: 0.65,
                          opacityTo: 0.5,
                          stops: [0, 100, 100],
                        },
                      },
                    },
                    fill: {
                      type: "gradient",
                      gradient: {
                        inverseColors: !1,
                        shade: "light",
                        type: "vertical",
                        opacityFrom: 0.65,
                        opacityTo: 0.5,
                        stops: [0, 100, 100],
                      },
                    },
                    markers: { size: 0, hover: { sizeOffset: 6 } },
                    tooltip: { followCursor: !1 },
                  };
                },
              },
              {
                key: "rangeArea",
                value: function () {
                  return {
                    stroke: { curve: "straight", width: 0 },
                    fill: { type: "solid", opacity: 0.6 },
                    markers: { size: 0 },
                    states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } },
                    tooltip: {
                      intersect: !1,
                      shared: !0,
                      followCursor: !0,
                      custom: function (t) {
                        return (function (t) {
                          var e = I(t),
                            i = e.color,
                            s = e.seriesName,
                            a = e.ylabel,
                            r = e.start,
                            o = e.end;
                          return F(n(n({}, t), {}, { color: i, seriesName: s, ylabel: a, start: r, end: o }));
                        })(t);
                      },
                    },
                  };
                },
              },
              {
                key: "brush",
                value: function (t) {
                  return b.extend(t, {
                    chart: { toolbar: { autoSelected: "selection", show: !1 }, zoom: { enabled: !1 } },
                    dataLabels: { enabled: !1 },
                    stroke: { width: 1 },
                    tooltip: { enabled: !1 },
                    xaxis: { tooltip: { enabled: !1 } },
                  });
                },
              },
              {
                key: "stacked100",
                value: function (t) {
                  (t.dataLabels = t.dataLabels || {}), (t.dataLabels.formatter = t.dataLabels.formatter || void 0);
                  var e = t.dataLabels.formatter;
                  return (
                    t.yaxis.forEach(function (e, i) {
                      (t.yaxis[i].min = 0), (t.yaxis[i].max = 100);
                    }),
                    "bar" === t.chart.type &&
                      (t.dataLabels.formatter =
                        e ||
                        function (t) {
                          return "number" == typeof t && t ? t.toFixed(0) + "%" : t;
                        }),
                    t
                  );
                },
              },
              {
                key: "convertCatToNumeric",
                value: function (t) {
                  return (t.xaxis.convertedCatToNumeric = !0), t;
                },
              },
              {
                key: "convertCatToNumericXaxis",
                value: function (t, e, i) {
                  (t.xaxis.type = "numeric"),
                    (t.xaxis.labels = t.xaxis.labels || {}),
                    (t.xaxis.labels.formatter =
                      t.xaxis.labels.formatter ||
                      function (t) {
                        return b.isNumber(t) ? Math.floor(t) : t;
                      });
                  var s = t.xaxis.labels.formatter,
                    a = t.xaxis.categories && t.xaxis.categories.length ? t.xaxis.categories : t.labels;
                  return (
                    i &&
                      i.length &&
                      (a = i.map(function (t) {
                        return Array.isArray(t) ? t : String(t);
                      })),
                    a &&
                      a.length &&
                      (t.xaxis.labels.formatter = function (t) {
                        return b.isNumber(t) ? s(a[Math.floor(t) - 1]) : s(t);
                      }),
                    (t.xaxis.categories = []),
                    (t.labels = []),
                    (t.xaxis.tickAmount = t.xaxis.tickAmount || "dataPoints"),
                    t
                  );
                },
              },
              {
                key: "bubble",
                value: function () {
                  return {
                    dataLabels: { style: { colors: ["#fff"] } },
                    tooltip: { shared: !1, intersect: !0 },
                    xaxis: { crosshairs: { width: 0 } },
                    fill: {
                      type: "solid",
                      gradient: { shade: "light", inverse: !0, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 },
                    },
                  };
                },
              },
              {
                key: "scatter",
                value: function () {
                  return {
                    dataLabels: { enabled: !1 },
                    tooltip: { shared: !1, intersect: !0 },
                    markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } },
                  };
                },
              },
              {
                key: "heatmap",
                value: function () {
                  return {
                    chart: { stacked: !1 },
                    fill: { opacity: 1 },
                    dataLabels: { style: { colors: ["#fff"] } },
                    stroke: { colors: ["#fff"] },
                    tooltip: { followCursor: !0, marker: { show: !1 }, x: { show: !1 } },
                    legend: { position: "top", markers: { shape: "square", size: 10, offsetY: 2 } },
                    grid: { padding: { right: 20 } },
                  };
                },
              },
              {
                key: "treemap",
                value: function () {
                  return {
                    chart: { zoom: { enabled: !1 } },
                    dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } },
                    stroke: { show: !0, width: 2, colors: ["#fff"] },
                    legend: { show: !1 },
                    fill: { gradient: { stops: [0, 100] } },
                    tooltip: { followCursor: !0, x: { show: !1 } },
                    grid: { padding: { left: 0, right: 0 } },
                    xaxis: { crosshairs: { show: !1 }, tooltip: { enabled: !1 } },
                  };
                },
              },
              {
                key: "pie",
                value: function () {
                  return {
                    chart: { toolbar: { show: !1 } },
                    plotOptions: { pie: { donut: { labels: { show: !1 } } } },
                    dataLabels: {
                      formatter: function (t) {
                        return t.toFixed(1) + "%";
                      },
                      style: { colors: ["#fff"] },
                      background: { enabled: !1 },
                      dropShadow: { enabled: !0 },
                    },
                    stroke: { colors: ["#fff"] },
                    fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } },
                    tooltip: { theme: "dark", fillSeriesColor: !0 },
                    legend: { position: "right" },
                  };
                },
              },
              {
                key: "donut",
                value: function () {
                  return {
                    chart: { toolbar: { show: !1 } },
                    dataLabels: {
                      formatter: function (t) {
                        return t.toFixed(1) + "%";
                      },
                      style: { colors: ["#fff"] },
                      background: { enabled: !1 },
                      dropShadow: { enabled: !0 },
                    },
                    stroke: { colors: ["#fff"] },
                    fill: {
                      opacity: 1,
                      gradient: {
                        shade: "light",
                        shadeIntensity: 0.35,
                        stops: [80, 100],
                        opacityFrom: 1,
                        opacityTo: 1,
                      },
                    },
                    tooltip: { theme: "dark", fillSeriesColor: !0 },
                    legend: { position: "right" },
                  };
                },
              },
              {
                key: "polarArea",
                value: function () {
                  return (
                    (this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6),
                    {
                      chart: { toolbar: { show: !1 } },
                      dataLabels: {
                        formatter: function (t) {
                          return t.toFixed(1) + "%";
                        },
                        enabled: !1,
                      },
                      stroke: { show: !0, width: 2 },
                      fill: { opacity: 0.7 },
                      tooltip: { theme: "dark", fillSeriesColor: !0 },
                      legend: { position: "right" },
                    }
                  );
                },
              },
              {
                key: "radar",
                value: function () {
                  return (
                    (this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY
                      ? this.opts.yaxis[0].labels.offsetY
                      : 6),
                    {
                      dataLabels: { enabled: !1, style: { fontSize: "11px" } },
                      stroke: { width: 2 },
                      markers: { size: 3, strokeWidth: 1, strokeOpacity: 1 },
                      fill: { opacity: 0.2 },
                      tooltip: { shared: !1, intersect: !0, followCursor: !0 },
                      grid: { show: !1 },
                      xaxis: {
                        labels: {
                          formatter: function (t) {
                            return t;
                          },
                          style: { colors: ["#a8a8a8"], fontSize: "11px" },
                        },
                        tooltip: { enabled: !1 },
                        crosshairs: { show: !1 },
                      },
                    }
                  );
                },
              },
              {
                key: "radialBar",
                value: function () {
                  return {
                    chart: { animations: { dynamicAnimation: { enabled: !0, speed: 800 } }, toolbar: { show: !1 } },
                    fill: {
                      gradient: {
                        shade: "dark",
                        shadeIntensity: 0.4,
                        inverseColors: !1,
                        type: "diagonal2",
                        opacityFrom: 1,
                        opacityTo: 1,
                        stops: [70, 98, 100],
                      },
                    },
                    legend: { show: !1, position: "right" },
                    tooltip: { enabled: !1, fillSeriesColor: !0 },
                  };
                },
              },
              {
                key: "_getBoxTooltip",
                value: function (t, e, i, s, a) {
                  var n = t.globals.seriesCandleO[e][i],
                    r = t.globals.seriesCandleH[e][i],
                    o = t.globals.seriesCandleM[e][i],
                    l = t.globals.seriesCandleL[e][i],
                    c = t.globals.seriesCandleC[e][i];
                  return t.config.series[e].type && t.config.series[e].type !== a
                    ? '<div class="apexcharts-custom-tooltip">\n          '
                        .concat(t.config.series[e].name ? t.config.series[e].name : "series-" + (e + 1), ": <strong>")
                        .concat(t.globals.series[e][i], "</strong>\n        </div>")
                    : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t.config.chart.type, '">') +
                        "<div>".concat(s[0], ': <span class="value">') +
                        n +
                        "</span></div>" +
                        "<div>".concat(s[1], ': <span class="value">') +
                        r +
                        "</span></div>" +
                        (o ? "<div>".concat(s[2], ': <span class="value">') + o + "</span></div>" : "") +
                        "<div>".concat(s[3], ': <span class="value">') +
                        l +
                        "</span></div>" +
                        "<div>".concat(s[4], ': <span class="value">') +
                        c +
                        "</span></div></div>";
                },
              },
            ]),
            t
          );
        })(),
        z = (function () {
          function t(e) {
            o(this, t), (this.opts = e);
          }
          return (
            c(t, [
              {
                key: "init",
                value: function (t) {
                  var e = t.responsiveOverride,
                    i = this.opts,
                    s = new P(),
                    a = new D(i);
                  (this.chartType = i.chart.type),
                    "histogram" === this.chartType &&
                      ((i.chart.type = "bar"), (i = b.extend({ plotOptions: { bar: { columnWidth: "99.99%" } } }, i))),
                    (i = this.extendYAxis(i)),
                    (i = this.extendAnnotations(i));
                  var n = s.init(),
                    o = {};
                  if (i && "object" === r(i)) {
                    var l = {};
                    (l =
                      -1 !==
                      [
                        "line",
                        "area",
                        "bar",
                        "candlestick",
                        "boxPlot",
                        "rangeBar",
                        "rangeArea",
                        "histogram",
                        "bubble",
                        "scatter",
                        "heatmap",
                        "treemap",
                        "pie",
                        "polarArea",
                        "donut",
                        "radar",
                        "radialBar",
                      ].indexOf(i.chart.type)
                        ? a[i.chart.type]()
                        : a.line()),
                      i.chart.brush && i.chart.brush.enabled && (l = a.brush(l)),
                      i.chart.stacked && "100%" === i.chart.stackType && (i = a.stacked100(i)),
                      this.checkForDarkTheme(window.Apex),
                      this.checkForDarkTheme(i),
                      (i.xaxis = i.xaxis || window.Apex.xaxis || {}),
                      e || (i.xaxis.convertedCatToNumeric = !1),
                      (((i = this.checkForCatToNumericXAxis(this.chartType, l, i)).chart.sparkline &&
                        i.chart.sparkline.enabled) ||
                        (window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled)) &&
                        (l = a.sparkline(l)),
                      (o = b.extend(n, l));
                  }
                  var c = b.extend(o, window.Apex);
                  return (n = b.extend(c, i)), this.handleUserInputErrors(n);
                },
              },
              {
                key: "checkForCatToNumericXAxis",
                value: function (t, e, i) {
                  var s = new D(i),
                    a =
                      ("bar" === t || "boxPlot" === t) &&
                      i.plotOptions &&
                      i.plotOptions.bar &&
                      i.plotOptions.bar.horizontal,
                    n =
                      "pie" === t ||
                      "polarArea" === t ||
                      "donut" === t ||
                      "radar" === t ||
                      "radialBar" === t ||
                      "heatmap" === t,
                    r = "datetime" !== i.xaxis.type && "numeric" !== i.xaxis.type,
                    o = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : e.xaxis && e.xaxis.tickPlacement;
                  return a || n || !r || "between" === o || (i = s.convertCatToNumeric(i)), i;
                },
              },
              {
                key: "extendYAxis",
                value: function (t, e) {
                  var i = new P();
                  (void 0 === t.yaxis || !t.yaxis || (Array.isArray(t.yaxis) && 0 === t.yaxis.length)) &&
                    (t.yaxis = {}),
                    t.yaxis.constructor !== Array &&
                      window.Apex.yaxis &&
                      window.Apex.yaxis.constructor !== Array &&
                      (t.yaxis = b.extend(t.yaxis, window.Apex.yaxis)),
                    t.yaxis.constructor !== Array
                      ? (t.yaxis = [b.extend(i.yAxis, t.yaxis)])
                      : (t.yaxis = b.extendArray(t.yaxis, i.yAxis));
                  var s = !1;
                  t.yaxis.forEach(function (t) {
                    t.logarithmic && (s = !0);
                  });
                  var a = t.series;
                  return (
                    e && !a && (a = e.config.series),
                    s &&
                      a.length !== t.yaxis.length &&
                      a.length &&
                      (t.yaxis = a.map(function (e, s) {
                        if ((e.name || (a[s].name = "series-".concat(s + 1)), t.yaxis[s]))
                          return (t.yaxis[s].seriesName = a[s].name), t.yaxis[s];
                        var n = b.extend(i.yAxis, t.yaxis[0]);
                        return (n.show = !1), n;
                      })),
                    s &&
                      a.length > 1 &&
                      a.length !== t.yaxis.length &&
                      console.warn(
                        "A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both."
                      ),
                    t
                  );
                },
              },
              {
                key: "extendAnnotations",
                value: function (t) {
                  return (
                    void 0 === t.annotations &&
                      ((t.annotations = {}),
                      (t.annotations.yaxis = []),
                      (t.annotations.xaxis = []),
                      (t.annotations.points = [])),
                    (t = this.extendYAxisAnnotations(t)),
                    (t = this.extendXAxisAnnotations(t)),
                    this.extendPointAnnotations(t)
                  );
                },
              },
              {
                key: "extendYAxisAnnotations",
                value: function (t) {
                  var e = new P();
                  return (
                    (t.annotations.yaxis = b.extendArray(
                      void 0 !== t.annotations.yaxis ? t.annotations.yaxis : [],
                      e.yAxisAnnotation
                    )),
                    t
                  );
                },
              },
              {
                key: "extendXAxisAnnotations",
                value: function (t) {
                  var e = new P();
                  return (
                    (t.annotations.xaxis = b.extendArray(
                      void 0 !== t.annotations.xaxis ? t.annotations.xaxis : [],
                      e.xAxisAnnotation
                    )),
                    t
                  );
                },
              },
              {
                key: "extendPointAnnotations",
                value: function (t) {
                  var e = new P();
                  return (
                    (t.annotations.points = b.extendArray(
                      void 0 !== t.annotations.points ? t.annotations.points : [],
                      e.pointAnnotation
                    )),
                    t
                  );
                },
              },
              {
                key: "checkForDarkTheme",
                value: function (t) {
                  t.theme &&
                    "dark" === t.theme.mode &&
                    (t.tooltip || (t.tooltip = {}),
                    "light" !== t.tooltip.theme && (t.tooltip.theme = "dark"),
                    t.chart.foreColor || (t.chart.foreColor = "#f6f7f8"),
                    t.chart.background || (t.chart.background = "#424242"),
                    t.theme.palette || (t.theme.palette = "palette4"));
                },
              },
              {
                key: "handleUserInputErrors",
                value: function (t) {
                  var e = t;
                  if (e.tooltip.shared && e.tooltip.intersect)
                    throw new Error(
                      "tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false."
                    );
                  if ("bar" === e.chart.type && e.plotOptions.bar.horizontal) {
                    if (e.yaxis.length > 1)
                      throw new Error(
                        "Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false"
                      );
                    e.yaxis[0].reversed && (e.yaxis[0].opposite = !0),
                      (e.xaxis.tooltip.enabled = !1),
                      (e.yaxis[0].tooltip.enabled = !1),
                      (e.chart.zoom.enabled = !1);
                  }
                  return (
                    ("bar" !== e.chart.type && "rangeBar" !== e.chart.type) ||
                      (e.tooltip.shared &&
                        "barWidth" === e.xaxis.crosshairs.width &&
                        e.series.length > 1 &&
                        (e.xaxis.crosshairs.width = "tickWidth")),
                    ("candlestick" !== e.chart.type && "boxPlot" !== e.chart.type) ||
                      (e.yaxis[0].reversed &&
                        (console.warn("Reversed y-axis in ".concat(e.chart.type, " chart is not supported.")),
                        (e.yaxis[0].reversed = !1))),
                    e
                  );
                },
              },
            ]),
            t
          );
        })(),
        N = (function () {
          function t() {
            o(this, t);
          }
          return (
            c(t, [
              {
                key: "initGlobalVars",
                value: function (t) {
                  (t.series = []),
                    (t.seriesCandleO = []),
                    (t.seriesCandleH = []),
                    (t.seriesCandleM = []),
                    (t.seriesCandleL = []),
                    (t.seriesCandleC = []),
                    (t.seriesRangeStart = []),
                    (t.seriesRangeEnd = []),
                    (t.seriesRange = []),
                    (t.seriesPercent = []),
                    (t.seriesGoals = []),
                    (t.seriesX = []),
                    (t.seriesZ = []),
                    (t.seriesNames = []),
                    (t.seriesTotals = []),
                    (t.seriesLog = []),
                    (t.seriesColors = []),
                    (t.stackedSeriesTotals = []),
                    (t.seriesXvalues = []),
                    (t.seriesYvalues = []),
                    (t.labels = []),
                    (t.hasGroups = !1),
                    (t.groups = []),
                    (t.categoryLabels = []),
                    (t.timescaleLabels = []),
                    (t.noLabelsProvided = !1),
                    (t.resizeTimer = null),
                    (t.selectionResizeTimer = null),
                    (t.delayedElements = []),
                    (t.pointsArray = []),
                    (t.dataLabelsRects = []),
                    (t.isXNumeric = !1),
                    (t.xaxisLabelsCount = 0),
                    (t.skipLastTimelinelabel = !1),
                    (t.skipFirstTimelinelabel = !1),
                    (t.isDataXYZ = !1),
                    (t.isMultiLineX = !1),
                    (t.isMultipleYAxis = !1),
                    (t.maxY = -Number.MAX_VALUE),
                    (t.minY = Number.MIN_VALUE),
                    (t.minYArr = []),
                    (t.maxYArr = []),
                    (t.maxX = -Number.MAX_VALUE),
                    (t.minX = Number.MAX_VALUE),
                    (t.initialMaxX = -Number.MAX_VALUE),
                    (t.initialMinX = Number.MAX_VALUE),
                    (t.maxDate = 0),
                    (t.minDate = Number.MAX_VALUE),
                    (t.minZ = Number.MAX_VALUE),
                    (t.maxZ = -Number.MAX_VALUE),
                    (t.minXDiff = Number.MAX_VALUE),
                    (t.yAxisScale = []),
                    (t.xAxisScale = null),
                    (t.xAxisTicksPositions = []),
                    (t.yLabelsCoords = []),
                    (t.yTitleCoords = []),
                    (t.barPadForNumericAxis = 0),
                    (t.padHorizontal = 0),
                    (t.xRange = 0),
                    (t.yRange = []),
                    (t.zRange = 0),
                    (t.dataPoints = 0),
                    (t.xTickAmount = 0);
                },
              },
              {
                key: "globalVars",
                value: function (t) {
                  return {
                    chartID: null,
                    cuid: null,
                    events: {
                      beforeMount: [],
                      mounted: [],
                      updated: [],
                      clicked: [],
                      selection: [],
                      dataPointSelection: [],
                      zoomed: [],
                      scrolled: [],
                    },
                    colors: [],
                    clientX: null,
                    clientY: null,
                    fill: { colors: [] },
                    stroke: { colors: [] },
                    dataLabels: { style: { colors: [] } },
                    radarPolygons: { fill: { colors: [] } },
                    markers: { colors: [], size: t.markers.size, largestSize: 0 },
                    animationEnded: !1,
                    isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints,
                    isDirty: !1,
                    isExecCalled: !1,
                    initialConfig: null,
                    initialSeries: [],
                    lastXAxis: [],
                    lastYAxis: [],
                    columnSeries: null,
                    labels: [],
                    timescaleLabels: [],
                    noLabelsProvided: !1,
                    allSeriesCollapsed: !1,
                    collapsedSeries: [],
                    collapsedSeriesIndices: [],
                    ancillaryCollapsedSeries: [],
                    ancillaryCollapsedSeriesIndices: [],
                    risingSeries: [],
                    dataFormatXNumeric: !1,
                    capturedSeriesIndex: -1,
                    capturedDataPointIndex: -1,
                    selectedDataPoints: [],
                    goldenPadding: 35,
                    invalidLogScale: !1,
                    ignoreYAxisIndexes: [],
                    yAxisSameScaleIndices: [],
                    maxValsInArrayIndex: 0,
                    radialSize: 0,
                    selection: void 0,
                    zoomEnabled:
                      "zoom" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.zoom && t.chart.zoom.enabled,
                    panEnabled: "pan" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.pan,
                    selectionEnabled: "selection" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.selection,
                    yaxis: null,
                    mousedown: !1,
                    lastClientPosition: {},
                    visibleXRange: void 0,
                    yValueDecimal: 0,
                    total: 0,
                    SVGNS: "http://www.w3.org/2000/svg",
                    svgWidth: 0,
                    svgHeight: 0,
                    noData: !1,
                    locale: {},
                    dom: {},
                    memory: { methodsToExec: [] },
                    shouldAnimate: !0,
                    skipLastTimelinelabel: !1,
                    skipFirstTimelinelabel: !1,
                    delayedElements: [],
                    axisCharts: !0,
                    isDataXYZ: !1,
                    resized: !1,
                    resizeTimer: null,
                    comboCharts: !1,
                    dataChanged: !1,
                    previousPaths: [],
                    allSeriesHasEqualX: !0,
                    pointsArray: [],
                    dataLabelsRects: [],
                    lastDrawnDataLabelsIndexes: [],
                    hasNullValues: !1,
                    easing: null,
                    zoomed: !1,
                    gridWidth: 0,
                    gridHeight: 0,
                    rotateXLabels: !1,
                    defaultLabels: !1,
                    xLabelFormatter: void 0,
                    yLabelFormatters: [],
                    xaxisTooltipFormatter: void 0,
                    ttKeyFormatter: void 0,
                    ttVal: void 0,
                    ttZFormatter: void 0,
                    LINE_HEIGHT_RATIO: 1.618,
                    xAxisLabelsHeight: 0,
                    xAxisGroupLabelsHeight: 0,
                    xAxisLabelsWidth: 0,
                    yAxisLabelsWidth: 0,
                    scaleX: 1,
                    scaleY: 1,
                    translateX: 0,
                    translateY: 0,
                    translateYAxisX: [],
                    yAxisWidths: [],
                    translateXAxisY: 0,
                    translateXAxisX: 0,
                    tooltip: null,
                  };
                },
              },
              {
                key: "init",
                value: function (t) {
                  var e = this.globalVars(t);
                  return (
                    this.initGlobalVars(e),
                    (e.initialConfig = b.extend({}, t)),
                    (e.initialSeries = b.clone(t.series)),
                    (e.lastXAxis = b.clone(e.initialConfig.xaxis)),
                    (e.lastYAxis = b.clone(e.initialConfig.yaxis)),
                    e
                  );
                },
              },
            ]),
            t
          );
        })(),
        R = (function () {
          function t(e) {
            o(this, t), (this.opts = e);
          }
          return (
            c(t, [
              {
                key: "init",
                value: function () {
                  var t = new z(this.opts).init({ responsiveOverride: !1 });
                  return { config: t, globals: new N().init(t) };
                },
              },
            ]),
            t
          );
        })(),
        _ = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w), (this.opts = null), (this.seriesIndex = 0);
          }
          return (
            c(t, [
              {
                key: "clippedImgArea",
                value: function (t) {
                  var e = this.w,
                    i = e.config,
                    s = parseInt(e.globals.gridWidth, 10),
                    a = parseInt(e.globals.gridHeight, 10),
                    n = s > a ? s : a,
                    r = t.image,
                    o = 0,
                    l = 0;
                  void 0 === t.width && void 0 === t.height
                    ? void 0 !== i.fill.image.width && void 0 !== i.fill.image.height
                      ? ((o = i.fill.image.width + 1), (l = i.fill.image.height))
                      : ((o = n + 1), (l = n))
                    : ((o = t.width), (l = t.height));
                  var c = document.createElementNS(e.globals.SVGNS, "pattern");
                  k.setAttrs(c, {
                    id: t.patternID,
                    patternUnits: t.patternUnits ? t.patternUnits : "userSpaceOnUse",
                    width: o + "px",
                    height: l + "px",
                  });
                  var h = document.createElementNS(e.globals.SVGNS, "image");
                  c.appendChild(h),
                    h.setAttributeNS(window.SVG.xlink, "href", r),
                    k.setAttrs(h, { x: 0, y: 0, preserveAspectRatio: "none", width: o + "px", height: l + "px" }),
                    (h.style.opacity = t.opacity),
                    e.globals.dom.elDefs.node.appendChild(c);
                },
              },
              {
                key: "getSeriesIndex",
                value: function (t) {
                  var e = this.w;
                  return (
                    (("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) &&
                      e.config.plotOptions.bar.distributed) ||
                    "heatmap" === e.config.chart.type ||
                    "treemap" === e.config.chart.type
                      ? (this.seriesIndex = t.seriesNumber)
                      : (this.seriesIndex = t.seriesNumber % e.globals.series.length),
                    this.seriesIndex
                  );
                },
              },
              {
                key: "fillPath",
                value: function (t) {
                  var e = this.w;
                  this.opts = t;
                  var i,
                    s,
                    a,
                    n = this.w.config;
                  this.seriesIndex = this.getSeriesIndex(t);
                  var r = this.getFillColors()[this.seriesIndex];
                  void 0 !== e.globals.seriesColors[this.seriesIndex] && (r = e.globals.seriesColors[this.seriesIndex]),
                    "function" == typeof r &&
                      (r = r({
                        seriesIndex: this.seriesIndex,
                        dataPointIndex: t.dataPointIndex,
                        value: t.value,
                        w: e,
                      }));
                  var o = t.fillType ? t.fillType : this.getFillType(this.seriesIndex),
                    l = Array.isArray(n.fill.opacity) ? n.fill.opacity[this.seriesIndex] : n.fill.opacity;
                  t.color && (r = t.color);
                  var c = r;
                  if (
                    (-1 === r.indexOf("rgb")
                      ? r.length < 9 && (c = b.hexToRgba(r, l))
                      : r.indexOf("rgba") > -1 && (l = b.getOpacityFromRGBA(r)),
                    t.opacity && (l = t.opacity),
                    "pattern" === o &&
                      (s = this.handlePatternFill({
                        fillConfig: t.fillConfig,
                        patternFill: s,
                        fillColor: r,
                        fillOpacity: l,
                        defaultColor: c,
                      })),
                    "gradient" === o &&
                      (a = this.handleGradientFill({
                        fillConfig: t.fillConfig,
                        fillColor: r,
                        fillOpacity: l,
                        i: this.seriesIndex,
                      })),
                    "image" === o)
                  ) {
                    var h = n.fill.image.src,
                      d = t.patternID ? t.patternID : "";
                    this.clippedImgArea({
                      opacity: l,
                      image: Array.isArray(h) ? (t.seriesNumber < h.length ? h[t.seriesNumber] : h[0]) : h,
                      width: t.width ? t.width : void 0,
                      height: t.height ? t.height : void 0,
                      patternUnits: t.patternUnits,
                      patternID: "pattern"
                        .concat(e.globals.cuid)
                        .concat(t.seriesNumber + 1)
                        .concat(d),
                    }),
                      (i = "url(#pattern"
                        .concat(e.globals.cuid)
                        .concat(t.seriesNumber + 1)
                        .concat(d, ")"));
                  } else i = "gradient" === o ? a : "pattern" === o ? s : c;
                  return t.solid && (i = c), i;
                },
              },
              {
                key: "getFillType",
                value: function (t) {
                  var e = this.w;
                  return Array.isArray(e.config.fill.type) ? e.config.fill.type[t] : e.config.fill.type;
                },
              },
              {
                key: "getFillColors",
                value: function () {
                  var t = this.w,
                    e = t.config,
                    i = this.opts,
                    s = [];
                  return (
                    t.globals.comboCharts
                      ? "line" === t.config.series[this.seriesIndex].type
                        ? Array.isArray(t.globals.stroke.colors)
                          ? (s = t.globals.stroke.colors)
                          : s.push(t.globals.stroke.colors)
                        : Array.isArray(t.globals.fill.colors)
                        ? (s = t.globals.fill.colors)
                        : s.push(t.globals.fill.colors)
                      : "line" === e.chart.type
                      ? Array.isArray(t.globals.stroke.colors)
                        ? (s = t.globals.stroke.colors)
                        : s.push(t.globals.stroke.colors)
                      : Array.isArray(t.globals.fill.colors)
                      ? (s = t.globals.fill.colors)
                      : s.push(t.globals.fill.colors),
                    void 0 !== i.fillColors &&
                      ((s = []), Array.isArray(i.fillColors) ? (s = i.fillColors.slice()) : s.push(i.fillColors)),
                    s
                  );
                },
              },
              {
                key: "handlePatternFill",
                value: function (t) {
                  var e = t.fillConfig,
                    i = (t.patternFill, t.fillColor),
                    s = t.fillOpacity,
                    a = t.defaultColor,
                    n = this.w.config.fill;
                  e && (n = e);
                  var r = this.opts,
                    o = new k(this.ctx),
                    l = Array.isArray(n.pattern.strokeWidth)
                      ? n.pattern.strokeWidth[this.seriesIndex]
                      : n.pattern.strokeWidth,
                    c = i;
                  return Array.isArray(n.pattern.style)
                    ? void 0 !== n.pattern.style[r.seriesNumber]
                      ? o.drawPattern(n.pattern.style[r.seriesNumber], n.pattern.width, n.pattern.height, c, l, s)
                      : a
                    : o.drawPattern(n.pattern.style, n.pattern.width, n.pattern.height, c, l, s);
                },
              },
              {
                key: "handleGradientFill",
                value: function (t) {
                  var e = t.fillColor,
                    i = t.fillOpacity,
                    s = t.fillConfig,
                    a = t.i,
                    r = this.w.config.fill;
                  s && (r = n(n({}, r), s));
                  var o,
                    l = this.opts,
                    c = new k(this.ctx),
                    h = new b(),
                    d = r.gradient.type,
                    u = e,
                    p =
                      void 0 === r.gradient.opacityFrom
                        ? i
                        : Array.isArray(r.gradient.opacityFrom)
                        ? r.gradient.opacityFrom[a]
                        : r.gradient.opacityFrom;
                  u.indexOf("rgba") > -1 && (p = b.getOpacityFromRGBA(u));
                  var g =
                    void 0 === r.gradient.opacityTo
                      ? i
                      : Array.isArray(r.gradient.opacityTo)
                      ? r.gradient.opacityTo[a]
                      : r.gradient.opacityTo;
                  if (void 0 === r.gradient.gradientToColors || 0 === r.gradient.gradientToColors.length)
                    o =
                      "dark" === r.gradient.shade
                        ? h.shadeColor(
                            -1 * parseFloat(r.gradient.shadeIntensity),
                            e.indexOf("rgb") > -1 ? b.rgb2hex(e) : e
                          )
                        : h.shadeColor(parseFloat(r.gradient.shadeIntensity), e.indexOf("rgb") > -1 ? b.rgb2hex(e) : e);
                  else if (r.gradient.gradientToColors[l.seriesNumber]) {
                    var f = r.gradient.gradientToColors[l.seriesNumber];
                    (o = f), f.indexOf("rgba") > -1 && (g = b.getOpacityFromRGBA(f));
                  } else o = e;
                  if (
                    (r.gradient.gradientFrom && (u = r.gradient.gradientFrom),
                    r.gradient.gradientTo && (o = r.gradient.gradientTo),
                    r.gradient.inverseColors)
                  ) {
                    var m = u;
                    (u = o), (o = m);
                  }
                  return (
                    u.indexOf("rgb") > -1 && (u = b.rgb2hex(u)),
                    o.indexOf("rgb") > -1 && (o = b.rgb2hex(o)),
                    c.drawGradient(d, u, o, p, g, l.size, r.gradient.stops, r.gradient.colorStops, a)
                  );
                },
              },
            ]),
            t
          );
        })(),
        B = (function () {
          function t(e, i) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "setGlobalMarkerSize",
                value: function () {
                  var t = this.w;
                  if (
                    ((t.globals.markers.size = Array.isArray(t.config.markers.size)
                      ? t.config.markers.size
                      : [t.config.markers.size]),
                    t.globals.markers.size.length > 0)
                  ) {
                    if (t.globals.markers.size.length < t.globals.series.length + 1)
                      for (var e = 0; e <= t.globals.series.length; e++)
                        void 0 === t.globals.markers.size[e] && t.globals.markers.size.push(t.globals.markers.size[0]);
                  } else
                    t.globals.markers.size = t.config.series.map(function (e) {
                      return t.config.markers.size;
                    });
                },
              },
              {
                key: "plotChartMarkers",
                value: function (t, e, i, s) {
                  var a,
                    n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                    r = this.w,
                    o = e,
                    l = t,
                    c = null,
                    h = new k(this.ctx),
                    d = r.config.markers.discrete && r.config.markers.discrete.length;
                  if (
                    ((r.globals.markers.size[e] > 0 || n || d) &&
                      (c = h.group({ class: n || d ? "" : "apexcharts-series-markers" })).attr(
                        "clip-path",
                        "url(#gridRectMarkerMask".concat(r.globals.cuid, ")")
                      ),
                    Array.isArray(l.x))
                  )
                    for (var u = 0; u < l.x.length; u++) {
                      var p = i;
                      1 === i && 0 === u && (p = 0), 1 === i && 1 === u && (p = 1);
                      var g = "apexcharts-marker";
                      ("line" !== r.config.chart.type && "area" !== r.config.chart.type) ||
                        r.globals.comboCharts ||
                        r.config.tooltip.intersect ||
                        (g += " no-pointer-events");
                      var f = Array.isArray(r.config.markers.size)
                        ? r.globals.markers.size[e] > 0
                        : r.config.markers.size > 0;
                      if (f || n || d) {
                        b.isNumber(l.y[u]) ? (g += " w".concat(b.randomId())) : (g = "apexcharts-nullpoint");
                        var m = this.getMarkerConfig({ cssClass: g, seriesIndex: e, dataPointIndex: p });
                        r.config.series[o].data[p] &&
                          (r.config.series[o].data[p].fillColor &&
                            (m.pointFillColor = r.config.series[o].data[p].fillColor),
                          r.config.series[o].data[p].strokeColor &&
                            (m.pointStrokeColor = r.config.series[o].data[p].strokeColor)),
                          s && (m.pSize = s),
                          (a = h.drawMarker(l.x[u], l.y[u], m)).attr("rel", p),
                          a.attr("j", p),
                          a.attr("index", e),
                          a.node.setAttribute("default-marker-size", m.pSize);
                        var v = new w(this.ctx);
                        v.setSelectionFilter(a, e, p), this.addEvents(a), c && c.add(a);
                      } else
                        void 0 === r.globals.pointsArray[e] && (r.globals.pointsArray[e] = []),
                          r.globals.pointsArray[e].push([l.x[u], l.y[u]]);
                    }
                  return c;
                },
              },
              {
                key: "getMarkerConfig",
                value: function (t) {
                  var e = t.cssClass,
                    i = t.seriesIndex,
                    s = t.dataPointIndex,
                    a = void 0 === s ? null : s,
                    n = t.finishRadius,
                    r = void 0 === n ? null : n,
                    o = this.w,
                    l = this.getMarkerStyle(i),
                    c = o.globals.markers.size[i],
                    h = o.config.markers;
                  return (
                    null !== a &&
                      h.discrete.length &&
                      h.discrete.map(function (t) {
                        t.seriesIndex === i &&
                          t.dataPointIndex === a &&
                          ((l.pointStrokeColor = t.strokeColor),
                          (l.pointFillColor = t.fillColor),
                          (c = t.size),
                          (l.pointShape = t.shape));
                      }),
                    {
                      pSize: null === r ? c : r,
                      pRadius: h.radius,
                      width: Array.isArray(h.width) ? h.width[i] : h.width,
                      height: Array.isArray(h.height) ? h.height[i] : h.height,
                      pointStrokeWidth: Array.isArray(h.strokeWidth) ? h.strokeWidth[i] : h.strokeWidth,
                      pointStrokeColor: l.pointStrokeColor,
                      pointFillColor: l.pointFillColor,
                      shape: l.pointShape || (Array.isArray(h.shape) ? h.shape[i] : h.shape),
                      class: e,
                      pointStrokeOpacity: Array.isArray(h.strokeOpacity) ? h.strokeOpacity[i] : h.strokeOpacity,
                      pointStrokeDashArray: Array.isArray(h.strokeDashArray) ? h.strokeDashArray[i] : h.strokeDashArray,
                      pointFillOpacity: Array.isArray(h.fillOpacity) ? h.fillOpacity[i] : h.fillOpacity,
                      seriesIndex: i,
                    }
                  );
                },
              },
              {
                key: "addEvents",
                value: function (t) {
                  var e = this.w,
                    i = new k(this.ctx);
                  t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, t)),
                    t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, t)),
                    t.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, t)),
                    t.node.addEventListener("click", e.config.markers.onClick),
                    t.node.addEventListener("dblclick", e.config.markers.onDblClick),
                    t.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, t), { passive: !0 });
                },
              },
              {
                key: "getMarkerStyle",
                value: function (t) {
                  var e = this.w,
                    i = e.globals.markers.colors,
                    s = e.config.markers.strokeColor || e.config.markers.strokeColors;
                  return { pointStrokeColor: Array.isArray(s) ? s[t] : s, pointFillColor: Array.isArray(i) ? i[t] : i };
                },
              },
            ]),
            t
          );
        })(),
        X = (function () {
          function t(e) {
            o(this, t),
              (this.ctx = e),
              (this.w = e.w),
              (this.initialAnim = this.w.config.chart.animations.enabled),
              (this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled);
          }
          return (
            c(t, [
              {
                key: "draw",
                value: function (t, e, i) {
                  var s = this.w,
                    a = new k(this.ctx),
                    n = i.realIndex,
                    r = i.pointsPos,
                    o = i.zRatio,
                    l = i.elParent,
                    c = a.group({ class: "apexcharts-series-markers apexcharts-series-".concat(s.config.chart.type) });
                  if ((c.attr("clip-path", "url(#gridRectMarkerMask".concat(s.globals.cuid, ")")), Array.isArray(r.x)))
                    for (var h = 0; h < r.x.length; h++) {
                      var d = e + 1,
                        u = !0;
                      0 === e && 0 === h && (d = 0), 0 === e && 1 === h && (d = 1);
                      var p = 0,
                        g = s.globals.markers.size[n];
                      if (o !== 1 / 0) {
                        var f = s.config.plotOptions.bubble;
                        (g = s.globals.seriesZ[n][d]),
                          f.zScaling && (g /= o),
                          f.minBubbleRadius && g < f.minBubbleRadius && (g = f.minBubbleRadius),
                          f.maxBubbleRadius && g > f.maxBubbleRadius && (g = f.maxBubbleRadius);
                      }
                      s.config.chart.animations.enabled || (p = g);
                      var m = r.x[h],
                        v = r.y[h];
                      if (((p = p || 0), (null !== v && void 0 !== s.globals.series[n][d]) || (u = !1), u)) {
                        var x = this.drawPoint(m, v, p, g, n, d, e);
                        c.add(x);
                      }
                      l.add(c);
                    }
                },
              },
              {
                key: "drawPoint",
                value: function (t, e, i, s, a, n, r) {
                  var o = this.w,
                    l = a,
                    c = new y(this.ctx),
                    h = new w(this.ctx),
                    d = new _(this.ctx),
                    u = new B(this.ctx),
                    p = new k(this.ctx),
                    g = u.getMarkerConfig({
                      cssClass: "apexcharts-marker",
                      seriesIndex: l,
                      dataPointIndex: n,
                      finishRadius:
                        "bubble" === o.config.chart.type ||
                        (o.globals.comboCharts && o.config.series[a] && "bubble" === o.config.series[a].type)
                          ? s
                          : null,
                    });
                  s = g.pSize;
                  var f,
                    m = d.fillPath({
                      seriesNumber: a,
                      dataPointIndex: n,
                      color: g.pointFillColor,
                      patternUnits: "objectBoundingBox",
                      value: o.globals.series[a][r],
                    });
                  if (
                    ("circle" === g.shape
                      ? (f = p.drawCircle(i))
                      : ("square" !== g.shape && "rect" !== g.shape) ||
                        (f = p.drawRect(
                          0,
                          0,
                          g.width - g.pointStrokeWidth / 2,
                          g.height - g.pointStrokeWidth / 2,
                          g.pRadius
                        )),
                    o.config.series[l].data[n] &&
                      o.config.series[l].data[n].fillColor &&
                      (m = o.config.series[l].data[n].fillColor),
                    f.attr({
                      x: t - g.width / 2 - g.pointStrokeWidth / 2,
                      y: e - g.height / 2 - g.pointStrokeWidth / 2,
                      cx: t,
                      cy: e,
                      fill: m,
                      "fill-opacity": g.pointFillOpacity,
                      stroke: g.pointStrokeColor,
                      r: s,
                      "stroke-width": g.pointStrokeWidth,
                      "stroke-dasharray": g.pointStrokeDashArray,
                      "stroke-opacity": g.pointStrokeOpacity,
                    }),
                    o.config.chart.dropShadow.enabled)
                  ) {
                    var v = o.config.chart.dropShadow;
                    h.dropShadow(f, v, a);
                  }
                  if (!this.initialAnim || o.globals.dataChanged || o.globals.resized) o.globals.animationEnded = !0;
                  else {
                    var x = o.config.chart.animations.speed;
                    c.animateMarker(
                      f,
                      0,
                      "circle" === g.shape ? s : { width: g.width, height: g.height },
                      x,
                      o.globals.easing,
                      function () {
                        window.setTimeout(function () {
                          c.animationCompleted(f);
                        }, 100);
                      }
                    );
                  }
                  if (o.globals.dataChanged && "circle" === g.shape)
                    if (this.dynamicAnim) {
                      var b,
                        S,
                        C,
                        A,
                        E = o.config.chart.animations.dynamicAnimation.speed;
                      null != (A = o.globals.previousPaths[a] && o.globals.previousPaths[a][r]) &&
                        ((b = A.x), (S = A.y), (C = void 0 !== A.r ? A.r : s));
                      for (var T = 0; T < o.globals.collapsedSeries.length; T++)
                        o.globals.collapsedSeries[T].index === a && ((E = 1), (s = 0));
                      0 === t && 0 === e && (s = 0),
                        c.animateCircle(f, { cx: b, cy: S, r: C }, { cx: t, cy: e, r: s }, E, o.globals.easing);
                    } else f.attr({ r: s });
                  return (
                    f.attr({ rel: n, j: n, index: a, "default-marker-size": s }),
                    h.setSelectionFilter(f, a, n),
                    u.addEvents(f),
                    f.node.classList.add("apexcharts-marker"),
                    f
                  );
                },
              },
              {
                key: "centerTextInBubble",
                value: function (t) {
                  var e = this.w;
                  return { y: (t += parseInt(e.config.dataLabels.style.fontSize, 10) / 4) };
                },
              },
            ]),
            t
          );
        })(),
        H = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "dataLabelsCorrection",
                value: function (t, e, i, s, a, n, r) {
                  var o = this.w,
                    l = !1,
                    c = new k(this.ctx).getTextRects(i, r),
                    h = c.width,
                    d = c.height;
                  e < 0 && (e = 0),
                    e > o.globals.gridHeight + d && (e = o.globals.gridHeight + d / 2),
                    void 0 === o.globals.dataLabelsRects[s] && (o.globals.dataLabelsRects[s] = []),
                    o.globals.dataLabelsRects[s].push({ x: t, y: e, width: h, height: d });
                  var u = o.globals.dataLabelsRects[s].length - 2,
                    p =
                      void 0 !== o.globals.lastDrawnDataLabelsIndexes[s]
                        ? o.globals.lastDrawnDataLabelsIndexes[s][o.globals.lastDrawnDataLabelsIndexes[s].length - 1]
                        : 0;
                  if (void 0 !== o.globals.dataLabelsRects[s][u]) {
                    var g = o.globals.dataLabelsRects[s][p];
                    (t > g.x + g.width + 2 || e > g.y + g.height + 2 || t + h < g.x) && (l = !0);
                  }
                  return (0 === a || n) && (l = !0), { x: t, y: e, textRects: c, drawnextLabel: l };
                },
              },
              {
                key: "drawDataLabel",
                value: function (t) {
                  var e = this,
                    i = t.type,
                    s = t.pos,
                    a = t.i,
                    n = t.j,
                    r = t.isRangeStart,
                    o = t.strokeWidth,
                    l = void 0 === o ? 2 : o,
                    c = this.w,
                    h = new k(this.ctx),
                    d = c.config.dataLabels,
                    u = 0,
                    p = 0,
                    g = n,
                    f = null;
                  if (!d.enabled || !Array.isArray(s.x)) return f;
                  f = h.group({ class: "apexcharts-data-labels" });
                  for (var m = 0; m < s.x.length; m++)
                    if (((u = s.x[m] + d.offsetX), (p = s.y[m] + d.offsetY + l), !isNaN(u))) {
                      1 === n && 0 === m && (g = 0), 1 === n && 1 === m && (g = 1);
                      var v = c.globals.series[a][g];
                      "rangeArea" === i && (v = r ? c.globals.seriesRangeStart[a][g] : c.globals.seriesRangeEnd[a][g]);
                      var x = "",
                        b = function (t) {
                          return c.config.dataLabels.formatter(t, {
                            ctx: e.ctx,
                            seriesIndex: a,
                            dataPointIndex: g,
                            w: c,
                          });
                        };
                      "bubble" === c.config.chart.type
                        ? ((x = b((v = c.globals.seriesZ[a][g]))),
                          (p = s.y[m]),
                          (p = new X(this.ctx).centerTextInBubble(p, a, g).y))
                        : void 0 !== v && (x = b(v)),
                        this.plotDataLabelsText({
                          x: u,
                          y: p,
                          text: x,
                          i: a,
                          j: g,
                          parent: f,
                          offsetCorrection: !0,
                          dataLabelsConfig: c.config.dataLabels,
                        });
                    }
                  return f;
                },
              },
              {
                key: "plotDataLabelsText",
                value: function (t) {
                  var e = this.w,
                    i = new k(this.ctx),
                    s = t.x,
                    a = t.y,
                    n = t.i,
                    r = t.j,
                    o = t.text,
                    l = t.textAnchor,
                    c = t.fontSize,
                    h = t.parent,
                    d = t.dataLabelsConfig,
                    u = t.color,
                    p = t.alwaysDrawDataLabel,
                    g = t.offsetCorrection;
                  if (
                    !(
                      Array.isArray(e.config.dataLabels.enabledOnSeries) &&
                      e.config.dataLabels.enabledOnSeries.indexOf(n) < 0
                    )
                  ) {
                    var f = { x: s, y: a, drawnextLabel: !0, textRects: null };
                    g && (f = this.dataLabelsCorrection(s, a, o, n, r, p, parseInt(d.style.fontSize, 10))),
                      e.globals.zoomed || ((s = f.x), (a = f.y)),
                      f.textRects &&
                        (s < -10 - f.textRects.width || s > e.globals.gridWidth + f.textRects.width + 10) &&
                        (o = "");
                    var m = e.globals.dataLabels.style.colors[n];
                    ((("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) &&
                      e.config.plotOptions.bar.distributed) ||
                      e.config.dataLabels.distributed) &&
                      (m = e.globals.dataLabels.style.colors[r]),
                      "function" == typeof m &&
                        (m = m({ series: e.globals.series, seriesIndex: n, dataPointIndex: r, w: e })),
                      u && (m = u);
                    var v = d.offsetX,
                      x = d.offsetY;
                    if (
                      (("bar" !== e.config.chart.type && "rangeBar" !== e.config.chart.type) || ((v = 0), (x = 0)),
                      f.drawnextLabel)
                    ) {
                      var b = i.drawText({
                        width: 100,
                        height: parseInt(d.style.fontSize, 10),
                        x: s + v,
                        y: a + x,
                        foreColor: m,
                        textAnchor: l || d.textAnchor,
                        text: o,
                        fontSize: c || d.style.fontSize,
                        fontFamily: d.style.fontFamily,
                        fontWeight: d.style.fontWeight || "normal",
                      });
                      if ((b.attr({ class: "apexcharts-datalabel", cx: s, cy: a }), d.dropShadow.enabled)) {
                        var y = d.dropShadow;
                        new w(this.ctx).dropShadow(b, y);
                      }
                      h.add(b),
                        void 0 === e.globals.lastDrawnDataLabelsIndexes[n] &&
                          (e.globals.lastDrawnDataLabelsIndexes[n] = []),
                        e.globals.lastDrawnDataLabelsIndexes[n].push(r);
                    }
                  }
                },
              },
              {
                key: "addBackgroundToDataLabel",
                value: function (t, e) {
                  var i = this.w,
                    s = i.config.dataLabels.background,
                    a = s.padding,
                    n = s.padding / 2,
                    r = e.width,
                    o = e.height,
                    l = new k(this.ctx).drawRect(
                      e.x - a,
                      e.y - n / 2,
                      r + 2 * a,
                      o + n,
                      s.borderRadius,
                      "transparent" === i.config.chart.background ? "#fff" : i.config.chart.background,
                      s.opacity,
                      s.borderWidth,
                      s.borderColor
                    );
                  return s.dropShadow.enabled && new w(this.ctx).dropShadow(l, s.dropShadow), l;
                },
              },
              {
                key: "dataLabelsBackground",
                value: function () {
                  var t = this.w;
                  if ("bubble" !== t.config.chart.type)
                    for (
                      var e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0;
                      i < e.length;
                      i++
                    ) {
                      var s = e[i],
                        a = s.getBBox(),
                        n = null;
                      if ((a.width && a.height && (n = this.addBackgroundToDataLabel(s, a)), n)) {
                        s.parentNode.insertBefore(n.node, s);
                        var r = s.getAttribute("fill");
                        !t.config.chart.animations.enabled || t.globals.resized || t.globals.dataChanged
                          ? n.attr({ fill: r })
                          : n.animate().attr({ fill: r }),
                          s.setAttribute("fill", t.config.dataLabels.background.foreColor);
                      }
                    }
                },
              },
              {
                key: "bringForward",
                value: function () {
                  for (
                    var t = this.w,
                      e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"),
                      i = t.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"),
                      s = 0;
                    s < e.length;
                    s++
                  )
                    i && i.insertBefore(e[s], i.nextSibling);
                },
              },
            ]),
            t
          );
        })(),
        Y = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w), (this.legendInactiveClass = "legend-mouseover-inactive");
          }
          return (
            c(t, [
              {
                key: "getAllSeriesEls",
                value: function () {
                  return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
                },
              },
              {
                key: "getSeriesByName",
                value: function (t) {
                  return this.w.globals.dom.baseEl.querySelector(
                    ".apexcharts-inner .apexcharts-series[seriesName='".concat(b.escapeString(t), "']")
                  );
                },
              },
              {
                key: "isSeriesHidden",
                value: function (t) {
                  var e = this.getSeriesByName(t),
                    i = parseInt(e.getAttribute("data:realIndex"), 10);
                  return { isHidden: e.classList.contains("apexcharts-series-collapsed"), realIndex: i };
                },
              },
              {
                key: "addCollapsedClassToSeries",
                value: function (t, e) {
                  var i = this.w;
                  function s(i) {
                    for (var s = 0; s < i.length; s++)
                      i[s].index === e && t.node.classList.add("apexcharts-series-collapsed");
                  }
                  s(i.globals.collapsedSeries), s(i.globals.ancillaryCollapsedSeries);
                },
              },
              {
                key: "toggleSeries",
                value: function (t) {
                  var e = this.isSeriesHidden(t);
                  return this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, e.isHidden), e.isHidden;
                },
              },
              {
                key: "showSeries",
                value: function (t) {
                  var e = this.isSeriesHidden(t);
                  e.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !0);
                },
              },
              {
                key: "hideSeries",
                value: function (t) {
                  var e = this.isSeriesHidden(t);
                  e.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !1);
                },
              },
              {
                key: "resetSeries",
                value: function () {
                  var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                    e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                    i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                    s = this.w,
                    a = b.clone(s.globals.initialSeries);
                  (s.globals.previousPaths = []),
                    i
                      ? ((s.globals.collapsedSeries = []),
                        (s.globals.ancillaryCollapsedSeries = []),
                        (s.globals.collapsedSeriesIndices = []),
                        (s.globals.ancillaryCollapsedSeriesIndices = []))
                      : (a = this.emptyCollapsedSeries(a)),
                    (s.config.series = a),
                    t &&
                      (e && ((s.globals.zoomed = !1), this.ctx.updateHelpers.revertDefaultAxisMinMax()),
                      this.ctx.updateHelpers._updateSeries(a, s.config.chart.animations.dynamicAnimation.enabled));
                },
              },
              {
                key: "emptyCollapsedSeries",
                value: function (t) {
                  for (var e = this.w, i = 0; i < t.length; i++)
                    e.globals.collapsedSeriesIndices.indexOf(i) > -1 && (t[i].data = []);
                  return t;
                },
              },
              {
                key: "toggleSeriesOnHover",
                value: function (t, e) {
                  var i = this.w;
                  e || (e = t.target);
                  var s = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
                  if ("mousemove" === t.type) {
                    var a = parseInt(e.getAttribute("rel"), 10) - 1,
                      n = null,
                      r = null;
                    i.globals.axisCharts || "radialBar" === i.config.chart.type
                      ? i.globals.axisCharts
                        ? ((n = i.globals.dom.baseEl.querySelector(
                            ".apexcharts-series[data\\:realIndex='".concat(a, "']")
                          )),
                          (r = i.globals.dom.baseEl.querySelector(
                            ".apexcharts-datalabels[data\\:realIndex='".concat(a, "']")
                          )))
                        : (n = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a + 1, "']")))
                      : (n = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a + 1, "'] path")));
                    for (var o = 0; o < s.length; o++) s[o].classList.add(this.legendInactiveClass);
                    null !== n &&
                      (i.globals.axisCharts || n.parentNode.classList.remove(this.legendInactiveClass),
                      n.classList.remove(this.legendInactiveClass),
                      null !== r && r.classList.remove(this.legendInactiveClass));
                  } else if ("mouseout" === t.type)
                    for (var l = 0; l < s.length; l++) s[l].classList.remove(this.legendInactiveClass);
                },
              },
              {
                key: "highlightRangeInSeries",
                value: function (t, e) {
                  var i = this,
                    s = this.w,
                    a = s.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"),
                    n = function (t) {
                      for (var e = 0; e < a.length; e++) a[e].classList[t](i.legendInactiveClass);
                    };
                  if ("mousemove" === t.type) {
                    var r = parseInt(e.getAttribute("rel"), 10) - 1;
                    n("add"),
                      (function (t) {
                        for (var e = 0; e < a.length; e++) {
                          var s = parseInt(a[e].getAttribute("val"), 10);
                          s >= t.from && s <= t.to && a[e].classList.remove(i.legendInactiveClass);
                        }
                      })(s.config.plotOptions.heatmap.colorScale.ranges[r]);
                  } else "mouseout" === t.type && n("remove");
                },
              },
              {
                key: "getActiveConfigSeriesIndex",
                value: function () {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "asc",
                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                    i = this.w,
                    s = 0;
                  if (i.config.series.length > 1)
                    for (
                      var a = i.config.series.map(function (t, s) {
                          return t.data &&
                            t.data.length > 0 &&
                            -1 === i.globals.collapsedSeriesIndices.indexOf(s) &&
                            (!i.globals.comboCharts ||
                              0 === e.length ||
                              (e.length && e.indexOf(i.config.series[s].type) > -1))
                            ? s
                            : -1;
                        }),
                        n = "asc" === t ? 0 : a.length - 1;
                      "asc" === t ? n < a.length : n >= 0;
                      "asc" === t ? n++ : n--
                    )
                      if (-1 !== a[n]) {
                        s = a[n];
                        break;
                      }
                  return s;
                },
              },
              {
                key: "getBarSeriesIndices",
                value: function () {
                  return this.w.globals.comboCharts
                    ? this.w.config.series
                        .map(function (t, e) {
                          return "bar" === t.type || "column" === t.type ? e : -1;
                        })
                        .filter(function (t) {
                          return -1 !== t;
                        })
                    : this.w.config.series.map(function (t, e) {
                        return e;
                      });
                },
              },
              {
                key: "getPreviousPaths",
                value: function () {
                  var t = this.w;
                  function e(e, i, s) {
                    for (
                      var a = e[i].childNodes,
                        n = { type: s, paths: [], realIndex: e[i].getAttribute("data:realIndex") },
                        r = 0;
                      r < a.length;
                      r++
                    )
                      if (a[r].hasAttribute("pathTo")) {
                        var o = a[r].getAttribute("pathTo");
                        n.paths.push({ d: o });
                      }
                    t.globals.previousPaths.push(n);
                  }
                  (t.globals.previousPaths = []),
                    ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function (i) {
                      for (
                        var s,
                          a =
                            ((s = i),
                            t.globals.dom.baseEl.querySelectorAll(
                              ".apexcharts-".concat(s, "-series .apexcharts-series")
                            )),
                          n = 0;
                        n < a.length;
                        n++
                      )
                        e(a, n, i);
                    }),
                    this.handlePrevBubbleScatterPaths("bubble"),
                    this.handlePrevBubbleScatterPaths("scatter");
                  var i = t.globals.dom.baseEl.querySelectorAll(
                    ".apexcharts-".concat(t.config.chart.type, " .apexcharts-series")
                  );
                  if (i.length > 0)
                    for (
                      var s = function (e) {
                          for (
                            var i = t.globals.dom.baseEl.querySelectorAll(
                                ".apexcharts-"
                                  .concat(t.config.chart.type, " .apexcharts-series[data\\:realIndex='")
                                  .concat(e, "'] rect")
                              ),
                              s = [],
                              a = function (t) {
                                var e = function (e) {
                                    return i[t].getAttribute(e);
                                  },
                                  a = {
                                    x: parseFloat(e("x")),
                                    y: parseFloat(e("y")),
                                    width: parseFloat(e("width")),
                                    height: parseFloat(e("height")),
                                  };
                                s.push({ rect: a, color: i[t].getAttribute("color") });
                              },
                              n = 0;
                            n < i.length;
                            n++
                          )
                            a(n);
                          t.globals.previousPaths.push(s);
                        },
                        a = 0;
                      a < i.length;
                      a++
                    )
                      s(a);
                  t.globals.axisCharts || (t.globals.previousPaths = t.globals.series);
                },
              },
              {
                key: "handlePrevBubbleScatterPaths",
                value: function (t) {
                  var e = this.w,
                    i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series"));
                  if (i.length > 0)
                    for (var s = 0; s < i.length; s++) {
                      for (
                        var a = e.globals.dom.baseEl.querySelectorAll(
                            ".apexcharts-"
                              .concat(t, "-series .apexcharts-series[data\\:realIndex='")
                              .concat(s, "'] circle")
                          ),
                          n = [],
                          r = 0;
                        r < a.length;
                        r++
                      )
                        n.push({ x: a[r].getAttribute("cx"), y: a[r].getAttribute("cy"), r: a[r].getAttribute("r") });
                      e.globals.previousPaths.push(n);
                    }
                },
              },
              {
                key: "clearPreviousPaths",
                value: function () {
                  var t = this.w;
                  (t.globals.previousPaths = []), (t.globals.allSeriesCollapsed = !1);
                },
              },
              {
                key: "handleNoData",
                value: function () {
                  var t = this.w,
                    e = t.config.noData,
                    i = new k(this.ctx),
                    s = t.globals.svgWidth / 2,
                    a = t.globals.svgHeight / 2,
                    n = "middle";
                  if (
                    ((t.globals.noData = !0),
                    (t.globals.animationEnded = !0),
                    "left" === e.align
                      ? ((s = 10), (n = "start"))
                      : "right" === e.align && ((s = t.globals.svgWidth - 10), (n = "end")),
                    "top" === e.verticalAlign
                      ? (a = 50)
                      : "bottom" === e.verticalAlign && (a = t.globals.svgHeight - 50),
                    (s += e.offsetX),
                    (a = a + parseInt(e.style.fontSize, 10) + 2 + e.offsetY),
                    void 0 !== e.text && "" !== e.text)
                  ) {
                    var r = i.drawText({
                      x: s,
                      y: a,
                      text: e.text,
                      textAnchor: n,
                      fontSize: e.style.fontSize,
                      fontFamily: e.style.fontFamily,
                      foreColor: e.style.color,
                      opacity: 1,
                      class: "apexcharts-text-nodata",
                    });
                    t.globals.dom.Paper.add(r);
                  }
                },
              },
              {
                key: "setNullSeriesToZeroValues",
                value: function (t) {
                  for (var e = this.w, i = 0; i < t.length; i++)
                    if (0 === t[i].length)
                      for (var s = 0; s < t[e.globals.maxValsInArrayIndex].length; s++) t[i].push(0);
                  return t;
                },
              },
              {
                key: "hasAllSeriesEqualX",
                value: function () {
                  for (var t = !0, e = this.w, i = this.filteredSeriesX(), s = 0; s < i.length - 1; s++)
                    if (i[s][0] !== i[s + 1][0]) {
                      t = !1;
                      break;
                    }
                  return (e.globals.allSeriesHasEqualX = t), t;
                },
              },
              {
                key: "filteredSeriesX",
                value: function () {
                  return this.w.globals.seriesX.map(function (t) {
                    return t.length > 0 ? t : [];
                  });
                },
              },
            ]),
            t
          );
        })(),
        W = (function () {
          function t(e) {
            o(this, t),
              (this.ctx = e),
              (this.w = e.w),
              (this.twoDSeries = []),
              (this.threeDSeries = []),
              (this.twoDSeriesX = []),
              (this.seriesGoals = []),
              (this.coreUtils = new S(this.ctx));
          }
          return (
            c(t, [
              {
                key: "isMultiFormat",
                value: function () {
                  return this.isFormatXY() || this.isFormat2DArray();
                },
              },
              {
                key: "isFormatXY",
                value: function () {
                  var t = this.w.config.series.slice(),
                    e = new Y(this.ctx);
                  if (
                    ((this.activeSeriesIndex = e.getActiveConfigSeriesIndex()),
                    void 0 !== t[this.activeSeriesIndex].data &&
                      t[this.activeSeriesIndex].data.length > 0 &&
                      null !== t[this.activeSeriesIndex].data[0] &&
                      void 0 !== t[this.activeSeriesIndex].data[0].x &&
                      null !== t[this.activeSeriesIndex].data[0])
                  )
                    return !0;
                },
              },
              {
                key: "isFormat2DArray",
                value: function () {
                  var t = this.w.config.series.slice(),
                    e = new Y(this.ctx);
                  if (
                    ((this.activeSeriesIndex = e.getActiveConfigSeriesIndex()),
                    void 0 !== t[this.activeSeriesIndex].data &&
                      t[this.activeSeriesIndex].data.length > 0 &&
                      void 0 !== t[this.activeSeriesIndex].data[0] &&
                      null !== t[this.activeSeriesIndex].data[0] &&
                      t[this.activeSeriesIndex].data[0].constructor === Array)
                  )
                    return !0;
                },
              },
              {
                key: "handleFormat2DArray",
                value: function (t, e) {
                  for (
                    var i = this.w.config,
                      s = this.w.globals,
                      a = "boxPlot" === i.chart.type || "boxPlot" === i.series[e].type,
                      n = 0;
                    n < t[e].data.length;
                    n++
                  )
                    if (
                      (void 0 !== t[e].data[n][1] &&
                        (Array.isArray(t[e].data[n][1]) && 4 === t[e].data[n][1].length && !a
                          ? this.twoDSeries.push(b.parseNumber(t[e].data[n][1][3]))
                          : t[e].data[n].length >= 5
                          ? this.twoDSeries.push(b.parseNumber(t[e].data[n][4]))
                          : this.twoDSeries.push(b.parseNumber(t[e].data[n][1])),
                        (s.dataFormatXNumeric = !0)),
                      "datetime" === i.xaxis.type)
                    ) {
                      var r = new Date(t[e].data[n][0]);
                      (r = new Date(r).getTime()), this.twoDSeriesX.push(r);
                    } else this.twoDSeriesX.push(t[e].data[n][0]);
                  for (var o = 0; o < t[e].data.length; o++)
                    void 0 !== t[e].data[o][2] && (this.threeDSeries.push(t[e].data[o][2]), (s.isDataXYZ = !0));
                },
              },
              {
                key: "handleFormatXY",
                value: function (t, e) {
                  var i = this.w.config,
                    s = this.w.globals,
                    a = new O(this.ctx),
                    n = e;
                  s.collapsedSeriesIndices.indexOf(e) > -1 && (n = this.activeSeriesIndex);
                  for (var r = 0; r < t[e].data.length; r++)
                    void 0 !== t[e].data[r].y &&
                      (Array.isArray(t[e].data[r].y)
                        ? this.twoDSeries.push(b.parseNumber(t[e].data[r].y[t[e].data[r].y.length - 1]))
                        : this.twoDSeries.push(b.parseNumber(t[e].data[r].y))),
                      void 0 !== t[e].data[r].goals && Array.isArray(t[e].data[r].goals)
                        ? (void 0 === this.seriesGoals[e] && (this.seriesGoals[e] = []),
                          this.seriesGoals[e].push(t[e].data[r].goals))
                        : (void 0 === this.seriesGoals[e] && (this.seriesGoals[e] = []),
                          this.seriesGoals[e].push(null));
                  for (var o = 0; o < t[n].data.length; o++) {
                    var l = "string" == typeof t[n].data[o].x,
                      c = Array.isArray(t[n].data[o].x),
                      h = !c && !!a.isValidDate(t[n].data[o].x.toString());
                    if (l || h)
                      if (l || i.xaxis.convertedCatToNumeric) {
                        var d = s.isBarHorizontal && s.isRangeData;
                        "datetime" !== i.xaxis.type || d
                          ? ((this.fallbackToCategory = !0), this.twoDSeriesX.push(t[n].data[o].x))
                          : this.twoDSeriesX.push(a.parseDate(t[n].data[o].x));
                      } else
                        "datetime" === i.xaxis.type
                          ? this.twoDSeriesX.push(a.parseDate(t[n].data[o].x.toString()))
                          : ((s.dataFormatXNumeric = !0),
                            (s.isXNumeric = !0),
                            this.twoDSeriesX.push(parseFloat(t[n].data[o].x)));
                    else
                      c
                        ? ((this.fallbackToCategory = !0), this.twoDSeriesX.push(t[n].data[o].x))
                        : ((s.isXNumeric = !0), (s.dataFormatXNumeric = !0), this.twoDSeriesX.push(t[n].data[o].x));
                  }
                  if (t[e].data[0] && void 0 !== t[e].data[0].z) {
                    for (var u = 0; u < t[e].data.length; u++) this.threeDSeries.push(t[e].data[u].z);
                    s.isDataXYZ = !0;
                  }
                },
              },
              {
                key: "handleRangeData",
                value: function (t, e) {
                  var i = this.w.globals,
                    s = {};
                  return (
                    this.isFormat2DArray()
                      ? (s = this.handleRangeDataFormat("array", t, e))
                      : this.isFormatXY() && (s = this.handleRangeDataFormat("xy", t, e)),
                    i.seriesRangeStart.push(s.start),
                    i.seriesRangeEnd.push(s.end),
                    i.seriesRange.push(s.rangeUniques),
                    i.seriesRange.forEach(function (t, e) {
                      t &&
                        t.forEach(function (t, e) {
                          t.y.forEach(function (e, i) {
                            for (var s = 0; s < t.y.length; s++)
                              if (i !== s) {
                                var a = e.y1,
                                  n = e.y2,
                                  r = t.y[s].y1;
                                a <= t.y[s].y2 &&
                                  r <= n &&
                                  (t.overlaps.indexOf(e.rangeName) < 0 && t.overlaps.push(e.rangeName),
                                  t.overlaps.indexOf(t.y[s].rangeName) < 0 && t.overlaps.push(t.y[s].rangeName));
                              }
                          });
                        });
                    }),
                    s
                  );
                },
              },
              {
                key: "handleCandleStickBoxData",
                value: function (t, e) {
                  var i = this.w.globals,
                    s = {};
                  return (
                    this.isFormat2DArray()
                      ? (s = this.handleCandleStickBoxDataFormat("array", t, e))
                      : this.isFormatXY() && (s = this.handleCandleStickBoxDataFormat("xy", t, e)),
                    (i.seriesCandleO[e] = s.o),
                    (i.seriesCandleH[e] = s.h),
                    (i.seriesCandleM[e] = s.m),
                    (i.seriesCandleL[e] = s.l),
                    (i.seriesCandleC[e] = s.c),
                    s
                  );
                },
              },
              {
                key: "handleRangeDataFormat",
                value: function (t, e, i) {
                  var s = [],
                    a = [],
                    n = e[i].data
                      .filter(function (t, e, i) {
                        return (
                          e ===
                          i.findIndex(function (e) {
                            return e.x === t.x;
                          })
                        );
                      })
                      .map(function (t, e) {
                        return { x: t.x, overlaps: [], y: [] };
                      });
                  if ("array" === t)
                    for (var r = 0; r < e[i].data.length; r++)
                      Array.isArray(e[i].data[r])
                        ? (s.push(e[i].data[r][1][0]), a.push(e[i].data[r][1][1]))
                        : (s.push(e[i].data[r]), a.push(e[i].data[r]));
                  else if ("xy" === t)
                    for (
                      var o = function (t) {
                          var r = Array.isArray(e[i].data[t].y),
                            o = b.randomId(),
                            l = e[i].data[t].x,
                            c = {
                              y1: r ? e[i].data[t].y[0] : e[i].data[t].y,
                              y2: r ? e[i].data[t].y[1] : e[i].data[t].y,
                              rangeName: o,
                            };
                          e[i].data[t].rangeName = o;
                          var h = n.findIndex(function (t) {
                            return t.x === l;
                          });
                          n[h].y.push(c), s.push(c.y1), a.push(c.y2);
                        },
                        l = 0;
                      l < e[i].data.length;
                      l++
                    )
                      o(l);
                  return { start: s, end: a, rangeUniques: n };
                },
              },
              {
                key: "handleCandleStickBoxDataFormat",
                value: function (t, e, i) {
                  var s = this.w,
                    a = "boxPlot" === s.config.chart.type || "boxPlot" === s.config.series[i].type,
                    n = [],
                    r = [],
                    o = [],
                    l = [],
                    c = [];
                  if ("array" === t)
                    if ((a && 6 === e[i].data[0].length) || (!a && 5 === e[i].data[0].length))
                      for (var h = 0; h < e[i].data.length; h++)
                        n.push(e[i].data[h][1]),
                          r.push(e[i].data[h][2]),
                          a
                            ? (o.push(e[i].data[h][3]), l.push(e[i].data[h][4]), c.push(e[i].data[h][5]))
                            : (l.push(e[i].data[h][3]), c.push(e[i].data[h][4]));
                    else
                      for (var d = 0; d < e[i].data.length; d++)
                        Array.isArray(e[i].data[d][1]) &&
                          (n.push(e[i].data[d][1][0]),
                          r.push(e[i].data[d][1][1]),
                          a
                            ? (o.push(e[i].data[d][1][2]), l.push(e[i].data[d][1][3]), c.push(e[i].data[d][1][4]))
                            : (l.push(e[i].data[d][1][2]), c.push(e[i].data[d][1][3])));
                  else if ("xy" === t)
                    for (var u = 0; u < e[i].data.length; u++)
                      Array.isArray(e[i].data[u].y) &&
                        (n.push(e[i].data[u].y[0]),
                        r.push(e[i].data[u].y[1]),
                        a
                          ? (o.push(e[i].data[u].y[2]), l.push(e[i].data[u].y[3]), c.push(e[i].data[u].y[4]))
                          : (l.push(e[i].data[u].y[2]), c.push(e[i].data[u].y[3])));
                  return { o: n, h: r, m: o, l: l, c: c };
                },
              },
              {
                key: "parseDataAxisCharts",
                value: function (t) {
                  var e = this,
                    i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx,
                    s = this.w.config,
                    a = this.w.globals,
                    n = new O(i),
                    r = s.labels.length > 0 ? s.labels.slice() : s.xaxis.categories.slice();
                  (a.isRangeBar = "rangeBar" === s.chart.type && a.isBarHorizontal),
                    (a.hasGroups = "category" === s.xaxis.type && s.xaxis.group.groups.length > 0),
                    a.hasGroups && (a.groups = s.xaxis.group.groups);
                  for (
                    var o = function () {
                        for (var t = 0; t < r.length; t++)
                          if ("string" == typeof r[t]) {
                            if (!n.isValidDate(r[t]))
                              throw new Error(
                                "You have provided invalid Date format. Please provide a valid JavaScript Date"
                              );
                            e.twoDSeriesX.push(n.parseDate(r[t]));
                          } else e.twoDSeriesX.push(r[t]);
                      },
                      l = 0;
                    l < t.length;
                    l++
                  ) {
                    if (
                      ((this.twoDSeries = []), (this.twoDSeriesX = []), (this.threeDSeries = []), void 0 === t[l].data)
                    )
                      return void console.error(
                        "It is a possibility that you may have not included 'data' property in series."
                      );
                    if (
                      (("rangeBar" !== s.chart.type &&
                        "rangeArea" !== s.chart.type &&
                        "rangeBar" !== t[l].type &&
                        "rangeArea" !== t[l].type) ||
                        ((a.isRangeData = !0),
                        a.isComboCharts
                          ? ("rangeBar" !== t[l].type && "rangeArea" !== t[l].type) || this.handleRangeData(t, l)
                          : ("rangeBar" !== s.chart.type && "rangeArea" !== s.chart.type) ||
                            this.handleRangeData(t, l)),
                      this.isMultiFormat())
                    )
                      this.isFormat2DArray()
                        ? this.handleFormat2DArray(t, l)
                        : this.isFormatXY() && this.handleFormatXY(t, l),
                        ("candlestick" !== s.chart.type &&
                          "candlestick" !== t[l].type &&
                          "boxPlot" !== s.chart.type &&
                          "boxPlot" !== t[l].type) ||
                          this.handleCandleStickBoxData(t, l),
                        a.series.push(this.twoDSeries),
                        a.labels.push(this.twoDSeriesX),
                        a.seriesX.push(this.twoDSeriesX),
                        (a.seriesGoals = this.seriesGoals),
                        l !== this.activeSeriesIndex || this.fallbackToCategory || (a.isXNumeric = !0);
                    else {
                      "datetime" === s.xaxis.type
                        ? ((a.isXNumeric = !0), o(), a.seriesX.push(this.twoDSeriesX))
                        : "numeric" === s.xaxis.type &&
                          ((a.isXNumeric = !0),
                          r.length > 0 && ((this.twoDSeriesX = r), a.seriesX.push(this.twoDSeriesX))),
                        a.labels.push(this.twoDSeriesX);
                      var c = t[l].data.map(function (t) {
                        return b.parseNumber(t);
                      });
                      a.series.push(c);
                    }
                    a.seriesZ.push(this.threeDSeries),
                      void 0 !== t[l].name
                        ? a.seriesNames.push(t[l].name)
                        : a.seriesNames.push("series-" + parseInt(l + 1, 10)),
                      void 0 !== t[l].color ? a.seriesColors.push(t[l].color) : a.seriesColors.push(void 0);
                  }
                  return this.w;
                },
              },
              {
                key: "parseDataNonAxisCharts",
                value: function (t) {
                  var e = this.w.globals,
                    i = this.w.config;
                  (e.series = t.slice()), (e.seriesNames = i.labels.slice());
                  for (var s = 0; s < e.series.length; s++)
                    void 0 === e.seriesNames[s] && e.seriesNames.push("series-" + (s + 1));
                  return this.w;
                },
              },
              {
                key: "handleExternalLabelsData",
                value: function (t) {
                  var e = this.w.config,
                    i = this.w.globals;
                  e.xaxis.categories.length > 0
                    ? (i.labels = e.xaxis.categories)
                    : e.labels.length > 0
                    ? (i.labels = e.labels.slice())
                    : this.fallbackToCategory
                    ? ((i.labels = i.labels[0]),
                      i.seriesRange.length &&
                        (i.seriesRange.map(function (t) {
                          t.forEach(function (t) {
                            i.labels.indexOf(t.x) < 0 && t.x && i.labels.push(t.x);
                          });
                        }),
                        (i.labels = i.labels.filter(function (t, e, i) {
                          return i.indexOf(t) === e;
                        }))),
                      e.xaxis.convertedCatToNumeric &&
                        (new D(e).convertCatToNumericXaxis(e, this.ctx, i.seriesX[0]), this._generateExternalLabels(t)))
                    : this._generateExternalLabels(t);
                },
              },
              {
                key: "_generateExternalLabels",
                value: function (t) {
                  var e = this.w.globals,
                    i = this.w.config,
                    s = [];
                  if (e.axisCharts) {
                    if (e.series.length > 0)
                      if (this.isFormatXY())
                        for (
                          var a = i.series.map(function (t, e) {
                              return t.data.filter(function (t, e, i) {
                                return (
                                  i.findIndex(function (e) {
                                    return e.x === t.x;
                                  }) === e
                                );
                              });
                            }),
                            n = a.reduce(function (t, e, i, s) {
                              return s[t].length > e.length ? t : i;
                            }, 0),
                            r = 0;
                          r < a[n].length;
                          r++
                        )
                          s.push(r + 1);
                      else for (var o = 0; o < e.series[e.maxValsInArrayIndex].length; o++) s.push(o + 1);
                    e.seriesX = [];
                    for (var l = 0; l < t.length; l++) e.seriesX.push(s);
                    e.isXNumeric = !0;
                  }
                  if (0 === s.length) {
                    s = e.axisCharts
                      ? []
                      : e.series.map(function (t, e) {
                          return e + 1;
                        });
                    for (var c = 0; c < t.length; c++) e.seriesX.push(s);
                  }
                  (e.labels = s),
                    i.xaxis.convertedCatToNumeric &&
                      (e.categoryLabels = s.map(function (t) {
                        return i.xaxis.labels.formatter(t);
                      })),
                    (e.noLabelsProvided = !0);
                },
              },
              {
                key: "parseData",
                value: function (t) {
                  var e = this.w,
                    i = e.config,
                    s = e.globals;
                  if (
                    (this.excludeCollapsedSeriesInYAxis(),
                    (this.fallbackToCategory = !1),
                    this.ctx.core.resetGlobals(),
                    this.ctx.core.isMultipleY(),
                    s.axisCharts
                      ? (this.parseDataAxisCharts(t), this.coreUtils.getLargestSeries())
                      : this.parseDataNonAxisCharts(t),
                    "bar" === i.chart.type && i.chart.stacked)
                  ) {
                    var a = new Y(this.ctx);
                    s.series = a.setNullSeriesToZeroValues(s.series);
                  }
                  this.coreUtils.getSeriesTotals(),
                    s.axisCharts && (s.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals()),
                    this.coreUtils.getPercentSeries(),
                    s.dataFormatXNumeric ||
                      (s.isXNumeric &&
                        ("numeric" !== i.xaxis.type || 0 !== i.labels.length || 0 !== i.xaxis.categories.length)) ||
                      this.handleExternalLabelsData(t);
                  for (var n = this.coreUtils.getCategoryLabels(s.labels), r = 0; r < n.length; r++)
                    if (Array.isArray(n[r])) {
                      s.isMultiLineX = !0;
                      break;
                    }
                },
              },
              {
                key: "excludeCollapsedSeriesInYAxis",
                value: function () {
                  var t = this,
                    e = this.w;
                  e.globals.ignoreYAxisIndexes = e.globals.collapsedSeries.map(function (i, s) {
                    if (t.w.globals.isMultipleYAxis && !e.config.chart.stacked) return i.index;
                  });
                },
              },
            ]),
            t
          );
        })(),
        $ = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w), (this.tooltipKeyFormat = "dd MMM");
          }
          return (
            c(t, [
              {
                key: "xLabelFormat",
                value: function (t, e, i, s) {
                  var a = this.w;
                  if (
                    "datetime" === a.config.xaxis.type &&
                    void 0 === a.config.xaxis.labels.formatter &&
                    void 0 === a.config.tooltip.x.formatter
                  ) {
                    var n = new O(this.ctx);
                    return n.formatDate(n.getDate(e), a.config.tooltip.x.format);
                  }
                  return t(e, i, s);
                },
              },
              {
                key: "defaultGeneralFormatter",
                value: function (t) {
                  return Array.isArray(t)
                    ? t.map(function (t) {
                        return t;
                      })
                    : t;
                },
              },
              {
                key: "defaultYFormatter",
                value: function (t, e, i) {
                  var s = this.w;
                  return (
                    b.isNumber(t) &&
                      (t =
                        0 !== s.globals.yValueDecimal
                          ? t.toFixed(void 0 !== e.decimalsInFloat ? e.decimalsInFloat : s.globals.yValueDecimal)
                          : s.globals.maxYArr[i] - s.globals.minYArr[i] < 5
                          ? t.toFixed(1)
                          : t.toFixed(0)),
                    t
                  );
                },
              },
              {
                key: "setLabelFormatters",
                value: function () {
                  var t = this,
                    e = this.w;
                  return (
                    (e.globals.xaxisTooltipFormatter = function (e) {
                      return t.defaultGeneralFormatter(e);
                    }),
                    (e.globals.ttKeyFormatter = function (e) {
                      return t.defaultGeneralFormatter(e);
                    }),
                    (e.globals.ttZFormatter = function (t) {
                      return t;
                    }),
                    (e.globals.legendFormatter = function (e) {
                      return t.defaultGeneralFormatter(e);
                    }),
                    void 0 !== e.config.xaxis.labels.formatter
                      ? (e.globals.xLabelFormatter = e.config.xaxis.labels.formatter)
                      : (e.globals.xLabelFormatter = function (t) {
                          if (b.isNumber(t)) {
                            if (!e.config.xaxis.convertedCatToNumeric && "numeric" === e.config.xaxis.type) {
                              if (b.isNumber(e.config.xaxis.decimalsInFloat))
                                return t.toFixed(e.config.xaxis.decimalsInFloat);
                              var i = e.globals.maxX - e.globals.minX;
                              return i > 0 && i < 100 ? t.toFixed(1) : t.toFixed(0);
                            }
                            return e.globals.isBarHorizontal && e.globals.maxY - e.globals.minYArr < 4
                              ? t.toFixed(1)
                              : t.toFixed(0);
                          }
                          return t;
                        }),
                    "function" == typeof e.config.tooltip.x.formatter
                      ? (e.globals.ttKeyFormatter = e.config.tooltip.x.formatter)
                      : (e.globals.ttKeyFormatter = e.globals.xLabelFormatter),
                    "function" == typeof e.config.xaxis.tooltip.formatter &&
                      (e.globals.xaxisTooltipFormatter = e.config.xaxis.tooltip.formatter),
                    (Array.isArray(e.config.tooltip.y) || void 0 !== e.config.tooltip.y.formatter) &&
                      (e.globals.ttVal = e.config.tooltip.y),
                    void 0 !== e.config.tooltip.z.formatter && (e.globals.ttZFormatter = e.config.tooltip.z.formatter),
                    void 0 !== e.config.legend.formatter && (e.globals.legendFormatter = e.config.legend.formatter),
                    e.config.yaxis.forEach(function (i, s) {
                      void 0 !== i.labels.formatter
                        ? (e.globals.yLabelFormatters[s] = i.labels.formatter)
                        : (e.globals.yLabelFormatters[s] = function (a) {
                            return e.globals.xyCharts
                              ? Array.isArray(a)
                                ? a.map(function (e) {
                                    return t.defaultYFormatter(e, i, s);
                                  })
                                : t.defaultYFormatter(a, i, s)
                              : a;
                          });
                    }),
                    e.globals
                  );
                },
              },
              {
                key: "heatmapLabelFormatters",
                value: function () {
                  var t = this.w;
                  if ("heatmap" === t.config.chart.type) {
                    t.globals.yAxisScale[0].result = t.globals.seriesNames.slice();
                    var e = t.globals.seriesNames.reduce(function (t, e) {
                      return t.length > e.length ? t : e;
                    }, 0);
                    (t.globals.yAxisScale[0].niceMax = e), (t.globals.yAxisScale[0].niceMin = e);
                  }
                },
              },
            ]),
            t
          );
        })(),
        V = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "getLabel",
                value: function (t, e, i, s) {
                  var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [],
                    n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px",
                    r = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6],
                    o = this.w,
                    l = void 0 === t[s] ? "" : t[s],
                    c = l,
                    h = o.globals.xLabelFormatter,
                    d = o.config.xaxis.labels.formatter,
                    u = !1,
                    p = new $(this.ctx),
                    g = l;
                  r &&
                    ((c = p.xLabelFormat(h, l, g, { i: s, dateFormatter: new O(this.ctx).formatDate, w: o })),
                    void 0 !== d && (c = d(l, t[s], { i: s, dateFormatter: new O(this.ctx).formatDate, w: o })));
                  var f = function (t) {
                    var i = null;
                    return (
                      e.forEach(function (t) {
                        "month" === t.unit
                          ? (i = "year")
                          : "day" === t.unit
                          ? (i = "month")
                          : "hour" === t.unit
                          ? (i = "day")
                          : "minute" === t.unit && (i = "hour");
                      }),
                      i === t
                    );
                  };
                  e.length > 0
                    ? ((u = f(e[s].unit)), (i = e[s].position), (c = e[s].value))
                    : "datetime" === o.config.xaxis.type && void 0 === d && (c = ""),
                    void 0 === c && (c = ""),
                    (c = Array.isArray(c) ? c : c.toString());
                  var m = new k(this.ctx),
                    v = {};
                  v =
                    o.globals.rotateXLabels && r
                      ? m.getTextRects(
                          c,
                          parseInt(n, 10),
                          null,
                          "rotate(".concat(o.config.xaxis.labels.rotate, " 0 0)"),
                          !1
                        )
                      : m.getTextRects(c, parseInt(n, 10));
                  var x = !o.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
                  return (
                    !Array.isArray(c) &&
                      (0 === c.indexOf("NaN") ||
                        0 === c.toLowerCase().indexOf("invalid") ||
                        c.toLowerCase().indexOf("infinity") >= 0 ||
                        (a.indexOf(c) >= 0 && x)) &&
                      (c = ""),
                    { x: i, text: c, textRect: v, isBold: u }
                  );
                },
              },
              {
                key: "checkLabelBasedOnTickamount",
                value: function (t, e, i) {
                  var s = this.w,
                    a = s.config.xaxis.tickAmount;
                  return (
                    "dataPoints" === a && (a = Math.round(s.globals.gridWidth / 120)),
                    a > i || t % Math.round(i / (a + 1)) == 0 || (e.text = ""),
                    e
                  );
                },
              },
              {
                key: "checkForOverflowingLabels",
                value: function (t, e, i, s, a) {
                  var n = this.w;
                  if (
                    (0 === t && n.globals.skipFirstTimelinelabel && (e.text = ""),
                    t === i - 1 && n.globals.skipLastTimelinelabel && (e.text = ""),
                    n.config.xaxis.labels.hideOverlappingLabels && s.length > 0)
                  ) {
                    var r = a[a.length - 1];
                    e.x <
                      r.textRect.width /
                        (n.globals.rotateXLabels ? Math.abs(n.config.xaxis.labels.rotate) / 12 : 1.01) +
                        r.x && (e.text = "");
                  }
                  return e;
                },
              },
              {
                key: "checkForReversedLabels",
                value: function (t, e) {
                  var i = this.w;
                  return i.config.yaxis[t] && i.config.yaxis[t].reversed && e.reverse(), e;
                },
              },
              {
                key: "isYAxisHidden",
                value: function (t) {
                  var e = this.w,
                    i = new S(this.ctx);
                  return (
                    !e.config.yaxis[t].show ||
                    (!e.config.yaxis[t].showForNullSeries &&
                      i.isSeriesNull(t) &&
                      -1 === e.globals.collapsedSeriesIndices.indexOf(t))
                  );
                },
              },
              {
                key: "getYAxisForeColor",
                value: function (t, e) {
                  var i = this.w;
                  return (
                    Array.isArray(t) &&
                      i.globals.yAxisScale[e] &&
                      this.ctx.theme.pushExtraColors(t, i.globals.yAxisScale[e].result.length, !1),
                    t
                  );
                },
              },
              {
                key: "drawYAxisTicks",
                value: function (t, e, i, s, a, n, r) {
                  var o = this.w,
                    l = new k(this.ctx),
                    c = o.globals.translateY;
                  if (s.show && e > 0) {
                    !0 === o.config.yaxis[a].opposite && (t += s.width);
                    for (var h = e; h >= 0; h--) {
                      var d = c + e / 10 + o.config.yaxis[a].labels.offsetY - 1;
                      o.globals.isBarHorizontal && (d = n * h), "heatmap" === o.config.chart.type && (d += n / 2);
                      var u = l.drawLine(
                        t + i.offsetX - s.width + s.offsetX,
                        d + s.offsetY,
                        t + i.offsetX + s.offsetX,
                        d + s.offsetY,
                        s.color
                      );
                      r.add(u), (c += n);
                    }
                  }
                },
              },
            ]),
            t
          );
        })(),
        j = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "scaleSvgNode",
                value: function (t, e) {
                  var i = parseFloat(t.getAttributeNS(null, "width")),
                    s = parseFloat(t.getAttributeNS(null, "height"));
                  t.setAttributeNS(null, "width", i * e),
                    t.setAttributeNS(null, "height", s * e),
                    t.setAttributeNS(null, "viewBox", "0 0 " + i + " " + s);
                },
              },
              {
                key: "fixSvgStringForIe11",
                value: function (t) {
                  if (!b.isIE11()) return t.replace(/&nbsp;/g, "&#160;");
                  var e = 0,
                    i = t.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function (t) {
                      return 2 == ++e ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : t;
                    });
                  return (i = i.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1");
                },
              },
              {
                key: "getSvgString",
                value: function (t) {
                  null == t && (t = 1);
                  var e = this.w.globals.dom.Paper.svg();
                  if (1 !== t) {
                    var i = this.w.globals.dom.Paper.node.cloneNode(!0);
                    this.scaleSvgNode(i, t), (e = new XMLSerializer().serializeToString(i));
                  }
                  return this.fixSvgStringForIe11(e);
                },
              },
              {
                key: "cleanup",
                value: function () {
                  var t = this.w,
                    e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"),
                    i = t.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"),
                    s = t.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
                  Array.prototype.forEach.call(s, function (t) {
                    t.setAttribute("width", 0);
                  }),
                    e &&
                      e[0] &&
                      (e[0].setAttribute("x", -500), e[0].setAttribute("x1", -500), e[0].setAttribute("x2", -500)),
                    i &&
                      i[0] &&
                      (i[0].setAttribute("y", -100), i[0].setAttribute("y1", -100), i[0].setAttribute("y2", -100));
                },
              },
              {
                key: "svgUrl",
                value: function () {
                  this.cleanup();
                  var t = this.getSvgString(),
                    e = new Blob([t], { type: "image/svg+xml;charset=utf-8" });
                  return URL.createObjectURL(e);
                },
              },
              {
                key: "dataURI",
                value: function (t) {
                  var e = this;
                  return new Promise(function (i) {
                    var s = e.w,
                      a = t ? t.scale || t.width / s.globals.svgWidth : 1;
                    e.cleanup();
                    var n = document.createElement("canvas");
                    (n.width = s.globals.svgWidth * a),
                      (n.height = parseInt(s.globals.dom.elWrap.style.height, 10) * a);
                    var r = "transparent" === s.config.chart.background ? "#fff" : s.config.chart.background,
                      o = n.getContext("2d");
                    (o.fillStyle = r), o.fillRect(0, 0, n.width * a, n.height * a);
                    var l = e.getSvgString(a);
                    if (window.canvg && b.isIE11()) {
                      var c = window.canvg.Canvg.fromString(o, l, { ignoreClear: !0, ignoreDimensions: !0 });
                      c.start();
                      var h = n.msToBlob();
                      c.stop(), i({ blob: h });
                    } else {
                      var d = "data:image/svg+xml," + encodeURIComponent(l),
                        u = new Image();
                      (u.crossOrigin = "anonymous"),
                        (u.onload = function () {
                          if ((o.drawImage(u, 0, 0), n.msToBlob)) {
                            var t = n.msToBlob();
                            i({ blob: t });
                          } else {
                            var e = n.toDataURL("image/png");
                            i({ imgURI: e });
                          }
                        }),
                        (u.src = d);
                    }
                  });
                },
              },
              {
                key: "exportToSVG",
                value: function () {
                  this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg");
                },
              },
              {
                key: "exportToPng",
                value: function () {
                  var t = this;
                  this.dataURI().then(function (e) {
                    var i = e.imgURI,
                      s = e.blob;
                    s
                      ? navigator.msSaveOrOpenBlob(s, t.w.globals.chartID + ".png")
                      : t.triggerDownload(i, t.w.config.chart.toolbar.export.png.filename, ".png");
                  });
                },
              },
              {
                key: "exportToCSV",
                value: function (t) {
                  var e = this,
                    i = t.series,
                    s = t.fileName,
                    a = t.columnDelimiter,
                    n = void 0 === a ? "," : a,
                    r = t.lineDelimiter,
                    o = void 0 === r ? "\n" : r,
                    l = this.w;
                  i || (i = l.config.series);
                  var c = [],
                    h = [],
                    d = "",
                    u = l.globals.series.map(function (t, e) {
                      return -1 === l.globals.collapsedSeriesIndices.indexOf(e) ? t : [];
                    }),
                    p = Math.max.apply(
                      Math,
                      m(
                        i.map(function (t) {
                          return t.data ? t.data.length : 0;
                        })
                      )
                    ),
                    g = new W(this.ctx),
                    f = new V(this.ctx),
                    v = function (t) {
                      var i = "";
                      if (l.globals.axisCharts) {
                        if ("category" === l.config.xaxis.type || l.config.xaxis.convertedCatToNumeric)
                          if (l.globals.isBarHorizontal) {
                            var s = l.globals.yLabelFormatters[0],
                              a = new Y(e.ctx).getActiveConfigSeriesIndex();
                            i = s(l.globals.labels[t], { seriesIndex: a, dataPointIndex: t, w: l });
                          } else i = f.getLabel(l.globals.labels, l.globals.timescaleLabels, 0, t).text;
                        "datetime" === l.config.xaxis.type &&
                          (l.config.xaxis.categories.length
                            ? (i = l.config.xaxis.categories[t])
                            : l.config.labels.length && (i = l.config.labels[t]));
                      } else i = l.config.labels[t];
                      return Array.isArray(i) && (i = i.join(" ")), b.isNumber(i) ? i : i.split(n).join("");
                    };
                  c.push(l.config.chart.toolbar.export.csv.headerCategory),
                    "boxPlot" === l.config.chart.type
                      ? (c.push("minimum"), c.push("q1"), c.push("median"), c.push("q3"), c.push("maximum"))
                      : "candlestick" === l.config.chart.type
                      ? (c.push("open"), c.push("high"), c.push("low"), c.push("close"))
                      : "rangeBar" === l.config.chart.type
                      ? (c.push("minimum"), c.push("maximum"))
                      : i.map(function (t, e) {
                          var i = t.name ? t.name : "series-".concat(e);
                          l.globals.axisCharts &&
                            c.push(i.split(n).join("") ? i.split(n).join("") : "series-".concat(e));
                        }),
                    l.globals.axisCharts || (c.push(l.config.chart.toolbar.export.csv.headerValue), h.push(c.join(n))),
                    i.map(function (t, e) {
                      l.globals.axisCharts
                        ? (function (t, e) {
                            if ((c.length && 0 === e && h.push(c.join(n)), t.data)) {
                              t.data =
                                (t.data.length && t.data) ||
                                m(Array(p)).map(function () {
                                  return "";
                                });
                              for (var s = 0; s < t.data.length; s++) {
                                c = [];
                                var a = v(s);
                                if (
                                  (a ||
                                    (g.isFormatXY()
                                      ? (a = i[e].data[s].x)
                                      : g.isFormat2DArray() && (a = i[e].data[s] ? i[e].data[s][0] : "")),
                                  0 === e)
                                ) {
                                  c.push(
                                    ((o = a),
                                    "datetime" === l.config.xaxis.type && String(o).length >= 10
                                      ? l.config.chart.toolbar.export.csv.dateFormatter(a)
                                      : b.isNumber(a)
                                      ? a
                                      : a.split(n).join(""))
                                  );
                                  for (var r = 0; r < l.globals.series.length; r++)
                                    g.isFormatXY() ? c.push(i[r].data[s].y) : c.push(u[r][s]);
                                }
                                ("candlestick" === l.config.chart.type || (t.type && "candlestick" === t.type)) &&
                                  (c.pop(),
                                  c.push(l.globals.seriesCandleO[e][s]),
                                  c.push(l.globals.seriesCandleH[e][s]),
                                  c.push(l.globals.seriesCandleL[e][s]),
                                  c.push(l.globals.seriesCandleC[e][s])),
                                  ("boxPlot" === l.config.chart.type || (t.type && "boxPlot" === t.type)) &&
                                    (c.pop(),
                                    c.push(l.globals.seriesCandleO[e][s]),
                                    c.push(l.globals.seriesCandleH[e][s]),
                                    c.push(l.globals.seriesCandleM[e][s]),
                                    c.push(l.globals.seriesCandleL[e][s]),
                                    c.push(l.globals.seriesCandleC[e][s])),
                                  "rangeBar" === l.config.chart.type &&
                                    (c.pop(),
                                    c.push(l.globals.seriesRangeStart[e][s]),
                                    c.push(l.globals.seriesRangeEnd[e][s])),
                                  c.length && h.push(c.join(n));
                              }
                            }
                            var o;
                          })(t, e)
                        : ((c = []).push(l.globals.labels[e].split(n).join("")), c.push(u[e]), h.push(c.join(n)));
                    }),
                    (d += h.join(o)),
                    this.triggerDownload(
                      "data:text/csv; charset=utf-8," + encodeURIComponent("\ufeff" + d),
                      s || l.config.chart.toolbar.export.csv.filename,
                      ".csv"
                    );
                },
              },
              {
                key: "triggerDownload",
                value: function (t, e, i) {
                  var s = document.createElement("a");
                  (s.href = t),
                    (s.download = (e || this.w.globals.chartID) + i),
                    document.body.appendChild(s),
                    s.click(),
                    document.body.removeChild(s);
                },
              },
            ]),
            t
          );
        })(),
        G = (function () {
          function t(e, i) {
            o(this, t), (this.ctx = e), (this.elgrid = i), (this.w = e.w);
            var s = this.w;
            (this.axesUtils = new V(e)),
              (this.xaxisLabels = s.globals.labels.slice()),
              s.globals.timescaleLabels.length > 0 &&
                !s.globals.isBarHorizontal &&
                (this.xaxisLabels = s.globals.timescaleLabels.slice()),
              s.config.xaxis.overwriteCategories && (this.xaxisLabels = s.config.xaxis.overwriteCategories),
              (this.drawnLabels = []),
              (this.drawnLabelsRects = []),
              "top" === s.config.xaxis.position ? (this.offY = 0) : (this.offY = s.globals.gridHeight + 1),
              (this.offY = this.offY + s.config.xaxis.axisBorder.offsetY),
              (this.isCategoryBarHorizontal = "bar" === s.config.chart.type && s.config.plotOptions.bar.horizontal),
              (this.xaxisFontSize = s.config.xaxis.labels.style.fontSize),
              (this.xaxisFontFamily = s.config.xaxis.labels.style.fontFamily),
              (this.xaxisForeColors = s.config.xaxis.labels.style.colors),
              (this.xaxisBorderWidth = s.config.xaxis.axisBorder.width),
              this.isCategoryBarHorizontal && (this.xaxisBorderWidth = s.config.yaxis[0].axisBorder.width.toString()),
              this.xaxisBorderWidth.indexOf("%") > -1
                ? (this.xaxisBorderWidth = (s.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10)) / 100)
                : (this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10)),
              (this.xaxisBorderHeight = s.config.xaxis.axisBorder.height),
              (this.yaxis = s.config.yaxis[0]);
          }
          return (
            c(t, [
              {
                key: "drawXaxis",
                value: function () {
                  var t = this.w,
                    e = new k(this.ctx),
                    i = e.group({
                      class: "apexcharts-xaxis",
                      transform: "translate(".concat(t.config.xaxis.offsetX, ", ").concat(t.config.xaxis.offsetY, ")"),
                    }),
                    s = e.group({
                      class: "apexcharts-xaxis-texts-g",
                      transform: "translate("
                        .concat(t.globals.translateXAxisX, ", ")
                        .concat(t.globals.translateXAxisY, ")"),
                    });
                  i.add(s);
                  for (var a = [], n = 0; n < this.xaxisLabels.length; n++) a.push(this.xaxisLabels[n]);
                  if (
                    (this.drawXAxisLabelAndGroup(!0, e, s, a, t.globals.isXNumeric, function (t, e) {
                      return e;
                    }),
                    t.globals.hasGroups)
                  ) {
                    var r = t.globals.groups;
                    a = [];
                    for (var o = 0; o < r.length; o++) a.push(r[o].title);
                    var l = {};
                    t.config.xaxis.group.style &&
                      ((l.xaxisFontSize = t.config.xaxis.group.style.fontSize),
                      (l.xaxisFontFamily = t.config.xaxis.group.style.fontFamily),
                      (l.xaxisForeColors = t.config.xaxis.group.style.colors),
                      (l.fontWeight = t.config.xaxis.group.style.fontWeight),
                      (l.cssClass = t.config.xaxis.group.style.cssClass)),
                      this.drawXAxisLabelAndGroup(
                        !1,
                        e,
                        s,
                        a,
                        !1,
                        function (t, e) {
                          return r[t].cols * e;
                        },
                        l
                      );
                  }
                  if (void 0 !== t.config.xaxis.title.text) {
                    var c = e.group({ class: "apexcharts-xaxis-title" }),
                      h = e.drawText({
                        x: t.globals.gridWidth / 2 + t.config.xaxis.title.offsetX,
                        y:
                          this.offY +
                          parseFloat(this.xaxisFontSize) +
                          ("bottom" === t.config.xaxis.title.position
                            ? t.globals.xAxisLabelsHeight
                            : -t.globals.xAxisLabelsHeight - 10) +
                          t.config.xaxis.title.offsetY,
                        text: t.config.xaxis.title.text,
                        textAnchor: "middle",
                        fontSize: t.config.xaxis.title.style.fontSize,
                        fontFamily: t.config.xaxis.title.style.fontFamily,
                        fontWeight: t.config.xaxis.title.style.fontWeight,
                        foreColor: t.config.xaxis.title.style.color,
                        cssClass: "apexcharts-xaxis-title-text " + t.config.xaxis.title.style.cssClass,
                      });
                    c.add(h), i.add(c);
                  }
                  if (t.config.xaxis.axisBorder.show) {
                    var d = t.globals.barPadForNumericAxis,
                      u = e.drawLine(
                        t.globals.padHorizontal + t.config.xaxis.axisBorder.offsetX - d,
                        this.offY,
                        this.xaxisBorderWidth + d,
                        this.offY,
                        t.config.xaxis.axisBorder.color,
                        0,
                        this.xaxisBorderHeight
                      );
                    this.elgrid && this.elgrid.elGridBorders ? this.elgrid.elGridBorders.add(u) : i.add(u);
                  }
                  return i;
                },
              },
              {
                key: "drawXAxisLabelAndGroup",
                value: function (t, e, i, s, a, n) {
                  var r,
                    o = this,
                    l = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {},
                    c = [],
                    h = [],
                    d = this.w,
                    u = l.xaxisFontSize || this.xaxisFontSize,
                    p = l.xaxisFontFamily || this.xaxisFontFamily,
                    g = l.xaxisForeColors || this.xaxisForeColors,
                    f = l.fontWeight || d.config.xaxis.labels.style.fontWeight,
                    m = l.cssClass || d.config.xaxis.labels.style.cssClass,
                    v = d.globals.padHorizontal,
                    x = s.length,
                    b = "category" === d.config.xaxis.type ? d.globals.dataPoints : x;
                  if ((0 === b && x > b && (b = x), a)) {
                    var y = b > 1 ? b - 1 : b;
                    (r = d.globals.gridWidth / y), (v = v + n(0, r) / 2 + d.config.xaxis.labels.offsetX);
                  } else (r = d.globals.gridWidth / b), (v = v + n(0, r) + d.config.xaxis.labels.offsetX);
                  for (
                    var w = function (a) {
                        var l = v - n(a, r) / 2 + d.config.xaxis.labels.offsetX;
                        0 === a && 1 === x && r / 2 === v && 1 === b && (l = d.globals.gridWidth / 2);
                        var y = o.axesUtils.getLabel(s, d.globals.timescaleLabels, l, a, c, u, t),
                          w = 28;
                        if (
                          (d.globals.rotateXLabels && t && (w = 22),
                          d.config.xaxis.title.text &&
                            "top" === d.config.xaxis.position &&
                            (w += parseFloat(d.config.xaxis.title.style.fontSize) + 2),
                          t ||
                            (w =
                              w +
                              parseFloat(u) +
                              (d.globals.xAxisLabelsHeight - d.globals.xAxisGroupLabelsHeight) +
                              (d.globals.rotateXLabels ? 10 : 0)),
                          (y =
                            void 0 !== d.config.xaxis.tickAmount &&
                            "dataPoints" !== d.config.xaxis.tickAmount &&
                            "datetime" !== d.config.xaxis.type
                              ? o.axesUtils.checkLabelBasedOnTickamount(a, y, x)
                              : o.axesUtils.checkForOverflowingLabels(a, y, x, c, h)),
                          t && y.text && d.globals.xaxisLabelsCount++,
                          d.config.xaxis.labels.show)
                        ) {
                          var k = e.drawText({
                            x: y.x,
                            y:
                              o.offY +
                              d.config.xaxis.labels.offsetY +
                              w -
                              ("top" === d.config.xaxis.position
                                ? d.globals.xAxisHeight + d.config.xaxis.axisTicks.height - 2
                                : 0),
                            text: y.text,
                            textAnchor: "middle",
                            fontWeight: y.isBold ? 600 : f,
                            fontSize: u,
                            fontFamily: p,
                            foreColor: Array.isArray(g)
                              ? t && d.config.xaxis.convertedCatToNumeric
                                ? g[d.globals.minX + a - 1]
                                : g[a]
                              : g,
                            isPlainText: !1,
                            cssClass: (t ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + m,
                          });
                          if (
                            (i.add(k),
                            k.on("click", function (t) {
                              if ("function" == typeof d.config.chart.events.xAxisLabelClick) {
                                var e = Object.assign({}, d, { labelIndex: a });
                                d.config.chart.events.xAxisLabelClick(t, o.ctx, e);
                              }
                            }),
                            t)
                          ) {
                            var S = document.createElementNS(d.globals.SVGNS, "title");
                            (S.textContent = Array.isArray(y.text) ? y.text.join(" ") : y.text),
                              k.node.appendChild(S),
                              "" !== y.text && (c.push(y.text), h.push(y));
                          }
                        }
                        a < x - 1 && (v += n(a + 1, r));
                      },
                      k = 0;
                    k <= x - 1;
                    k++
                  )
                    w(k);
                },
              },
              {
                key: "drawXaxisInversed",
                value: function (t) {
                  var e,
                    i,
                    s = this,
                    a = this.w,
                    n = new k(this.ctx),
                    r = a.config.yaxis[0].opposite ? a.globals.translateYAxisX[t] : 0,
                    o = n.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t }),
                    l = n.group({
                      class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
                      transform: "translate(" + r + ", 0)",
                    });
                  o.add(l);
                  var c = [];
                  if (a.config.yaxis[t].show)
                    for (var h = 0; h < this.xaxisLabels.length; h++) c.push(this.xaxisLabels[h]);
                  (e = a.globals.gridHeight / c.length), (i = -e / 2.2);
                  var d = a.globals.yLabelFormatters[0],
                    u = a.config.yaxis[0].labels;
                  if (u.show)
                    for (
                      var p = function (r) {
                          var o = void 0 === c[r] ? "" : c[r];
                          o = d(o, { seriesIndex: t, dataPointIndex: r, w: a });
                          var h = s.axesUtils.getYAxisForeColor(u.style.colors, t),
                            p = 0;
                          Array.isArray(o) && (p = (o.length / 2) * parseInt(u.style.fontSize, 10));
                          var g = n.drawText({
                            x: u.offsetX - 15,
                            y: i + e + u.offsetY - p,
                            text: o,
                            textAnchor: s.yaxis.opposite ? "start" : "end",
                            foreColor: Array.isArray(h) ? h[r] : h,
                            fontSize: u.style.fontSize,
                            fontFamily: u.style.fontFamily,
                            fontWeight: u.style.fontWeight,
                            isPlainText: !1,
                            cssClass: "apexcharts-yaxis-label " + u.style.cssClass,
                            maxWidth: u.maxWidth,
                          });
                          l.add(g),
                            g.on("click", function (t) {
                              if ("function" == typeof a.config.chart.events.xAxisLabelClick) {
                                var e = Object.assign({}, a, { labelIndex: r });
                                a.config.chart.events.xAxisLabelClick(t, s.ctx, e);
                              }
                            });
                          var f = document.createElementNS(a.globals.SVGNS, "title");
                          if (
                            ((f.textContent = Array.isArray(o) ? o.join(" ") : o),
                            g.node.appendChild(f),
                            0 !== a.config.yaxis[t].labels.rotate)
                          ) {
                            var m = n.rotateAroundCenter(g.node);
                            g.node.setAttribute(
                              "transform",
                              "rotate(".concat(a.config.yaxis[t].labels.rotate, " 0 ").concat(m.y, ")")
                            );
                          }
                          i += e;
                        },
                        g = 0;
                      g <= c.length - 1;
                      g++
                    )
                      p(g);
                  if (void 0 !== a.config.yaxis[0].title.text) {
                    var f = n.group({
                        class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
                        transform: "translate(" + r + ", 0)",
                      }),
                      m = n.drawText({
                        x: a.config.yaxis[0].title.offsetX,
                        y: a.globals.gridHeight / 2 + a.config.yaxis[0].title.offsetY,
                        text: a.config.yaxis[0].title.text,
                        textAnchor: "middle",
                        foreColor: a.config.yaxis[0].title.style.color,
                        fontSize: a.config.yaxis[0].title.style.fontSize,
                        fontWeight: a.config.yaxis[0].title.style.fontWeight,
                        fontFamily: a.config.yaxis[0].title.style.fontFamily,
                        cssClass: "apexcharts-yaxis-title-text " + a.config.yaxis[0].title.style.cssClass,
                      });
                    f.add(m), o.add(f);
                  }
                  var v = 0;
                  this.isCategoryBarHorizontal && a.config.yaxis[0].opposite && (v = a.globals.gridWidth);
                  var x = a.config.xaxis.axisBorder;
                  if (x.show) {
                    var b = n.drawLine(
                      a.globals.padHorizontal + x.offsetX + v,
                      1 + x.offsetY,
                      a.globals.padHorizontal + x.offsetX + v,
                      a.globals.gridHeight + x.offsetY,
                      x.color,
                      0
                    );
                    this.elgrid && this.elgrid.elGridBorders ? this.elgrid.elGridBorders.add(b) : o.add(b);
                  }
                  return (
                    a.config.yaxis[0].axisTicks.show &&
                      this.axesUtils.drawYAxisTicks(
                        v,
                        c.length,
                        a.config.yaxis[0].axisBorder,
                        a.config.yaxis[0].axisTicks,
                        0,
                        e,
                        o
                      ),
                    o
                  );
                },
              },
              {
                key: "drawXaxisTicks",
                value: function (t, e, i) {
                  var s = this.w,
                    a = t;
                  if (!(t < 0 || t - 2 > s.globals.gridWidth)) {
                    var n = this.offY + s.config.xaxis.axisTicks.offsetY;
                    if (
                      ((e = e + n + s.config.xaxis.axisTicks.height),
                      "top" === s.config.xaxis.position && (e = n - s.config.xaxis.axisTicks.height),
                      s.config.xaxis.axisTicks.show)
                    ) {
                      var r = new k(this.ctx).drawLine(
                        t + s.config.xaxis.axisTicks.offsetX,
                        n + s.config.xaxis.offsetY,
                        a + s.config.xaxis.axisTicks.offsetX,
                        e + s.config.xaxis.offsetY,
                        s.config.xaxis.axisTicks.color
                      );
                      i.add(r), r.node.classList.add("apexcharts-xaxis-tick");
                    }
                  }
                },
              },
              {
                key: "getXAxisTicksPositions",
                value: function () {
                  var t = this.w,
                    e = [],
                    i = this.xaxisLabels.length,
                    s = t.globals.padHorizontal;
                  if (t.globals.timescaleLabels.length > 0)
                    for (var a = 0; a < i; a++) (s = this.xaxisLabels[a].position), e.push(s);
                  else
                    for (var n = i, r = 0; r < n; r++) {
                      var o = n;
                      t.globals.isXNumeric && "bar" !== t.config.chart.type && (o -= 1),
                        (s += t.globals.gridWidth / o),
                        e.push(s);
                    }
                  return e;
                },
              },
              {
                key: "xAxisLabelCorrections",
                value: function () {
                  var t = this.w,
                    e = new k(this.ctx),
                    i = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"),
                    s = t.globals.dom.baseEl.querySelectorAll(
                      ".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"
                    ),
                    a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"),
                    n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
                  if (t.globals.rotateXLabels || t.config.xaxis.labels.rotateAlways)
                    for (var r = 0; r < s.length; r++) {
                      var o = e.rotateAroundCenter(s[r]);
                      (o.y = o.y - 1),
                        (o.x = o.x + 1),
                        s[r].setAttribute(
                          "transform",
                          "rotate(".concat(t.config.xaxis.labels.rotate, " ").concat(o.x, " ").concat(o.y, ")")
                        ),
                        s[r].setAttribute("text-anchor", "end"),
                        i.setAttribute("transform", "translate(0, ".concat(-10, ")"));
                      var l = s[r].childNodes;
                      t.config.xaxis.labels.trim &&
                        Array.prototype.forEach.call(l, function (i) {
                          e.placeTextWithEllipsis(
                            i,
                            i.textContent,
                            t.globals.xAxisLabelsHeight - ("bottom" === t.config.legend.position ? 20 : 10)
                          );
                        });
                    }
                  else
                    !(function () {
                      for (var i = t.globals.gridWidth / (t.globals.labels.length + 1), a = 0; a < s.length; a++) {
                        var n = s[a].childNodes;
                        t.config.xaxis.labels.trim &&
                          "datetime" !== t.config.xaxis.type &&
                          Array.prototype.forEach.call(n, function (t) {
                            e.placeTextWithEllipsis(t, t.textContent, i);
                          });
                      }
                    })();
                  if (a.length > 0) {
                    var c = a[a.length - 1].getBBox(),
                      h = a[0].getBBox();
                    c.x < -20 && a[a.length - 1].parentNode.removeChild(a[a.length - 1]),
                      h.x + h.width > t.globals.gridWidth &&
                        !t.globals.isBarHorizontal &&
                        a[0].parentNode.removeChild(a[0]);
                    for (var d = 0; d < n.length; d++)
                      e.placeTextWithEllipsis(
                        n[d],
                        n[d].textContent,
                        t.config.yaxis[0].labels.maxWidth -
                          (t.config.yaxis[0].title.text ? 2 * parseFloat(t.config.yaxis[0].title.style.fontSize) : 0) -
                          15
                      );
                  }
                },
              },
            ]),
            t
          );
        })(),
        U = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
            var i = this.w;
            (this.xaxisLabels = i.globals.labels.slice()),
              (this.axesUtils = new V(e)),
              (this.isRangeBar = i.globals.seriesRange.length),
              i.globals.timescaleLabels.length > 0 && (this.xaxisLabels = i.globals.timescaleLabels.slice());
          }
          return (
            c(t, [
              {
                key: "drawGridArea",
                value: function () {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    e = this.w,
                    i = new k(this.ctx);
                  null === t && (t = i.group({ class: "apexcharts-grid" }));
                  var s = i.drawLine(
                      e.globals.padHorizontal,
                      1,
                      e.globals.padHorizontal,
                      e.globals.gridHeight,
                      "transparent"
                    ),
                    a = i.drawLine(
                      e.globals.padHorizontal,
                      e.globals.gridHeight,
                      e.globals.gridWidth,
                      e.globals.gridHeight,
                      "transparent"
                    );
                  return t.add(a), t.add(s), t;
                },
              },
              {
                key: "drawGrid",
                value: function () {
                  var t = null;
                  return this.w.globals.axisCharts && ((t = this.renderGrid()), this.drawGridArea(t.el)), t;
                },
              },
              {
                key: "createGridMask",
                value: function () {
                  var t = this.w,
                    e = t.globals,
                    i = new k(this.ctx),
                    s = Array.isArray(t.config.stroke.width) ? 0 : t.config.stroke.width;
                  if (Array.isArray(t.config.stroke.width)) {
                    var a = 0;
                    t.config.stroke.width.forEach(function (t) {
                      a = Math.max(a, t);
                    }),
                      (s = a);
                  }
                  (e.dom.elGridRectMask = document.createElementNS(e.SVGNS, "clipPath")),
                    e.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e.cuid)),
                    (e.dom.elGridRectMarkerMask = document.createElementNS(e.SVGNS, "clipPath")),
                    e.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e.cuid)),
                    (e.dom.elForecastMask = document.createElementNS(e.SVGNS, "clipPath")),
                    e.dom.elForecastMask.setAttribute("id", "forecastMask".concat(e.cuid)),
                    (e.dom.elNonForecastMask = document.createElementNS(e.SVGNS, "clipPath")),
                    e.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(e.cuid));
                  var n = t.config.chart.type,
                    r = 0,
                    o = 0;
                  ("bar" === n ||
                    "rangeBar" === n ||
                    "candlestick" === n ||
                    "boxPlot" === n ||
                    t.globals.comboBarCount > 0) &&
                    t.globals.isXNumeric &&
                    !t.globals.isBarHorizontal &&
                    ((r = t.config.grid.padding.left),
                    (o = t.config.grid.padding.right),
                    e.barPadForNumericAxis > r && ((r = e.barPadForNumericAxis), (o = e.barPadForNumericAxis))),
                    (e.dom.elGridRect = i.drawRect(
                      -s / 2 - r - 2,
                      -s / 2,
                      e.gridWidth + s + o + r + 4,
                      e.gridHeight + s,
                      0,
                      "#fff"
                    ));
                  var l = t.globals.markers.largestSize + 1;
                  (e.dom.elGridRectMarker = i.drawRect(
                    2 * -l,
                    2 * -l,
                    e.gridWidth + 4 * l,
                    e.gridHeight + 4 * l,
                    0,
                    "#fff"
                  )),
                    e.dom.elGridRectMask.appendChild(e.dom.elGridRect.node),
                    e.dom.elGridRectMarkerMask.appendChild(e.dom.elGridRectMarker.node);
                  var c = e.dom.baseEl.querySelector("defs");
                  c.appendChild(e.dom.elGridRectMask),
                    c.appendChild(e.dom.elForecastMask),
                    c.appendChild(e.dom.elNonForecastMask),
                    c.appendChild(e.dom.elGridRectMarkerMask);
                },
              },
              {
                key: "_drawGridLines",
                value: function (t) {
                  var e = t.i,
                    i = t.x1,
                    s = t.y1,
                    a = t.x2,
                    n = t.y2,
                    r = t.xCount,
                    o = t.parent,
                    l = this.w;
                  if (
                    !(
                      (0 === e && l.globals.skipFirstTimelinelabel) ||
                      (e === r - 1 && l.globals.skipLastTimelinelabel && !l.config.xaxis.labels.formatter) ||
                      "radar" === l.config.chart.type
                    )
                  ) {
                    l.config.grid.xaxis.lines.show &&
                      this._drawGridLine({ i: e, x1: i, y1: s, x2: a, y2: n, xCount: r, parent: o });
                    var c = 0;
                    if (l.globals.hasGroups && "between" === l.config.xaxis.tickPlacement) {
                      var h = l.globals.groups;
                      if (h) {
                        for (var d = 0, u = 0; d < e && u < h.length; u++) d += h[u].cols;
                        d === e && (c = 0.6 * l.globals.xAxisLabelsHeight);
                      }
                    }
                    new G(this.ctx).drawXaxisTicks(i, c, l.globals.dom.elGraphical);
                  }
                },
              },
              {
                key: "_drawGridLine",
                value: function (t) {
                  var e = t.i,
                    i = t.x1,
                    s = t.y1,
                    a = t.x2,
                    n = t.y2,
                    r = t.xCount,
                    o = t.parent,
                    l = this.w,
                    c = !1,
                    h = o.node.classList.contains("apexcharts-gridlines-horizontal"),
                    d = l.config.grid.strokeDashArray,
                    u = l.globals.barPadForNumericAxis;
                  ((0 === s && 0 === n) || (0 === i && 0 === a)) && (c = !0),
                    s === l.globals.gridHeight && n === l.globals.gridHeight && (c = !0),
                    !l.globals.isBarHorizontal || (0 !== e && e !== r - 1) || (c = !0);
                  var p = new k(this).drawLine(i - (h ? u : 0), s, a + (h ? u : 0), n, l.config.grid.borderColor, d);
                  p.node.classList.add("apexcharts-gridline"), c ? this.elGridBorders.add(p) : o.add(p);
                },
              },
              {
                key: "_drawGridBandRect",
                value: function (t) {
                  var e = t.c,
                    i = t.x1,
                    s = t.y1,
                    a = t.x2,
                    n = t.y2,
                    r = t.type,
                    o = this.w,
                    l = new k(this.ctx),
                    c = o.globals.barPadForNumericAxis;
                  if ("column" !== r || "datetime" !== o.config.xaxis.type) {
                    var h = o.config.grid[r].colors[e],
                      d = l.drawRect(
                        i - ("row" === r ? c : 0),
                        s,
                        a + ("row" === r ? 2 * c : 0),
                        n,
                        0,
                        h,
                        o.config.grid[r].opacity
                      );
                    this.elg.add(d),
                      d.attr("clip-path", "url(#gridRectMask".concat(o.globals.cuid, ")")),
                      d.node.classList.add("apexcharts-grid-".concat(r));
                  }
                },
              },
              {
                key: "_drawXYLines",
                value: function (t) {
                  var e = this,
                    i = t.xCount,
                    s = t.tickAmount,
                    a = this.w;
                  if (a.config.grid.xaxis.lines.show || a.config.xaxis.axisTicks.show) {
                    var n,
                      r = a.globals.padHorizontal,
                      o = a.globals.gridHeight;
                    a.globals.timescaleLabels.length
                      ? (function (t) {
                          for (var s = t.xC, a = t.x1, n = t.y1, r = t.x2, o = t.y2, l = 0; l < s; l++)
                            (a = e.xaxisLabels[l].position),
                              (r = e.xaxisLabels[l].position),
                              e._drawGridLines({ i: l, x1: a, y1: n, x2: r, y2: o, xCount: i, parent: e.elgridLinesV });
                        })({ xC: i, x1: r, y1: 0, x2: n, y2: o })
                      : (a.globals.isXNumeric && (i = a.globals.xAxisScale.result.length),
                        a.config.xaxis.convertedCatToNumeric && (i = a.globals.xaxisLabelsCount),
                        (function (t) {
                          var s = t.xC,
                            n = t.x1,
                            r = t.y1,
                            o = t.x2,
                            l = t.y2;
                          if (
                            void 0 !== a.config.xaxis.tickAmount &&
                            "dataPoints" !== a.config.xaxis.tickAmount &&
                            "on" === a.config.xaxis.tickPlacement
                          )
                            a.globals.dom.baseEl
                              .querySelectorAll(".apexcharts-text.apexcharts-xaxis-label tspan:not(:empty)")
                              .forEach(function (t, s) {
                                var a = t.getBBox();
                                e._drawGridLines({
                                  i: s,
                                  x1: a.x + a.width / 2,
                                  y1: r,
                                  x2: a.x + a.width / 2,
                                  y2: l,
                                  xCount: i,
                                  parent: e.elgridLinesV,
                                });
                              });
                          else
                            for (var c = 0; c < s + (a.globals.isXNumeric ? 0 : 1); c++)
                              0 === c && 1 === s && 1 === a.globals.dataPoints && (o = n = a.globals.gridWidth / 2),
                                e._drawGridLines({
                                  i: c,
                                  x1: n,
                                  y1: r,
                                  x2: o,
                                  y2: l,
                                  xCount: i,
                                  parent: e.elgridLinesV,
                                }),
                                (o = n += a.globals.gridWidth / (a.globals.isXNumeric ? s - 1 : s));
                        })({ xC: i, x1: r, y1: 0, x2: n, y2: o }));
                  }
                  if (a.config.grid.yaxis.lines.show) {
                    var l = 0,
                      c = 0,
                      h = a.globals.gridWidth,
                      d = s + 1;
                    this.isRangeBar && (d = a.globals.labels.length);
                    for (var u = 0; u < d + (this.isRangeBar ? 1 : 0); u++)
                      this._drawGridLine({
                        i: u,
                        xCount: d + (this.isRangeBar ? 1 : 0),
                        x1: 0,
                        y1: l,
                        x2: h,
                        y2: c,
                        parent: this.elgridLinesH,
                      }),
                        (c = l += a.globals.gridHeight / (this.isRangeBar ? d : s));
                  }
                },
              },
              {
                key: "_drawInvertedXYLines",
                value: function (t) {
                  var e = t.xCount,
                    i = this.w;
                  if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show)
                    for (var s, a = i.globals.padHorizontal, n = i.globals.gridHeight, r = 0; r < e + 1; r++)
                      i.config.grid.xaxis.lines.show &&
                        this._drawGridLine({
                          i: r,
                          xCount: e + 1,
                          x1: a,
                          y1: 0,
                          x2: s,
                          y2: n,
                          parent: this.elgridLinesV,
                        }),
                        new G(this.ctx).drawXaxisTicks(a, 0, i.globals.dom.elGraphical),
                        (s = a = a + i.globals.gridWidth / e + 0.3);
                  if (i.config.grid.yaxis.lines.show)
                    for (var o = 0, l = 0, c = i.globals.gridWidth, h = 0; h < i.globals.dataPoints + 1; h++)
                      this._drawGridLine({
                        i: h,
                        xCount: i.globals.dataPoints + 1,
                        x1: 0,
                        y1: o,
                        x2: c,
                        y2: l,
                        parent: this.elgridLinesH,
                      }),
                        (l = o += i.globals.gridHeight / i.globals.dataPoints);
                },
              },
              {
                key: "renderGrid",
                value: function () {
                  var t = this.w,
                    e = new k(this.ctx);
                  (this.elg = e.group({ class: "apexcharts-grid" })),
                    (this.elgridLinesH = e.group({ class: "apexcharts-gridlines-horizontal" })),
                    (this.elgridLinesV = e.group({ class: "apexcharts-gridlines-vertical" })),
                    (this.elGridBorders = e.group({ class: "apexcharts-grid-borders" })),
                    this.elg.add(this.elgridLinesH),
                    this.elg.add(this.elgridLinesV),
                    t.config.grid.show ||
                      (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
                  for (
                    var i, s = t.globals.yAxisScale.length ? t.globals.yAxisScale[0].result.length - 1 : 5, a = 0;
                    a < t.globals.series.length &&
                    (void 0 !== t.globals.yAxisScale[a] && (s = t.globals.yAxisScale[a].result.length - 1), !(s > 2));
                    a++
                  );
                  return (
                    !t.globals.isBarHorizontal || this.isRangeBar
                      ? ((i = this.xaxisLabels.length),
                        this.isRangeBar &&
                          ((s = t.globals.labels.length),
                          t.config.xaxis.tickAmount &&
                            t.config.xaxis.labels.formatter &&
                            (i = t.config.xaxis.tickAmount)),
                        this._drawXYLines({ xCount: i, tickAmount: s }))
                      : ((i = s), (s = t.globals.xTickAmount), this._drawInvertedXYLines({ xCount: i, tickAmount: s })),
                    this.drawGridBands(i, s),
                    { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: t.globals.gridWidth / i }
                  );
                },
              },
              {
                key: "drawGridBands",
                value: function (t, e) {
                  var i = this.w;
                  if (void 0 !== i.config.grid.row.colors && i.config.grid.row.colors.length > 0)
                    for (
                      var s = 0, a = i.globals.gridHeight / e, n = i.globals.gridWidth, r = 0, o = 0;
                      r < e;
                      r++, o++
                    )
                      o >= i.config.grid.row.colors.length && (o = 0),
                        this._drawGridBandRect({ c: o, x1: 0, y1: s, x2: n, y2: a, type: "row" }),
                        (s += i.globals.gridHeight / e);
                  if (void 0 !== i.config.grid.column.colors && i.config.grid.column.colors.length > 0)
                    for (
                      var l =
                          i.globals.isBarHorizontal ||
                          ("category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric)
                            ? t
                            : t - 1,
                        c = i.globals.padHorizontal,
                        h = i.globals.padHorizontal + i.globals.gridWidth / l,
                        d = i.globals.gridHeight,
                        u = 0,
                        p = 0;
                      u < t;
                      u++, p++
                    )
                      p >= i.config.grid.column.colors.length && (p = 0),
                        this._drawGridBandRect({ c: p, x1: c, y1: 0, x2: h, y2: d, type: "column" }),
                        (c += i.globals.gridWidth / l);
                },
              },
            ]),
            t
          );
        })(),
        q = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "niceScale",
                value: function (t, e) {
                  var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
                    s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                    a = arguments.length > 4 ? arguments[4] : void 0,
                    n = this.w,
                    r = Math.abs(e - t);
                  if (
                    ("dataPoints" === (i = this._adjustTicksForSmallRange(i, s, r)) && (i = n.globals.dataPoints - 1),
                    (t === Number.MIN_VALUE && 0 === e) ||
                      (!b.isNumber(t) && !b.isNumber(e)) ||
                      (t === Number.MIN_VALUE && e === -Number.MAX_VALUE))
                  ) {
                    (t = 0), (e = i);
                    var o = this.linearScale(t, e, i);
                    return o;
                  }
                  t > e
                    ? (console.warn("axis.min cannot be greater than axis.max"), (e = t + 0.1))
                    : t === e && ((t = 0 === t ? 0 : t - 0.5), (e = 0 === e ? 2 : e + 0.5));
                  var l = [];
                  r < 1 &&
                    a &&
                    ("candlestick" === n.config.chart.type ||
                      "candlestick" === n.config.series[s].type ||
                      "boxPlot" === n.config.chart.type ||
                      "boxPlot" === n.config.series[s].type ||
                      n.globals.isRangeData) &&
                    (e *= 1.01);
                  var c = i + 1;
                  c < 2 ? (c = 2) : c > 2 && (c -= 2);
                  var h = r / c,
                    d = Math.floor(b.log10(h)),
                    u = Math.pow(10, d),
                    p = Math.round(h / u);
                  p < 1 && (p = 1);
                  var g = p * u,
                    f = g * Math.floor(t / g),
                    m = g * Math.ceil(e / g),
                    v = f;
                  if (a && r > 2) {
                    for (; l.push(v), !((v += g) > m); );
                    return { result: l, niceMin: l[0], niceMax: l[l.length - 1] };
                  }
                  var x = t;
                  (l = []).push(x);
                  for (var y = Math.abs(e - t) / i, w = 0; w <= i; w++) (x += y), l.push(x);
                  return l[l.length - 2] >= e && l.pop(), { result: l, niceMin: l[0], niceMax: l[l.length - 1] };
                },
              },
              {
                key: "linearScale",
                value: function (t, e) {
                  var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
                    s = arguments.length > 3 ? arguments[3] : void 0,
                    a = Math.abs(e - t);
                  "dataPoints" === (i = this._adjustTicksForSmallRange(i, s, a)) && (i = this.w.globals.dataPoints - 1);
                  var n = a / i;
                  i === Number.MAX_VALUE && ((i = 10), (n = 1));
                  for (var r = [], o = t; i >= 0; ) r.push(o), (o += n), (i -= 1);
                  return { result: r, niceMin: r[0], niceMax: r[r.length - 1] };
                },
              },
              {
                key: "logarithmicScaleNice",
                value: function (t, e, i) {
                  e <= 0 && (e = Math.max(t, i)), t <= 0 && (t = Math.min(e, i));
                  for (
                    var s = [], a = Math.ceil(Math.log(e) / Math.log(i) + 1), n = Math.floor(Math.log(t) / Math.log(i));
                    n < a;
                    n++
                  )
                    s.push(Math.pow(i, n));
                  return { result: s, niceMin: s[0], niceMax: s[s.length - 1] };
                },
              },
              {
                key: "logarithmicScale",
                value: function (t, e, i) {
                  e <= 0 && (e = Math.max(t, i)), t <= 0 && (t = Math.min(e, i));
                  for (
                    var s = [],
                      a = Math.log(e) / Math.log(i),
                      n = Math.log(t) / Math.log(i),
                      r = a - n,
                      o = Math.round(r),
                      l = r / o,
                      c = 0,
                      h = n;
                    c < o;
                    c++, h += l
                  )
                    s.push(Math.pow(i, h));
                  return s.push(Math.pow(i, a)), { result: s, niceMin: t, niceMax: e };
                },
              },
              {
                key: "_adjustTicksForSmallRange",
                value: function (t, e, i) {
                  var s = t;
                  if (
                    void 0 !== e &&
                    this.w.config.yaxis[e].labels.formatter &&
                    void 0 === this.w.config.yaxis[e].tickAmount
                  ) {
                    var a = this.w.config.yaxis[e].labels.formatter(1);
                    b.isNumber(Number(a)) && !b.isFloat(a) && (s = Math.ceil(i));
                  }
                  return s < t ? s : t;
                },
              },
              {
                key: "setYScaleForIndex",
                value: function (t, e, i) {
                  var s = this.w.globals,
                    a = this.w.config,
                    n = s.isBarHorizontal ? a.xaxis : a.yaxis[t];
                  void 0 === s.yAxisScale[t] && (s.yAxisScale[t] = []);
                  var r = Math.abs(i - e);
                  if ((n.logarithmic && r <= 5 && (s.invalidLogScale = !0), n.logarithmic && r > 5))
                    (s.allSeriesCollapsed = !1),
                      (s.yAxisScale[t] = this.logarithmicScale(e, i, n.logBase)),
                      (s.yAxisScale[t] = n.forceNiceScale
                        ? this.logarithmicScaleNice(e, i, n.logBase)
                        : this.logarithmicScale(e, i, n.logBase));
                  else if (i !== -Number.MAX_VALUE && b.isNumber(i))
                    if (((s.allSeriesCollapsed = !1), (void 0 === n.min && void 0 === n.max) || n.forceNiceScale)) {
                      var o = (void 0 === a.yaxis[t].max && void 0 === a.yaxis[t].min) || a.yaxis[t].forceNiceScale;
                      s.yAxisScale[t] = this.niceScale(
                        e,
                        i,
                        n.tickAmount ? n.tickAmount : r < 5 && r > 1 ? r + 1 : 5,
                        t,
                        o
                      );
                    } else s.yAxisScale[t] = this.linearScale(e, i, n.tickAmount, t);
                  else s.yAxisScale[t] = this.linearScale(0, 5, 5);
                },
              },
              {
                key: "setXScale",
                value: function (t, e) {
                  var i = this.w,
                    s = i.globals,
                    a = i.config.xaxis,
                    n = Math.abs(e - t);
                  return (
                    e !== -Number.MAX_VALUE && b.isNumber(e)
                      ? (s.xAxisScale = this.linearScale(
                          t,
                          e,
                          a.tickAmount ? a.tickAmount : n < 5 && n > 1 ? n + 1 : 5,
                          0
                        ))
                      : (s.xAxisScale = this.linearScale(0, 5, 5)),
                    s.xAxisScale
                  );
                },
              },
              {
                key: "setMultipleYScales",
                value: function () {
                  var t = this,
                    e = this.w.globals,
                    i = this.w.config,
                    s = e.minYArr.concat([]),
                    a = e.maxYArr.concat([]),
                    n = [];
                  i.yaxis.forEach(function (e, r) {
                    var o = r;
                    i.series.forEach(function (t, i) {
                      t.name === e.seriesName &&
                        ((o = i),
                        r !== i ? n.push({ index: i, similarIndex: r, alreadyExists: !0 }) : n.push({ index: i }));
                    });
                    var l = s[o],
                      c = a[o];
                    t.setYScaleForIndex(r, l, c);
                  }),
                    this.sameScaleInMultipleAxes(s, a, n);
                },
              },
              {
                key: "sameScaleInMultipleAxes",
                value: function (t, e, i) {
                  var s = this,
                    a = this.w.config,
                    n = this.w.globals,
                    r = [];
                  i.forEach(function (t) {
                    t.alreadyExists &&
                      (void 0 === r[t.index] && (r[t.index] = []),
                      r[t.index].push(t.index),
                      r[t.index].push(t.similarIndex));
                  }),
                    (n.yAxisSameScaleIndices = r),
                    r.forEach(function (t, e) {
                      r.forEach(function (i, s) {
                        var a, n;
                        e !== s &&
                          ((a = t),
                          (n = i),
                          a.filter(function (t) {
                            return -1 !== n.indexOf(t);
                          })).length > 0 &&
                          (r[e] = r[e].concat(r[s]));
                      });
                    });
                  var o = r
                    .map(function (t) {
                      return t.filter(function (e, i) {
                        return t.indexOf(e) === i;
                      });
                    })
                    .map(function (t) {
                      return t.sort();
                    });
                  r = r.filter(function (t) {
                    return !!t;
                  });
                  var l = o.slice(),
                    c = l.map(function (t) {
                      return JSON.stringify(t);
                    });
                  l = l.filter(function (t, e) {
                    return c.indexOf(JSON.stringify(t)) === e;
                  });
                  var h = [],
                    d = [];
                  t.forEach(function (t, i) {
                    l.forEach(function (s, a) {
                      s.indexOf(i) > -1 &&
                        (void 0 === h[a] && ((h[a] = []), (d[a] = [])),
                        h[a].push({ key: i, value: t }),
                        d[a].push({ key: i, value: e[i] }));
                    });
                  });
                  var u = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, Number.MIN_VALUE),
                    p = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
                  h.forEach(function (t, e) {
                    t.forEach(function (t, i) {
                      u[e] = Math.min(t.value, u[e]);
                    });
                  }),
                    d.forEach(function (t, e) {
                      t.forEach(function (t, i) {
                        p[e] = Math.max(t.value, p[e]);
                      });
                    }),
                    t.forEach(function (t, e) {
                      d.forEach(function (t, i) {
                        var r = u[i],
                          o = p[i];
                        a.chart.stacked &&
                          ((o = 0),
                          t.forEach(function (t, e) {
                            t.value !== -Number.MAX_VALUE && (o += t.value),
                              r !== Number.MIN_VALUE && (r += h[i][e].value);
                          })),
                          t.forEach(function (i, l) {
                            t[l].key === e &&
                              (void 0 !== a.yaxis[e].min &&
                                (r = "function" == typeof a.yaxis[e].min ? a.yaxis[e].min(n.minY) : a.yaxis[e].min),
                              void 0 !== a.yaxis[e].max &&
                                (o = "function" == typeof a.yaxis[e].max ? a.yaxis[e].max(n.maxY) : a.yaxis[e].max),
                              s.setYScaleForIndex(e, r, o));
                          });
                      });
                    });
                },
              },
              {
                key: "autoScaleY",
                value: function (t, e, i) {
                  t || (t = this);
                  var s = t.w;
                  if (s.globals.isMultipleYAxis || s.globals.collapsedSeries.length)
                    return console.warn("autoScaleYaxis is not supported in a multi-yaxis chart."), e;
                  var a = s.globals.seriesX[0],
                    n = s.config.chart.stacked;
                  return (
                    e.forEach(function (t, r) {
                      for (var o = 0, l = 0; l < a.length; l++)
                        if (a[l] >= i.xaxis.min) {
                          o = l;
                          break;
                        }
                      var c,
                        h,
                        d = s.globals.minYArr[r],
                        u = s.globals.maxYArr[r],
                        p = s.globals.stackedSeriesTotals;
                      s.globals.series.forEach(function (r, l) {
                        var g = r[o];
                        n
                          ? ((g = p[o]),
                            (c = h = g),
                            p.forEach(function (t, e) {
                              a[e] <= i.xaxis.max &&
                                a[e] >= i.xaxis.min &&
                                (t > h && null !== t && (h = t), r[e] < c && null !== r[e] && (c = r[e]));
                            }))
                          : ((c = h = g),
                            r.forEach(function (t, e) {
                              if (a[e] <= i.xaxis.max && a[e] >= i.xaxis.min) {
                                var n = t,
                                  r = t;
                                s.globals.series.forEach(function (i, s) {
                                  null !== t && ((n = Math.min(i[e], n)), (r = Math.max(i[e], r)));
                                }),
                                  r > h && null !== r && (h = r),
                                  n < c && null !== n && (c = n);
                              }
                            })),
                          void 0 === c && void 0 === h && ((c = d), (h = u)),
                          (h *= h < 0 ? 0.9 : 1.1),
                          0 == (c *= c < 0 ? 1.1 : 0.9) && 0 === h && ((c = -1), (h = 1)),
                          h < 0 && h < u && (h = u),
                          c < 0 && c > d && (c = d),
                          e.length > 1
                            ? ((e[l].min = void 0 === t.min ? c : t.min), (e[l].max = void 0 === t.max ? h : t.max))
                            : ((e[0].min = void 0 === t.min ? c : t.min), (e[0].max = void 0 === t.max ? h : t.max));
                      });
                    }),
                    e
                  );
                },
              },
            ]),
            t
          );
        })(),
        Z = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w), (this.scales = new q(e));
          }
          return (
            c(t, [
              {
                key: "init",
                value: function () {
                  this.setYRange(), this.setXRange(), this.setZRange();
                },
              },
              {
                key: "getMinYMaxY",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE,
                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE,
                    s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                    a = this.w.config,
                    n = this.w.globals,
                    r = -Number.MAX_VALUE,
                    o = Number.MIN_VALUE;
                  null === s && (s = t + 1);
                  var l = n.series,
                    c = l,
                    h = l;
                  "candlestick" === a.chart.type
                    ? ((c = n.seriesCandleL), (h = n.seriesCandleH))
                    : "boxPlot" === a.chart.type
                    ? ((c = n.seriesCandleO), (h = n.seriesCandleC))
                    : n.isRangeData && ((c = n.seriesRangeStart), (h = n.seriesRangeEnd));
                  for (var d = t; d < s; d++) {
                    (n.dataPoints = Math.max(n.dataPoints, l[d].length)),
                      n.categoryLabels.length &&
                        (n.dataPoints = n.categoryLabels.filter(function (t) {
                          return void 0 !== t;
                        }).length);
                    for (var u = 0; u < n.series[d].length; u++) {
                      var p = l[d][u];
                      null !== p && b.isNumber(p)
                        ? (void 0 !== h[d][u] && ((r = Math.max(r, h[d][u])), (e = Math.min(e, h[d][u]))),
                          void 0 !== c[d][u] && ((e = Math.min(e, c[d][u])), (i = Math.max(i, c[d][u]))),
                          ("candlestick" !== this.w.config.chart.type &&
                            "boxPlot" !== this.w.config.chart.type &&
                            "rangeArea" === this.w.config.chart.type &&
                            "rangeBar" === this.w.config.chart.type) ||
                            (("candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type) ||
                              (void 0 !== n.seriesCandleC[d][u] &&
                                ((r = Math.max(r, n.seriesCandleO[d][u])),
                                (r = Math.max(r, n.seriesCandleH[d][u])),
                                (r = Math.max(r, n.seriesCandleL[d][u])),
                                (r = Math.max(r, n.seriesCandleC[d][u])),
                                "boxPlot" === this.w.config.chart.type && (r = Math.max(r, n.seriesCandleM[d][u])))),
                            !a.series[d].type ||
                              ("candlestick" === a.series[d].type &&
                                "boxPlot" === a.series[d].type &&
                                "rangeArea" === a.series[d].type &&
                                "rangeBar" === a.series[d].type) ||
                              ((r = Math.max(r, n.series[d][u])), (e = Math.min(e, n.series[d][u]))),
                            (i = r)),
                          n.seriesGoals[d] &&
                            n.seriesGoals[d][u] &&
                            Array.isArray(n.seriesGoals[d][u]) &&
                            n.seriesGoals[d][u].forEach(function (t) {
                              o !== Number.MIN_VALUE && ((o = Math.min(o, t.value)), (e = o)),
                                (r = Math.max(r, t.value)),
                                (i = r);
                            }),
                          b.isFloat(p) &&
                            ((p = b.noExponents(p)),
                            (n.yValueDecimal = Math.max(n.yValueDecimal, p.toString().split(".")[1].length))),
                          o > c[d][u] && c[d][u] < 0 && (o = c[d][u]))
                        : (n.hasNullValues = !0);
                    }
                  }
                  return (
                    "rangeBar" === a.chart.type && n.seriesRangeStart.length && n.isBarHorizontal && (o = e),
                    "bar" === a.chart.type && (o < 0 && r < 0 && (r = 0), o === Number.MIN_VALUE && (o = 0)),
                    { minY: o, maxY: r, lowestY: e, highestY: i }
                  );
                },
              },
              {
                key: "setYRange",
                value: function () {
                  var t = this.w.globals,
                    e = this.w.config;
                  (t.maxY = -Number.MAX_VALUE), (t.minY = Number.MIN_VALUE);
                  var i = Number.MAX_VALUE;
                  if (t.isMultipleYAxis)
                    for (var s = 0; s < t.series.length; s++) {
                      var a = this.getMinYMaxY(s, i, null, s + 1);
                      t.minYArr.push(a.minY), t.maxYArr.push(a.maxY), (i = a.lowestY);
                    }
                  var n = this.getMinYMaxY(0, i, null, t.series.length);
                  if (
                    ((t.minY = n.minY),
                    (t.maxY = n.maxY),
                    (i = n.lowestY),
                    e.chart.stacked && this._setStackedMinMax(),
                    ("line" === e.chart.type ||
                      "area" === e.chart.type ||
                      "candlestick" === e.chart.type ||
                      "boxPlot" === e.chart.type ||
                      ("rangeBar" === e.chart.type && !t.isBarHorizontal)) &&
                      t.minY === Number.MIN_VALUE &&
                      i !== -Number.MAX_VALUE &&
                      i !== t.maxY)
                  ) {
                    var r = t.maxY - i;
                    ((i >= 0 && i <= 10) || void 0 !== e.yaxis[0].min || void 0 !== e.yaxis[0].max) && (r = 0),
                      (t.minY = i - (5 * r) / 100),
                      i > 0 && t.minY < 0 && (t.minY = 0),
                      (t.maxY = t.maxY + (5 * r) / 100);
                  }
                  return (
                    e.yaxis.forEach(function (e, i) {
                      void 0 !== e.max &&
                        ("number" == typeof e.max
                          ? (t.maxYArr[i] = e.max)
                          : "function" == typeof e.max &&
                            (t.maxYArr[i] = e.max(t.isMultipleYAxis ? t.maxYArr[i] : t.maxY)),
                        (t.maxY = t.maxYArr[i])),
                        void 0 !== e.min &&
                          ("number" == typeof e.min
                            ? (t.minYArr[i] = e.min)
                            : "function" == typeof e.min &&
                              (t.minYArr[i] = e.min(
                                t.isMultipleYAxis ? (t.minYArr[i] === Number.MIN_VALUE ? 0 : t.minYArr[i]) : t.minY
                              )),
                          (t.minY = t.minYArr[i]));
                    }),
                    t.isBarHorizontal &&
                      ["min", "max"].forEach(function (i) {
                        void 0 !== e.xaxis[i] &&
                          "number" == typeof e.xaxis[i] &&
                          ("min" === i ? (t.minY = e.xaxis[i]) : (t.maxY = e.xaxis[i]));
                      }),
                    t.isMultipleYAxis
                      ? (this.scales.setMultipleYScales(),
                        (t.minY = i),
                        t.yAxisScale.forEach(function (e, i) {
                          (t.minYArr[i] = e.niceMin), (t.maxYArr[i] = e.niceMax);
                        }))
                      : (this.scales.setYScaleForIndex(0, t.minY, t.maxY),
                        (t.minY = t.yAxisScale[0].niceMin),
                        (t.maxY = t.yAxisScale[0].niceMax),
                        (t.minYArr[0] = t.yAxisScale[0].niceMin),
                        (t.maxYArr[0] = t.yAxisScale[0].niceMax)),
                    { minY: t.minY, maxY: t.maxY, minYArr: t.minYArr, maxYArr: t.maxYArr, yAxisScale: t.yAxisScale }
                  );
                },
              },
              {
                key: "setXRange",
                value: function () {
                  var t = this.w.globals,
                    e = this.w.config,
                    i =
                      "numeric" === e.xaxis.type ||
                      "datetime" === e.xaxis.type ||
                      ("category" === e.xaxis.type && !t.noLabelsProvided) ||
                      t.noLabelsProvided ||
                      t.isXNumeric;
                  if (
                    (t.isXNumeric &&
                      (function () {
                        for (var e = 0; e < t.series.length; e++)
                          if (t.labels[e])
                            for (var i = 0; i < t.labels[e].length; i++)
                              null !== t.labels[e][i] &&
                                b.isNumber(t.labels[e][i]) &&
                                ((t.maxX = Math.max(t.maxX, t.labels[e][i])),
                                (t.initialMaxX = Math.max(t.maxX, t.labels[e][i])),
                                (t.minX = Math.min(t.minX, t.labels[e][i])),
                                (t.initialMinX = Math.min(t.minX, t.labels[e][i])));
                      })(),
                    t.noLabelsProvided &&
                      0 === e.xaxis.categories.length &&
                      ((t.maxX = t.labels[t.labels.length - 1]),
                      (t.initialMaxX = t.labels[t.labels.length - 1]),
                      (t.minX = 1),
                      (t.initialMinX = 1)),
                    t.isXNumeric || t.noLabelsProvided || t.dataFormatXNumeric)
                  ) {
                    var s;
                    if (
                      (void 0 === e.xaxis.tickAmount
                        ? ((s = Math.round(t.svgWidth / 150)),
                          "numeric" === e.xaxis.type && t.dataPoints < 30 && (s = t.dataPoints - 1),
                          s > t.dataPoints && 0 !== t.dataPoints && (s = t.dataPoints - 1))
                        : "dataPoints" === e.xaxis.tickAmount
                        ? (t.series.length > 1 && (s = t.series[t.maxValsInArrayIndex].length - 1),
                          t.isXNumeric && (s = t.maxX - t.minX - 1))
                        : (s = e.xaxis.tickAmount),
                      (t.xTickAmount = s),
                      void 0 !== e.xaxis.max && "number" == typeof e.xaxis.max && (t.maxX = e.xaxis.max),
                      void 0 !== e.xaxis.min && "number" == typeof e.xaxis.min && (t.minX = e.xaxis.min),
                      void 0 !== e.xaxis.range && (t.minX = t.maxX - e.xaxis.range),
                      t.minX !== Number.MAX_VALUE && t.maxX !== -Number.MAX_VALUE)
                    )
                      if (e.xaxis.convertedCatToNumeric && !t.dataFormatXNumeric) {
                        for (var a = [], n = t.minX - 1; n < t.maxX; n++) a.push(n + 1);
                        t.xAxisScale = { result: a, niceMin: a[0], niceMax: a[a.length - 1] };
                      } else t.xAxisScale = this.scales.setXScale(t.minX, t.maxX);
                    else
                      (t.xAxisScale = this.scales.linearScale(1, s, s)),
                        t.noLabelsProvided &&
                          t.labels.length > 0 &&
                          ((t.xAxisScale = this.scales.linearScale(1, t.labels.length, s - 1)),
                          (t.seriesX = t.labels.slice()));
                    i && (t.labels = t.xAxisScale.result.slice());
                  }
                  return (
                    t.isBarHorizontal && t.labels.length && (t.xTickAmount = t.labels.length),
                    this._handleSingleDataPoint(),
                    this._getMinXDiff(),
                    { minX: t.minX, maxX: t.maxX }
                  );
                },
              },
              {
                key: "setZRange",
                value: function () {
                  var t = this.w.globals;
                  if (t.isDataXYZ)
                    for (var e = 0; e < t.series.length; e++)
                      if (void 0 !== t.seriesZ[e])
                        for (var i = 0; i < t.seriesZ[e].length; i++)
                          null !== t.seriesZ[e][i] &&
                            b.isNumber(t.seriesZ[e][i]) &&
                            ((t.maxZ = Math.max(t.maxZ, t.seriesZ[e][i])),
                            (t.minZ = Math.min(t.minZ, t.seriesZ[e][i])));
                },
              },
              {
                key: "_handleSingleDataPoint",
                value: function () {
                  var t = this.w.globals,
                    e = this.w.config;
                  if (t.minX === t.maxX) {
                    var i = new O(this.ctx);
                    if ("datetime" === e.xaxis.type) {
                      var s = i.getDate(t.minX);
                      e.xaxis.labels.datetimeUTC ? s.setUTCDate(s.getUTCDate() - 2) : s.setDate(s.getDate() - 2),
                        (t.minX = new Date(s).getTime());
                      var a = i.getDate(t.maxX);
                      e.xaxis.labels.datetimeUTC ? a.setUTCDate(a.getUTCDate() + 2) : a.setDate(a.getDate() + 2),
                        (t.maxX = new Date(a).getTime());
                    } else
                      ("numeric" === e.xaxis.type || ("category" === e.xaxis.type && !t.noLabelsProvided)) &&
                        ((t.minX = t.minX - 2),
                        (t.initialMinX = t.minX),
                        (t.maxX = t.maxX + 2),
                        (t.initialMaxX = t.maxX));
                  }
                },
              },
              {
                key: "_getMinXDiff",
                value: function () {
                  var t = this.w.globals;
                  t.isXNumeric &&
                    t.seriesX.forEach(function (e, i) {
                      1 === e.length &&
                        e.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length - 1]);
                      var s = e.slice();
                      s.sort(function (t, e) {
                        return t - e;
                      }),
                        s.forEach(function (e, i) {
                          if (i > 0) {
                            var a = e - s[i - 1];
                            a > 0 && (t.minXDiff = Math.min(a, t.minXDiff));
                          }
                        }),
                        (1 !== t.dataPoints && t.minXDiff !== Number.MAX_VALUE) || (t.minXDiff = 0.5);
                    });
                },
              },
              {
                key: "_setStackedMinMax",
                value: function () {
                  var t = this.w.globals,
                    e = [],
                    i = [];
                  if (t.series.length)
                    for (var s = 0; s < t.series[t.maxValsInArrayIndex].length; s++)
                      for (var a = 0, n = 0, r = 0; r < t.series.length; r++)
                        null !== t.series[r][s] &&
                          b.isNumber(t.series[r][s]) &&
                          (t.series[r][s] > 0
                            ? (a = a + parseFloat(t.series[r][s]) + 1e-4)
                            : (n += parseFloat(t.series[r][s]))),
                          r === t.series.length - 1 && (e.push(a), i.push(n));
                  for (var o = 0; o < e.length; o++)
                    (t.maxY = Math.max(t.maxY, e[o])), (t.minY = Math.min(t.minY, i[o]));
                },
              },
            ]),
            t
          );
        })(),
        K = (function () {
          function t(e, i) {
            o(this, t), (this.ctx = e), (this.elgrid = i), (this.w = e.w);
            var s = this.w;
            (this.xaxisFontSize = s.config.xaxis.labels.style.fontSize),
              (this.axisFontFamily = s.config.xaxis.labels.style.fontFamily),
              (this.xaxisForeColors = s.config.xaxis.labels.style.colors),
              (this.isCategoryBarHorizontal = "bar" === s.config.chart.type && s.config.plotOptions.bar.horizontal),
              (this.xAxisoffX = 0),
              "bottom" === s.config.xaxis.position && (this.xAxisoffX = s.globals.gridHeight),
              (this.drawnLabels = []),
              (this.axesUtils = new V(e));
          }
          return (
            c(t, [
              {
                key: "drawYaxis",
                value: function (t) {
                  var e = this,
                    i = this.w,
                    s = new k(this.ctx),
                    a = i.config.yaxis[t].labels.style,
                    n = a.fontSize,
                    r = a.fontFamily,
                    o = a.fontWeight,
                    l = s.group({
                      class: "apexcharts-yaxis",
                      rel: t,
                      transform: "translate(" + i.globals.translateYAxisX[t] + ", 0)",
                    });
                  if (this.axesUtils.isYAxisHidden(t)) return l;
                  var c = s.group({ class: "apexcharts-yaxis-texts-g" });
                  l.add(c);
                  var h = i.globals.yAxisScale[t].result.length - 1,
                    d = i.globals.gridHeight / h,
                    u = i.globals.translateY,
                    p = i.globals.yLabelFormatters[t],
                    g = i.globals.yAxisScale[t].result.slice();
                  g = this.axesUtils.checkForReversedLabels(t, g);
                  var f = "";
                  if (i.config.yaxis[t].labels.show)
                    for (
                      var m = function (l) {
                          var m = g[l];
                          m = p(m, l, i);
                          var v = i.config.yaxis[t].labels.padding;
                          i.config.yaxis[t].opposite && 0 !== i.config.yaxis.length && (v *= -1);
                          var x = e.axesUtils.getYAxisForeColor(a.colors, t),
                            b = s.drawText({
                              x: v,
                              y: u + h / 10 + i.config.yaxis[t].labels.offsetY + 1,
                              text: m,
                              textAnchor: i.config.yaxis[t].opposite ? "start" : "end",
                              fontSize: n,
                              fontFamily: r,
                              fontWeight: o,
                              maxWidth: i.config.yaxis[t].labels.maxWidth,
                              foreColor: Array.isArray(x) ? x[l] : x,
                              isPlainText: !1,
                              cssClass: "apexcharts-yaxis-label " + a.cssClass,
                            });
                          l === h && (f = b), c.add(b);
                          var y = document.createElementNS(i.globals.SVGNS, "title");
                          if (
                            ((y.textContent = Array.isArray(m) ? m.join(" ") : m),
                            b.node.appendChild(y),
                            0 !== i.config.yaxis[t].labels.rotate)
                          ) {
                            var w = s.rotateAroundCenter(f.node),
                              k = s.rotateAroundCenter(b.node);
                            b.node.setAttribute(
                              "transform",
                              "rotate(".concat(i.config.yaxis[t].labels.rotate, " ").concat(w.x, " ").concat(k.y, ")")
                            );
                          }
                          u += d;
                        },
                        v = h;
                      v >= 0;
                      v--
                    )
                      m(v);
                  if (void 0 !== i.config.yaxis[t].title.text) {
                    var x = s.group({ class: "apexcharts-yaxis-title" }),
                      b = 0;
                    i.config.yaxis[t].opposite && (b = i.globals.translateYAxisX[t]);
                    var y = s.drawText({
                      x: b,
                      y: i.globals.gridHeight / 2 + i.globals.translateY + i.config.yaxis[t].title.offsetY,
                      text: i.config.yaxis[t].title.text,
                      textAnchor: "end",
                      foreColor: i.config.yaxis[t].title.style.color,
                      fontSize: i.config.yaxis[t].title.style.fontSize,
                      fontWeight: i.config.yaxis[t].title.style.fontWeight,
                      fontFamily: i.config.yaxis[t].title.style.fontFamily,
                      cssClass: "apexcharts-yaxis-title-text " + i.config.yaxis[t].title.style.cssClass,
                    });
                    x.add(y), l.add(x);
                  }
                  var w = i.config.yaxis[t].axisBorder,
                    S = 31 + w.offsetX;
                  if ((i.config.yaxis[t].opposite && (S = -31 - w.offsetX), w.show)) {
                    var C = s.drawLine(
                      S,
                      i.globals.translateY + w.offsetY - 2,
                      S,
                      i.globals.gridHeight + i.globals.translateY + w.offsetY + 2,
                      w.color,
                      0,
                      w.width
                    );
                    l.add(C);
                  }
                  return (
                    i.config.yaxis[t].axisTicks.show &&
                      this.axesUtils.drawYAxisTicks(S, h, w, i.config.yaxis[t].axisTicks, t, d, l),
                    l
                  );
                },
              },
              {
                key: "drawYaxisInversed",
                value: function (t) {
                  var e = this.w,
                    i = new k(this.ctx),
                    s = i.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }),
                    a = i.group({
                      class: "apexcharts-xaxis-texts-g",
                      transform: "translate("
                        .concat(e.globals.translateXAxisX, ", ")
                        .concat(e.globals.translateXAxisY, ")"),
                    });
                  s.add(a);
                  var n = e.globals.yAxisScale[t].result.length - 1,
                    r = e.globals.gridWidth / n + 0.1,
                    o = r + e.config.xaxis.labels.offsetX,
                    l = e.globals.xLabelFormatter,
                    c = e.globals.yAxisScale[t].result.slice(),
                    h = e.globals.timescaleLabels;
                  h.length > 0 && ((this.xaxisLabels = h.slice()), (n = (c = h.slice()).length)),
                    (c = this.axesUtils.checkForReversedLabels(t, c));
                  var d = h.length;
                  if (e.config.xaxis.labels.show)
                    for (var u = d ? 0 : n; d ? u < d : u >= 0; d ? u++ : u--) {
                      var p = c[u];
                      p = l(p, u, e);
                      var g = e.globals.gridWidth + e.globals.padHorizontal - (o - r + e.config.xaxis.labels.offsetX);
                      if (h.length) {
                        var f = this.axesUtils.getLabel(c, h, g, u, this.drawnLabels, this.xaxisFontSize);
                        (g = f.x),
                          (p = f.text),
                          this.drawnLabels.push(f.text),
                          0 === u && e.globals.skipFirstTimelinelabel && (p = ""),
                          u === c.length - 1 && e.globals.skipLastTimelinelabel && (p = "");
                      }
                      var m = i.drawText({
                        x: g,
                        y:
                          this.xAxisoffX +
                          e.config.xaxis.labels.offsetY +
                          30 -
                          ("top" === e.config.xaxis.position
                            ? e.globals.xAxisHeight + e.config.xaxis.axisTicks.height - 2
                            : 0),
                        text: p,
                        textAnchor: "middle",
                        foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t] : this.xaxisForeColors,
                        fontSize: this.xaxisFontSize,
                        fontFamily: this.xaxisFontFamily,
                        fontWeight: e.config.xaxis.labels.style.fontWeight,
                        isPlainText: !1,
                        cssClass: "apexcharts-xaxis-label " + e.config.xaxis.labels.style.cssClass,
                      });
                      a.add(m), m.tspan(p);
                      var v = document.createElementNS(e.globals.SVGNS, "title");
                      (v.textContent = p), m.node.appendChild(v), (o += r);
                    }
                  return this.inversedYAxisTitleText(s), this.inversedYAxisBorder(s), s;
                },
              },
              {
                key: "inversedYAxisBorder",
                value: function (t) {
                  var e = this.w,
                    i = new k(this.ctx),
                    s = e.config.xaxis.axisBorder;
                  if (s.show) {
                    var a = 0;
                    "bar" === e.config.chart.type && e.globals.isXNumeric && (a -= 15);
                    var n = i.drawLine(
                      e.globals.padHorizontal + a + s.offsetX,
                      this.xAxisoffX,
                      e.globals.gridWidth,
                      this.xAxisoffX,
                      s.color,
                      0,
                      s.height
                    );
                    this.elgrid && this.elgrid.elGridBorders ? this.elgrid.elGridBorders.add(n) : t.add(n);
                  }
                },
              },
              {
                key: "inversedYAxisTitleText",
                value: function (t) {
                  var e = this.w,
                    i = new k(this.ctx);
                  if (void 0 !== e.config.xaxis.title.text) {
                    var s = i.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }),
                      a = i.drawText({
                        x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX,
                        y:
                          this.xAxisoffX +
                          parseFloat(this.xaxisFontSize) +
                          parseFloat(e.config.xaxis.title.style.fontSize) +
                          e.config.xaxis.title.offsetY +
                          20,
                        text: e.config.xaxis.title.text,
                        textAnchor: "middle",
                        fontSize: e.config.xaxis.title.style.fontSize,
                        fontFamily: e.config.xaxis.title.style.fontFamily,
                        fontWeight: e.config.xaxis.title.style.fontWeight,
                        foreColor: e.config.xaxis.title.style.color,
                        cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass,
                      });
                    s.add(a), t.add(s);
                  }
                },
              },
              {
                key: "yAxisTitleRotate",
                value: function (t, e) {
                  var i = this.w,
                    s = new k(this.ctx),
                    a = { width: 0, height: 0 },
                    n = { width: 0, height: 0 },
                    r = i.globals.dom.baseEl.querySelector(
                      " .apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-texts-g")
                    );
                  null !== r && (a = r.getBoundingClientRect());
                  var o = i.globals.dom.baseEl.querySelector(
                    ".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-title text")
                  );
                  if ((null !== o && (n = o.getBoundingClientRect()), null !== o)) {
                    var l = this.xPaddingForYAxisTitle(t, a, n, e);
                    o.setAttribute("x", l.xPos - (e ? 10 : 0));
                  }
                  if (null !== o) {
                    var c = s.rotateAroundCenter(o);
                    o.setAttribute(
                      "transform",
                      "rotate("
                        .concat(e ? -1 * i.config.yaxis[t].title.rotate : i.config.yaxis[t].title.rotate, " ")
                        .concat(c.x, " ")
                        .concat(c.y, ")")
                    );
                  }
                },
              },
              {
                key: "xPaddingForYAxisTitle",
                value: function (t, e, i, s) {
                  var a = this.w,
                    n = 0,
                    r = 0,
                    o = 10;
                  return void 0 === a.config.yaxis[t].title.text || t < 0
                    ? { xPos: r, padd: 0 }
                    : (s
                        ? ((r = e.width + a.config.yaxis[t].title.offsetX + i.width / 2 + o / 2),
                          0 === (n += 1) && (r -= o / 2))
                        : ((r = -1 * e.width + a.config.yaxis[t].title.offsetX + o / 2 + i.width / 2),
                          a.globals.isBarHorizontal &&
                            ((o = 25), (r = -1 * e.width - a.config.yaxis[t].title.offsetX - o))),
                      { xPos: r, padd: o });
                },
              },
              {
                key: "setYAxisXPosition",
                value: function (t, e) {
                  var i = this.w,
                    s = 0,
                    a = 0,
                    n = 18,
                    r = 1;
                  i.config.yaxis.length > 1 && (this.multipleYs = !0),
                    i.config.yaxis.map(function (o, l) {
                      var c = i.globals.ignoreYAxisIndexes.indexOf(l) > -1 || !o.show || o.floating || 0 === t[l].width,
                        h = t[l].width + e[l].width;
                      o.opposite
                        ? i.globals.isBarHorizontal
                          ? ((a = i.globals.gridWidth + i.globals.translateX - 1),
                            (i.globals.translateYAxisX[l] = a - o.labels.offsetX))
                          : ((a = i.globals.gridWidth + i.globals.translateX + r),
                            c || (r = r + h + 20),
                            (i.globals.translateYAxisX[l] = a - o.labels.offsetX + 20))
                        : ((s = i.globals.translateX - n),
                          c || (n = n + h + 20),
                          (i.globals.translateYAxisX[l] = s + o.labels.offsetX));
                    });
                },
              },
              {
                key: "setYAxisTextAlignments",
                value: function () {
                  var t = this.w,
                    e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
                  (e = b.listToArray(e)).forEach(function (e, i) {
                    var s = t.config.yaxis[i];
                    if (s && void 0 !== s.labels.align) {
                      var a = t.globals.dom.baseEl.querySelector(
                          ".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-texts-g")
                        ),
                        n = t.globals.dom.baseEl.querySelectorAll(
                          ".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-label")
                        );
                      n = b.listToArray(n);
                      var r = a.getBoundingClientRect();
                      "left" === s.labels.align
                        ? (n.forEach(function (t, e) {
                            t.setAttribute("text-anchor", "start");
                          }),
                          s.opposite || a.setAttribute("transform", "translate(-".concat(r.width, ", 0)")))
                        : "center" === s.labels.align
                        ? (n.forEach(function (t, e) {
                            t.setAttribute("text-anchor", "middle");
                          }),
                          a.setAttribute(
                            "transform",
                            "translate(".concat((r.width / 2) * (s.opposite ? 1 : -1), ", 0)")
                          ))
                        : "right" === s.labels.align &&
                          (n.forEach(function (t, e) {
                            t.setAttribute("text-anchor", "end");
                          }),
                          s.opposite && a.setAttribute("transform", "translate(".concat(r.width, ", 0)")));
                    }
                  });
                },
              },
            ]),
            t
          );
        })(),
        J = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w), (this.documentEvent = b.bind(this.documentEvent, this));
          }
          return (
            c(t, [
              {
                key: "addEventListener",
                value: function (t, e) {
                  var i = this.w;
                  i.globals.events.hasOwnProperty(t) ? i.globals.events[t].push(e) : (i.globals.events[t] = [e]);
                },
              },
              {
                key: "removeEventListener",
                value: function (t, e) {
                  var i = this.w;
                  if (i.globals.events.hasOwnProperty(t)) {
                    var s = i.globals.events[t].indexOf(e);
                    -1 !== s && i.globals.events[t].splice(s, 1);
                  }
                },
              },
              {
                key: "fireEvent",
                value: function (t, e) {
                  var i = this.w;
                  if (i.globals.events.hasOwnProperty(t)) {
                    (e && e.length) || (e = []);
                    for (var s = i.globals.events[t], a = s.length, n = 0; n < a; n++) s[n].apply(null, e);
                  }
                },
              },
              {
                key: "setupEventHandlers",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = this.ctx,
                    s = e.globals.dom.baseEl.querySelector(e.globals.chartClass);
                  this.ctx.eventList.forEach(function (t) {
                    s.addEventListener(
                      t,
                      function (t) {
                        var s = Object.assign({}, e, {
                          seriesIndex: e.globals.capturedSeriesIndex,
                          dataPointIndex: e.globals.capturedDataPointIndex,
                        });
                        "mousemove" === t.type || "touchmove" === t.type
                          ? "function" == typeof e.config.chart.events.mouseMove &&
                            e.config.chart.events.mouseMove(t, i, s)
                          : "mouseleave" === t.type || "touchleave" === t.type
                          ? "function" == typeof e.config.chart.events.mouseLeave &&
                            e.config.chart.events.mouseLeave(t, i, s)
                          : (("mouseup" === t.type && 1 === t.which) || "touchend" === t.type) &&
                            ("function" == typeof e.config.chart.events.click && e.config.chart.events.click(t, i, s),
                            i.ctx.events.fireEvent("click", [t, i, s]));
                      },
                      { capture: !1, passive: !0 }
                    );
                  }),
                    this.ctx.eventList.forEach(function (i) {
                      e.globals.dom.baseEl.addEventListener(i, t.documentEvent, { passive: !0 });
                    }),
                    this.ctx.core.setupBrushHandler();
                },
              },
              {
                key: "documentEvent",
                value: function (t) {
                  var e = this.w,
                    i = t.target.className;
                  if ("click" === t.type) {
                    var s = e.globals.dom.baseEl.querySelector(".apexcharts-menu");
                    s &&
                      s.classList.contains("apexcharts-menu-open") &&
                      "apexcharts-menu-icon" !== i &&
                      s.classList.remove("apexcharts-menu-open");
                  }
                  (e.globals.clientX = "touchmove" === t.type ? t.touches[0].clientX : t.clientX),
                    (e.globals.clientY = "touchmove" === t.type ? t.touches[0].clientY : t.clientY);
                },
              },
            ]),
            t
          );
        })(),
        Q = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "setCurrentLocaleValues",
                value: function (t) {
                  var e = this.w.config.chart.locales;
                  window.Apex.chart &&
                    window.Apex.chart.locales &&
                    window.Apex.chart.locales.length > 0 &&
                    (e = this.w.config.chart.locales.concat(window.Apex.chart.locales));
                  var i = e.filter(function (e) {
                    return e.name === t;
                  })[0];
                  if (!i)
                    throw new Error(
                      "Wrong locale name provided. Please make sure you set the correct locale name in options"
                    );
                  var s = b.extend(L, i);
                  this.w.globals.locale = s.options;
                },
              },
            ]),
            t
          );
        })(),
        tt = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "drawAxis",
                value: function (t, e) {
                  var i,
                    s,
                    a = this.w.globals,
                    n = this.w.config,
                    r = new G(this.ctx, e),
                    o = new K(this.ctx, e);
                  a.axisCharts &&
                    "radar" !== t &&
                    (a.isBarHorizontal
                      ? ((s = o.drawYaxisInversed(0)),
                        (i = r.drawXaxisInversed(0)),
                        a.dom.elGraphical.add(i),
                        a.dom.elGraphical.add(s))
                      : ((i = r.drawXaxis()),
                        a.dom.elGraphical.add(i),
                        n.yaxis.map(function (t, e) {
                          -1 === a.ignoreYAxisIndexes.indexOf(e) && ((s = o.drawYaxis(e)), a.dom.Paper.add(s));
                        })));
                },
              },
            ]),
            t
          );
        })(),
        et = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "drawXCrosshairs",
                value: function () {
                  var t = this.w,
                    e = new k(this.ctx),
                    i = new w(this.ctx),
                    s = t.config.xaxis.crosshairs.fill.gradient,
                    a = t.config.xaxis.crosshairs.dropShadow,
                    n = t.config.xaxis.crosshairs.fill.type,
                    r = s.colorFrom,
                    o = s.colorTo,
                    l = s.opacityFrom,
                    c = s.opacityTo,
                    h = s.stops,
                    d = a.enabled,
                    u = a.left,
                    p = a.top,
                    g = a.blur,
                    f = a.color,
                    m = a.opacity,
                    v = t.config.xaxis.crosshairs.fill.color;
                  if (t.config.xaxis.crosshairs.show) {
                    "gradient" === n && (v = e.drawGradient("vertical", r, o, l, c, null, h, null));
                    var x = e.drawRect();
                    1 === t.config.xaxis.crosshairs.width && (x = e.drawLine());
                    var y = t.globals.gridHeight;
                    (!b.isNumber(y) || y < 0) && (y = 0);
                    var S = t.config.xaxis.crosshairs.width;
                    (!b.isNumber(S) || S < 0) && (S = 0),
                      x.attr({
                        class: "apexcharts-xcrosshairs",
                        x: 0,
                        y: 0,
                        y2: y,
                        width: S,
                        height: y,
                        fill: v,
                        filter: "none",
                        "fill-opacity": t.config.xaxis.crosshairs.opacity,
                        stroke: t.config.xaxis.crosshairs.stroke.color,
                        "stroke-width": t.config.xaxis.crosshairs.stroke.width,
                        "stroke-dasharray": t.config.xaxis.crosshairs.stroke.dashArray,
                      }),
                      d && (x = i.dropShadow(x, { left: u, top: p, blur: g, color: f, opacity: m })),
                      t.globals.dom.elGraphical.add(x);
                  }
                },
              },
              {
                key: "drawYCrosshairs",
                value: function () {
                  var t = this.w,
                    e = new k(this.ctx),
                    i = t.config.yaxis[0].crosshairs,
                    s = t.globals.barPadForNumericAxis;
                  if (t.config.yaxis[0].crosshairs.show) {
                    var a = e.drawLine(
                      -s,
                      0,
                      t.globals.gridWidth + s,
                      0,
                      i.stroke.color,
                      i.stroke.dashArray,
                      i.stroke.width
                    );
                    a.attr({ class: "apexcharts-ycrosshairs" }), t.globals.dom.elGraphical.add(a);
                  }
                  var n = e.drawLine(-s, 0, t.globals.gridWidth + s, 0, i.stroke.color, 0, 0);
                  n.attr({ class: "apexcharts-ycrosshairs-hidden" }), t.globals.dom.elGraphical.add(n);
                },
              },
            ]),
            t
          );
        })(),
        it = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "checkResponsiveConfig",
                value: function (t) {
                  var e = this,
                    i = this.w,
                    s = i.config;
                  if (0 !== s.responsive.length) {
                    var a = s.responsive.slice();
                    a.sort(function (t, e) {
                      return t.breakpoint > e.breakpoint ? 1 : e.breakpoint > t.breakpoint ? -1 : 0;
                    }).reverse();
                    var n = new z({}),
                      r = function () {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                          s = a[0].breakpoint,
                          r = window.innerWidth > 0 ? window.innerWidth : screen.width;
                        if (r > s) {
                          var o = S.extendArrayProps(n, i.globals.initialConfig, i);
                          (t = b.extend(o, t)), (t = b.extend(i.config, t)), e.overrideResponsiveOptions(t);
                        } else
                          for (var l = 0; l < a.length; l++)
                            r < a[l].breakpoint &&
                              ((t = S.extendArrayProps(n, a[l].options, i)),
                              (t = b.extend(i.config, t)),
                              e.overrideResponsiveOptions(t));
                      };
                    if (t) {
                      var o = S.extendArrayProps(n, t, i);
                      (o = b.extend(i.config, o)), r((o = b.extend(o, t)));
                    } else r({});
                  }
                },
              },
              {
                key: "overrideResponsiveOptions",
                value: function (t) {
                  var e = new z(t).init({ responsiveOverride: !0 });
                  this.w.config = e;
                },
              },
            ]),
            t
          );
        })(),
        st = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.colors = []), (this.w = e.w);
            var i = this.w;
            (this.isColorFn = !1),
              (this.isHeatmapDistributed =
                ("treemap" === i.config.chart.type && i.config.plotOptions.treemap.distributed) ||
                ("heatmap" === i.config.chart.type && i.config.plotOptions.heatmap.distributed)),
              (this.isBarDistributed =
                i.config.plotOptions.bar.distributed &&
                ("bar" === i.config.chart.type || "rangeBar" === i.config.chart.type));
          }
          return (
            c(t, [
              {
                key: "init",
                value: function () {
                  this.setDefaultColors();
                },
              },
              {
                key: "setDefaultColors",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = new b();
                  if (
                    (e.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(e.config.theme.mode)),
                    void 0 === e.config.colors
                      ? (e.globals.colors = this.predefined())
                      : ((e.globals.colors = e.config.colors),
                        Array.isArray(e.config.colors) &&
                          e.config.colors.length > 0 &&
                          "function" == typeof e.config.colors[0] &&
                          (e.globals.colors = e.config.series.map(function (i, s) {
                            var a = e.config.colors[s];
                            return (
                              a || (a = e.config.colors[0]),
                              "function" == typeof a
                                ? ((t.isColorFn = !0),
                                  a({
                                    value: e.globals.axisCharts
                                      ? e.globals.series[s][0]
                                        ? e.globals.series[s][0]
                                        : 0
                                      : e.globals.series[s],
                                    seriesIndex: s,
                                    dataPointIndex: s,
                                    w: e,
                                  }))
                                : a
                            );
                          }))),
                    e.globals.seriesColors.map(function (t, i) {
                      t && (e.globals.colors[i] = t);
                    }),
                    e.config.theme.monochrome.enabled)
                  ) {
                    var s = [],
                      a = e.globals.series.length;
                    (this.isBarDistributed || this.isHeatmapDistributed) &&
                      (a = e.globals.series[0].length * e.globals.series.length);
                    for (
                      var n = e.config.theme.monochrome.color,
                        r = 1 / (a / e.config.theme.monochrome.shadeIntensity),
                        o = e.config.theme.monochrome.shadeTo,
                        l = 0,
                        c = 0;
                      c < a;
                      c++
                    ) {
                      var h = void 0;
                      "dark" === o ? ((h = i.shadeColor(-1 * l, n)), (l += r)) : ((h = i.shadeColor(l, n)), (l += r)),
                        s.push(h);
                    }
                    e.globals.colors = s.slice();
                  }
                  var d = e.globals.colors.slice();
                  this.pushExtraColors(e.globals.colors),
                    ["fill", "stroke"].forEach(function (i) {
                      void 0 === e.config[i].colors
                        ? (e.globals[i].colors = t.isColorFn ? e.config.colors : d)
                        : (e.globals[i].colors = e.config[i].colors.slice()),
                        t.pushExtraColors(e.globals[i].colors);
                    }),
                    void 0 === e.config.dataLabels.style.colors
                      ? (e.globals.dataLabels.style.colors = d)
                      : (e.globals.dataLabels.style.colors = e.config.dataLabels.style.colors.slice()),
                    this.pushExtraColors(e.globals.dataLabels.style.colors, 50),
                    void 0 === e.config.plotOptions.radar.polygons.fill.colors
                      ? (e.globals.radarPolygons.fill.colors = ["dark" === e.config.theme.mode ? "#424242" : "none"])
                      : (e.globals.radarPolygons.fill.colors = e.config.plotOptions.radar.polygons.fill.colors.slice()),
                    this.pushExtraColors(e.globals.radarPolygons.fill.colors, 20),
                    void 0 === e.config.markers.colors
                      ? (e.globals.markers.colors = d)
                      : (e.globals.markers.colors = e.config.markers.colors.slice()),
                    this.pushExtraColors(e.globals.markers.colors);
                },
              },
              {
                key: "pushExtraColors",
                value: function (t, e) {
                  var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    s = this.w,
                    a = e || s.globals.series.length;
                  if (
                    (null === i &&
                      (i =
                        this.isBarDistributed ||
                        this.isHeatmapDistributed ||
                        ("heatmap" === s.config.chart.type && s.config.plotOptions.heatmap.colorScale.inverse)),
                    i &&
                      s.globals.series.length &&
                      (a = s.globals.series[s.globals.maxValsInArrayIndex].length * s.globals.series.length),
                    t.length < a)
                  )
                    for (var n = a - t.length, r = 0; r < n; r++) t.push(t[r]);
                },
              },
              {
                key: "updateThemeOptions",
                value: function (t) {
                  (t.chart = t.chart || {}), (t.tooltip = t.tooltip || {});
                  var e = t.theme.mode || "light",
                    i = t.theme.palette ? t.theme.palette : "dark" === e ? "palette4" : "palette1",
                    s = t.chart.foreColor ? t.chart.foreColor : "dark" === e ? "#f6f7f8" : "#373d3f";
                  return (t.tooltip.theme = e), (t.chart.foreColor = s), (t.theme.palette = i), t;
                },
              },
              {
                key: "predefined",
                value: function () {
                  switch (this.w.config.theme.palette) {
                    case "palette1":
                    default:
                      this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
                      break;
                    case "palette2":
                      this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
                      break;
                    case "palette3":
                      this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
                      break;
                    case "palette4":
                      this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
                      break;
                    case "palette5":
                      this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
                      break;
                    case "palette6":
                      this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
                      break;
                    case "palette7":
                      this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
                      break;
                    case "palette8":
                      this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
                      break;
                    case "palette9":
                      this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
                      break;
                    case "palette10":
                      this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
                  }
                  return this.colors;
                },
              },
            ]),
            t
          );
        })(),
        at = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "draw",
                value: function () {
                  this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
                },
              },
              {
                key: "drawTitleSubtitle",
                value: function (t) {
                  var e = this.w,
                    i = "title" === t ? e.config.title : e.config.subtitle,
                    s = e.globals.svgWidth / 2,
                    a = i.offsetY,
                    n = "middle";
                  if (
                    ("left" === i.align
                      ? ((s = 10), (n = "start"))
                      : "right" === i.align && ((s = e.globals.svgWidth - 10), (n = "end")),
                    (s += i.offsetX),
                    (a = a + parseInt(i.style.fontSize, 10) + i.margin / 2),
                    void 0 !== i.text)
                  ) {
                    var r = new k(this.ctx).drawText({
                      x: s,
                      y: a,
                      text: i.text,
                      textAnchor: n,
                      fontSize: i.style.fontSize,
                      fontFamily: i.style.fontFamily,
                      fontWeight: i.style.fontWeight,
                      foreColor: i.style.color,
                      opacity: 1,
                    });
                    r.node.setAttribute("class", "apexcharts-".concat(t, "-text")), e.globals.dom.Paper.add(r);
                  }
                },
              },
            ]),
            t
          );
        })(),
        nt = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.dCtx = e);
          }
          return (
            c(t, [
              {
                key: "getTitleSubtitleCoords",
                value: function (t) {
                  var e = this.w,
                    i = 0,
                    s = 0,
                    a = "title" === t ? e.config.title.floating : e.config.subtitle.floating,
                    n = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(t, "-text"));
                  if (null !== n && !a) {
                    var r = n.getBoundingClientRect();
                    (i = r.width), (s = e.globals.axisCharts ? r.height + 5 : r.height);
                  }
                  return { width: i, height: s };
                },
              },
              {
                key: "getLegendsRect",
                value: function () {
                  var t = this.w,
                    e = t.globals.dom.baseEl.querySelector(".apexcharts-legend");
                  t.config.legend.height ||
                    ("top" !== t.config.legend.position && "bottom" !== t.config.legend.position) ||
                    (e.style.maxHeight = t.globals.svgHeight / 2 + "px");
                  var i = Object.assign({}, b.getBoundingClientRect(e));
                  return (
                    null !== e && !t.config.legend.floating && t.config.legend.show
                      ? (this.dCtx.lgRect = { x: i.x, y: i.y, height: i.height, width: 0 === i.height ? 0 : i.width })
                      : (this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }),
                    ("left" !== t.config.legend.position && "right" !== t.config.legend.position) ||
                      (1.5 * this.dCtx.lgRect.width > t.globals.svgWidth &&
                        (this.dCtx.lgRect.width = t.globals.svgWidth / 1.5)),
                    this.dCtx.lgRect
                  );
                },
              },
              {
                key: "getLargestStringFromMultiArr",
                value: function (t, e) {
                  var i = t;
                  if (this.w.globals.isMultiLineX) {
                    var s = e.map(function (t, e) {
                        return Array.isArray(t) ? t.length : 1;
                      }),
                      a = Math.max.apply(Math, m(s));
                    i = e[s.indexOf(a)];
                  }
                  return i;
                },
              },
            ]),
            t
          );
        })(),
        rt = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.dCtx = e);
          }
          return (
            c(t, [
              {
                key: "getxAxisLabelsCoords",
                value: function () {
                  var t,
                    e = this.w,
                    i = e.globals.labels.slice();
                  if (
                    (e.config.xaxis.convertedCatToNumeric && 0 === i.length && (i = e.globals.categoryLabels),
                    e.globals.timescaleLabels.length > 0)
                  ) {
                    var s = this.getxAxisTimeScaleLabelsCoords();
                    (t = { width: s.width, height: s.height }), (e.globals.rotateXLabels = !1);
                  } else {
                    this.dCtx.lgWidthForSideLegends =
                      ("left" !== e.config.legend.position && "right" !== e.config.legend.position) ||
                      e.config.legend.floating
                        ? 0
                        : this.dCtx.lgRect.width;
                    var a = e.globals.xLabelFormatter,
                      n = b.getLargestStringFromArr(i),
                      r = this.dCtx.dimHelpers.getLargestStringFromMultiArr(n, i);
                    e.globals.isBarHorizontal &&
                      (r = n =
                        e.globals.yAxisScale[0].result.reduce(function (t, e) {
                          return t.length > e.length ? t : e;
                        }, 0));
                    var o = new $(this.dCtx.ctx),
                      l = n;
                    (n = o.xLabelFormat(a, n, l, { i: void 0, dateFormatter: new O(this.dCtx.ctx).formatDate, w: e })),
                      (r = o.xLabelFormat(a, r, l, {
                        i: void 0,
                        dateFormatter: new O(this.dCtx.ctx).formatDate,
                        w: e,
                      })),
                      ((e.config.xaxis.convertedCatToNumeric && void 0 === n) || "" === String(n).trim()) &&
                        (r = n = "1");
                    var c = new k(this.dCtx.ctx),
                      h = c.getTextRects(n, e.config.xaxis.labels.style.fontSize),
                      d = h;
                    if (
                      (n !== r && (d = c.getTextRects(r, e.config.xaxis.labels.style.fontSize)),
                      ((t = {
                        width: h.width >= d.width ? h.width : d.width,
                        height: h.height >= d.height ? h.height : d.height,
                      }).width *
                        i.length >
                        e.globals.svgWidth -
                          this.dCtx.lgWidthForSideLegends -
                          this.dCtx.yAxisWidth -
                          this.dCtx.gridPad.left -
                          this.dCtx.gridPad.right &&
                        0 !== e.config.xaxis.labels.rotate) ||
                        e.config.xaxis.labels.rotateAlways)
                    ) {
                      if (!e.globals.isBarHorizontal) {
                        e.globals.rotateXLabels = !0;
                        var u = function (t) {
                          return c.getTextRects(
                            t,
                            e.config.xaxis.labels.style.fontSize,
                            e.config.xaxis.labels.style.fontFamily,
                            "rotate(".concat(e.config.xaxis.labels.rotate, " 0 0)"),
                            !1
                          );
                        };
                        (h = u(n)),
                          n !== r && (d = u(r)),
                          (t.height = (h.height > d.height ? h.height : d.height) / 1.5),
                          (t.width = h.width > d.width ? h.width : d.width);
                      }
                    } else e.globals.rotateXLabels = !1;
                  }
                  return (
                    e.config.xaxis.labels.show || (t = { width: 0, height: 0 }), { width: t.width, height: t.height }
                  );
                },
              },
              {
                key: "getxAxisGroupLabelsCoords",
                value: function () {
                  var t,
                    e = this.w;
                  if (!e.globals.hasGroups) return { width: 0, height: 0 };
                  var i,
                    s =
                      (null === (t = e.config.xaxis.group.style) || void 0 === t ? void 0 : t.fontSize) ||
                      e.config.xaxis.labels.style.fontSize,
                    a = e.globals.groups.map(function (t) {
                      return t.title;
                    }),
                    n = b.getLargestStringFromArr(a),
                    r = this.dCtx.dimHelpers.getLargestStringFromMultiArr(n, a),
                    o = new k(this.dCtx.ctx),
                    l = o.getTextRects(n, s),
                    c = l;
                  return (
                    n !== r && (c = o.getTextRects(r, s)),
                    (i = {
                      width: l.width >= c.width ? l.width : c.width,
                      height: l.height >= c.height ? l.height : c.height,
                    }),
                    e.config.xaxis.labels.show || (i = { width: 0, height: 0 }),
                    { width: i.width, height: i.height }
                  );
                },
              },
              {
                key: "getxAxisTitleCoords",
                value: function () {
                  var t = this.w,
                    e = 0,
                    i = 0;
                  if (void 0 !== t.config.xaxis.title.text) {
                    var s = new k(this.dCtx.ctx).getTextRects(
                      t.config.xaxis.title.text,
                      t.config.xaxis.title.style.fontSize
                    );
                    (e = s.width), (i = s.height);
                  }
                  return { width: e, height: i };
                },
              },
              {
                key: "getxAxisTimeScaleLabelsCoords",
                value: function () {
                  var t,
                    e = this.w;
                  this.dCtx.timescaleLabels = e.globals.timescaleLabels.slice();
                  var i = this.dCtx.timescaleLabels.map(function (t) {
                      return t.value;
                    }),
                    s = i.reduce(function (t, e) {
                      return void 0 === t
                        ? (console.error(
                            "You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"
                          ),
                          0)
                        : t.length > e.length
                        ? t
                        : e;
                    }, 0);
                  return (
                    1.05 *
                      (t = new k(this.dCtx.ctx).getTextRects(s, e.config.xaxis.labels.style.fontSize)).width *
                      i.length >
                      e.globals.gridWidth &&
                      0 !== e.config.xaxis.labels.rotate &&
                      (e.globals.overlappingXLabels = !0),
                    t
                  );
                },
              },
              {
                key: "additionalPaddingXLabels",
                value: function (t) {
                  var e = this,
                    i = this.w,
                    s = i.globals,
                    a = i.config,
                    n = a.xaxis.type,
                    r = t.width;
                  (s.skipLastTimelinelabel = !1), (s.skipFirstTimelinelabel = !1);
                  var o = i.config.yaxis[0].opposite && i.globals.isBarHorizontal,
                    l = function (t, o) {
                      (function (t) {
                        return -1 !== s.collapsedSeriesIndices.indexOf(t);
                      })(o) ||
                        (function (t) {
                          if (e.dCtx.timescaleLabels && e.dCtx.timescaleLabels.length) {
                            var o = e.dCtx.timescaleLabels[0],
                              l =
                                e.dCtx.timescaleLabels[e.dCtx.timescaleLabels.length - 1].position +
                                r / 1.75 -
                                e.dCtx.yAxisWidthRight,
                              c = o.position - r / 1.75 + e.dCtx.yAxisWidthLeft,
                              h =
                                "right" === i.config.legend.position && e.dCtx.lgRect.width > 0
                                  ? e.dCtx.lgRect.width
                                  : 0;
                            l > s.svgWidth - s.translateX - h && (s.skipLastTimelinelabel = !0),
                              c <
                                -((t.show && !t.floating) ||
                                ("bar" !== a.chart.type &&
                                  "candlestick" !== a.chart.type &&
                                  "rangeBar" !== a.chart.type &&
                                  "boxPlot" !== a.chart.type)
                                  ? 10
                                  : r / 1.75) && (s.skipFirstTimelinelabel = !0);
                          } else
                            "datetime" === n
                              ? e.dCtx.gridPad.right < r && !s.rotateXLabels && (s.skipLastTimelinelabel = !0)
                              : "datetime" !== n &&
                                e.dCtx.gridPad.right < r / 2 - e.dCtx.yAxisWidthRight &&
                                !s.rotateXLabels &&
                                !i.config.xaxis.labels.trim &&
                                ("between" !== i.config.xaxis.tickPlacement || i.globals.isBarHorizontal) &&
                                (e.dCtx.xPadRight = r / 2 + 1);
                        })(t);
                    };
                  a.yaxis.forEach(function (t, i) {
                    o
                      ? (e.dCtx.gridPad.left < r && (e.dCtx.xPadLeft = r / 2 + 1), (e.dCtx.xPadRight = r / 2 + 1))
                      : l(t, i);
                  });
                },
              },
            ]),
            t
          );
        })(),
        ot = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.dCtx = e);
          }
          return (
            c(t, [
              {
                key: "getyAxisLabelsCoords",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = [],
                    s = 10,
                    a = new V(this.dCtx.ctx);
                  return (
                    e.config.yaxis.map(function (n, r) {
                      var o = e.globals.yAxisScale[r],
                        l = 0;
                      if (
                        (!a.isYAxisHidden(r) &&
                          n.labels.show &&
                          void 0 !== n.labels.minWidth &&
                          (l = n.labels.minWidth),
                        !a.isYAxisHidden(r) && n.labels.show && o.result.length)
                      ) {
                        var c = e.globals.yLabelFormatters[r],
                          h = o.niceMin === Number.MIN_VALUE ? 0 : o.niceMin,
                          d = String(h).length > String(o.niceMax).length ? h : o.niceMax,
                          u = c(d, { seriesIndex: r, dataPointIndex: -1, w: e }),
                          p = u;
                        if (((void 0 !== u && 0 !== u.length) || (u = d), e.globals.isBarHorizontal)) {
                          s = 0;
                          var g = e.globals.labels.slice();
                          (u = c((u = b.getLargestStringFromArr(g)), { seriesIndex: r, dataPointIndex: -1, w: e })),
                            (p = t.dCtx.dimHelpers.getLargestStringFromMultiArr(u, g));
                        }
                        var f = new k(t.dCtx.ctx),
                          m = "rotate(".concat(n.labels.rotate, " 0 0)"),
                          v = f.getTextRects(u, n.labels.style.fontSize, n.labels.style.fontFamily, m, !1),
                          x = v;
                        u !== p && (x = f.getTextRects(p, n.labels.style.fontSize, n.labels.style.fontFamily, m, !1)),
                          i.push({
                            width: (l > x.width || l > v.width ? l : x.width > v.width ? x.width : v.width) + s,
                            height: x.height > v.height ? x.height : v.height,
                          });
                      } else i.push({ width: 0, height: 0 });
                    }),
                    i
                  );
                },
              },
              {
                key: "getyAxisTitleCoords",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = [];
                  return (
                    e.config.yaxis.map(function (e, s) {
                      if (e.show && void 0 !== e.title.text) {
                        var a = new k(t.dCtx.ctx),
                          n = "rotate(".concat(e.title.rotate, " 0 0)"),
                          r = a.getTextRects(e.title.text, e.title.style.fontSize, e.title.style.fontFamily, n, !1);
                        i.push({ width: r.width, height: r.height });
                      } else i.push({ width: 0, height: 0 });
                    }),
                    i
                  );
                },
              },
              {
                key: "getTotalYAxisWidth",
                value: function () {
                  var t = this.w,
                    e = 0,
                    i = 0,
                    s = 0,
                    a = t.globals.yAxisScale.length > 1 ? 10 : 0,
                    n = new V(this.dCtx.ctx),
                    r = function (r, o) {
                      var l = t.config.yaxis[o].floating,
                        c = 0;
                      r.width > 0 && !l
                        ? ((c = r.width + a),
                          (function (e) {
                            return t.globals.ignoreYAxisIndexes.indexOf(e) > -1;
                          })(o) && (c = c - r.width - a))
                        : (c = l || n.isYAxisHidden(o) ? 0 : 5),
                        t.config.yaxis[o].opposite ? (s += c) : (i += c),
                        (e += c);
                    };
                  return (
                    t.globals.yLabelsCoords.map(function (t, e) {
                      r(t, e);
                    }),
                    t.globals.yTitleCoords.map(function (t, e) {
                      r(t, e);
                    }),
                    t.globals.isBarHorizontal &&
                      !t.config.yaxis[0].floating &&
                      (e = t.globals.yLabelsCoords[0].width + t.globals.yTitleCoords[0].width + 15),
                    (this.dCtx.yAxisWidthLeft = i),
                    (this.dCtx.yAxisWidthRight = s),
                    e
                  );
                },
              },
            ]),
            t
          );
        })(),
        lt = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.dCtx = e);
          }
          return (
            c(t, [
              {
                key: "gridPadForColumnsInNumericAxis",
                value: function (t) {
                  var e = this.w;
                  if (e.globals.noData || e.globals.allSeriesCollapsed) return 0;
                  var i = function (t) {
                      return "bar" === t || "rangeBar" === t || "candlestick" === t || "boxPlot" === t;
                    },
                    s = e.config.chart.type,
                    a = 0,
                    n = i(s) ? e.config.series.length : 1;
                  if (
                    (e.globals.comboBarCount > 0 && (n = e.globals.comboBarCount),
                    e.globals.collapsedSeries.forEach(function (t) {
                      i(t.type) && (n -= 1);
                    }),
                    e.config.chart.stacked && (n = 1),
                    (i(s) || e.globals.comboBarCount > 0) &&
                      e.globals.isXNumeric &&
                      !e.globals.isBarHorizontal &&
                      n > 0)
                  ) {
                    var r,
                      o,
                      l = Math.abs(e.globals.initialMaxX - e.globals.initialMinX);
                    l <= 3 && (l = e.globals.dataPoints),
                      (r = l / t),
                      e.globals.minXDiff && e.globals.minXDiff / r > 0 && (o = e.globals.minXDiff / r),
                      o > t / 2 && (o /= 2),
                      (a = ((o / n) * parseInt(e.config.plotOptions.bar.columnWidth, 10)) / 100) < 1 && (a = 1),
                      (a = a / (n > 1 ? 1 : 1.5) + 5),
                      (e.globals.barPadForNumericAxis = a);
                  }
                  return a;
                },
              },
              {
                key: "gridPadFortitleSubtitle",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = e.globals,
                    s = this.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 10;
                  ["title", "subtitle"].forEach(function (i) {
                    void 0 !== e.config[i].text
                      ? (s += e.config[i].margin)
                      : (s += t.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 5);
                  }),
                    !e.config.legend.show ||
                      "bottom" !== e.config.legend.position ||
                      e.config.legend.floating ||
                      e.globals.axisCharts ||
                      (s += 10);
                  var a = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"),
                    n = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
                  (i.gridHeight = i.gridHeight - a.height - n.height - s),
                    (i.translateY = i.translateY + a.height + n.height + s);
                },
              },
              {
                key: "setGridXPosForDualYAxis",
                value: function (t, e) {
                  var i = this.w,
                    s = new V(this.dCtx.ctx);
                  i.config.yaxis.map(function (a, n) {
                    -1 !== i.globals.ignoreYAxisIndexes.indexOf(n) ||
                      a.floating ||
                      s.isYAxisHidden(n) ||
                      (a.opposite &&
                        (i.globals.translateX =
                          i.globals.translateX -
                          (e[n].width + t[n].width) -
                          parseInt(i.config.yaxis[n].labels.style.fontSize, 10) / 1.2 -
                          12),
                      i.globals.translateX < 2 && (i.globals.translateX = 2));
                  });
                },
              },
            ]),
            t
          );
        })(),
        ct = (function () {
          function t(e) {
            o(this, t),
              (this.ctx = e),
              (this.w = e.w),
              (this.lgRect = {}),
              (this.yAxisWidth = 0),
              (this.yAxisWidthLeft = 0),
              (this.yAxisWidthRight = 0),
              (this.xAxisHeight = 0),
              (this.isSparkline = this.w.config.chart.sparkline.enabled),
              (this.dimHelpers = new nt(this)),
              (this.dimYAxis = new ot(this)),
              (this.dimXAxis = new rt(this)),
              (this.dimGrid = new lt(this)),
              (this.lgWidthForSideLegends = 0),
              (this.gridPad = this.w.config.grid.padding),
              (this.xPadRight = 0),
              (this.xPadLeft = 0);
          }
          return (
            c(t, [
              {
                key: "plotCoords",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = e.globals;
                  (this.lgRect = this.dimHelpers.getLegendsRect()),
                    this.isSparkline &&
                      (e.config.markers.discrete.length > 0 || e.config.markers.size > 0) &&
                      Object.entries(this.gridPad).forEach(function (e) {
                        var i = (function (t, e) {
                            return (
                              (function (t) {
                                if (Array.isArray(t)) return t;
                              })(t) ||
                              (function (t, e) {
                                var i =
                                  null == t
                                    ? null
                                    : ("undefined" != typeof Symbol && t[Symbol.iterator]) || t["@@iterator"];
                                if (null != i) {
                                  var s,
                                    a,
                                    n = [],
                                    r = !0,
                                    o = !1;
                                  try {
                                    for (
                                      i = i.call(t);
                                      !(r = (s = i.next()).done) && (n.push(s.value), 2 !== n.length);
                                      r = !0
                                    );
                                  } catch (t) {
                                    (o = !0), (a = t);
                                  } finally {
                                    try {
                                      r || null == i.return || i.return();
                                    } finally {
                                      if (o) throw a;
                                    }
                                  }
                                  return n;
                                }
                              })(t) ||
                              v(t, 2) ||
                              (function () {
                                throw new TypeError(
                                  "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                                );
                              })()
                            );
                          })(e),
                          s = i[0],
                          a = i[1];
                        t.gridPad[s] = Math.max(a, t.w.globals.markers.largestSize / 1.5);
                      }),
                    i.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(),
                    this.dimGrid.gridPadFortitleSubtitle(),
                    (i.gridHeight = i.gridHeight - this.gridPad.top - this.gridPad.bottom),
                    (i.gridWidth =
                      i.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft);
                  var s = this.dimGrid.gridPadForColumnsInNumericAxis(i.gridWidth);
                  (i.gridWidth = i.gridWidth - 2 * s),
                    (i.translateX = i.translateX + this.gridPad.left + this.xPadLeft + (s > 0 ? s + 4 : 0)),
                    (i.translateY = i.translateY + this.gridPad.top);
                },
              },
              {
                key: "setDimensionsForAxisCharts",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = e.globals,
                    s = this.dimYAxis.getyAxisLabelsCoords(),
                    a = this.dimYAxis.getyAxisTitleCoords();
                  (e.globals.yLabelsCoords = []),
                    (e.globals.yTitleCoords = []),
                    e.config.yaxis.map(function (t, i) {
                      e.globals.yLabelsCoords.push({ width: s[i].width, index: i }),
                        e.globals.yTitleCoords.push({ width: a[i].width, index: i });
                    }),
                    (this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth());
                  var n = this.dimXAxis.getxAxisLabelsCoords(),
                    r = this.dimXAxis.getxAxisGroupLabelsCoords(),
                    o = this.dimXAxis.getxAxisTitleCoords();
                  this.conditionalChecksForAxisCoords(n, o, r),
                    (i.translateXAxisY = e.globals.rotateXLabels ? this.xAxisHeight / 8 : -4),
                    (i.translateXAxisX =
                      e.globals.rotateXLabels && e.globals.isXNumeric && e.config.xaxis.labels.rotate <= -45
                        ? -this.xAxisWidth / 4
                        : 0),
                    e.globals.isBarHorizontal &&
                      ((i.rotateXLabels = !1),
                      (i.translateXAxisY = (parseInt(e.config.xaxis.labels.style.fontSize, 10) / 1.5) * -1)),
                    (i.translateXAxisY = i.translateXAxisY + e.config.xaxis.labels.offsetY),
                    (i.translateXAxisX = i.translateXAxisX + e.config.xaxis.labels.offsetX);
                  var l = this.yAxisWidth,
                    c = this.xAxisHeight;
                  (i.xAxisLabelsHeight = this.xAxisHeight - o.height),
                    (i.xAxisGroupLabelsHeight = i.xAxisLabelsHeight - n.height),
                    (i.xAxisLabelsWidth = this.xAxisWidth),
                    (i.xAxisHeight = this.xAxisHeight);
                  var h = 10;
                  ("radar" === e.config.chart.type || this.isSparkline) && ((l = 0), (c = i.goldenPadding)),
                    this.isSparkline && (this.lgRect = { height: 0, width: 0 }),
                    (this.isSparkline || "treemap" === e.config.chart.type) && ((l = 0), (c = 0), (h = 0)),
                    this.isSparkline || this.dimXAxis.additionalPaddingXLabels(n);
                  var d = function () {
                    (i.translateX = l),
                      (i.gridHeight =
                        i.svgHeight -
                        t.lgRect.height -
                        c -
                        (t.isSparkline || "treemap" === e.config.chart.type ? 0 : e.globals.rotateXLabels ? 10 : 15)),
                      (i.gridWidth = i.svgWidth - l);
                  };
                  switch (
                    ("top" === e.config.xaxis.position && (h = i.xAxisHeight - e.config.xaxis.axisTicks.height - 5),
                    e.config.legend.position)
                  ) {
                    case "bottom":
                      (i.translateY = h), d();
                      break;
                    case "top":
                      (i.translateY = this.lgRect.height + h), d();
                      break;
                    case "left":
                      (i.translateY = h),
                        (i.translateX = this.lgRect.width + l),
                        (i.gridHeight = i.svgHeight - c - 12),
                        (i.gridWidth = i.svgWidth - this.lgRect.width - l);
                      break;
                    case "right":
                      (i.translateY = h),
                        (i.translateX = l),
                        (i.gridHeight = i.svgHeight - c - 12),
                        (i.gridWidth = i.svgWidth - this.lgRect.width - l - 5);
                      break;
                    default:
                      throw new Error("Legend position not supported");
                  }
                  this.dimGrid.setGridXPosForDualYAxis(a, s), new K(this.ctx).setYAxisXPosition(s, a);
                },
              },
              {
                key: "setDimensionsForNonAxisCharts",
                value: function () {
                  var t = this.w,
                    e = t.globals,
                    i = t.config,
                    s = 0;
                  t.config.legend.show && !t.config.legend.floating && (s = 20);
                  var a =
                      "pie" === i.chart.type || "polarArea" === i.chart.type || "donut" === i.chart.type
                        ? "pie"
                        : "radialBar",
                    n = i.plotOptions[a].offsetY,
                    r = i.plotOptions[a].offsetX;
                  if (!i.legend.show || i.legend.floating)
                    return (
                      (e.gridHeight = e.svgHeight - i.grid.padding.left + i.grid.padding.right),
                      (e.gridWidth = e.gridHeight),
                      (e.translateY = n),
                      void (e.translateX = r + (e.svgWidth - e.gridWidth) / 2)
                    );
                  switch (i.legend.position) {
                    case "bottom":
                      (e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding),
                        (e.gridWidth = e.svgWidth),
                        (e.translateY = n - 10),
                        (e.translateX = r + (e.svgWidth - e.gridWidth) / 2);
                      break;
                    case "top":
                      (e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding),
                        (e.gridWidth = e.svgWidth),
                        (e.translateY = this.lgRect.height + n + 10),
                        (e.translateX = r + (e.svgWidth - e.gridWidth) / 2);
                      break;
                    case "left":
                      (e.gridWidth = e.svgWidth - this.lgRect.width - s),
                        (e.gridHeight = "auto" !== i.chart.height ? e.svgHeight : e.gridWidth),
                        (e.translateY = n),
                        (e.translateX = r + this.lgRect.width + s);
                      break;
                    case "right":
                      (e.gridWidth = e.svgWidth - this.lgRect.width - s - 5),
                        (e.gridHeight = "auto" !== i.chart.height ? e.svgHeight : e.gridWidth),
                        (e.translateY = n),
                        (e.translateX = r + 10);
                      break;
                    default:
                      throw new Error("Legend position not supported");
                  }
                },
              },
              {
                key: "conditionalChecksForAxisCoords",
                value: function (t, e, i) {
                  var s = this.w,
                    a = s.globals.hasGroups ? 2 : 1,
                    n = i.height + t.height + e.height,
                    r = s.globals.isMultiLineX ? 1.2 : s.globals.LINE_HEIGHT_RATIO,
                    o = s.globals.rotateXLabels ? 22 : 10,
                    l = s.globals.rotateXLabels && "bottom" === s.config.legend.position ? 10 : 0;
                  (this.xAxisHeight = n * r + a * o + l),
                    (this.xAxisWidth = t.width),
                    this.xAxisHeight - e.height > s.config.xaxis.labels.maxHeight &&
                      (this.xAxisHeight = s.config.xaxis.labels.maxHeight),
                    s.config.xaxis.labels.minHeight &&
                      this.xAxisHeight < s.config.xaxis.labels.minHeight &&
                      (this.xAxisHeight = s.config.xaxis.labels.minHeight),
                    s.config.xaxis.floating && (this.xAxisHeight = 0);
                  var c = 0,
                    h = 0;
                  s.config.yaxis.forEach(function (t) {
                    (c += t.labels.minWidth), (h += t.labels.maxWidth);
                  }),
                    this.yAxisWidth < c && (this.yAxisWidth = c),
                    this.yAxisWidth > h && (this.yAxisWidth = h);
                },
              },
            ]),
            t
          );
        })(),
        ht = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.lgCtx = e);
          }
          return (
            c(t, [
              {
                key: "getLegendStyles",
                value: function () {
                  var t = document.createElement("style");
                  t.setAttribute("type", "text/css");
                  var e = document.createTextNode(
                    "\t\n    \t\n      .apexcharts-legend {\t\n        display: flex;\t\n        overflow: auto;\t\n        padding: 0 10px;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\t\n        flex-wrap: wrap\t\n      }\t\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\t\n        flex-direction: column;\t\n        bottom: 0;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\t\n        justify-content: flex-start;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\t\n        justify-content: center;  \t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\t\n        justify-content: flex-end;\t\n      }\t\n      .apexcharts-legend-series {\t\n        cursor: pointer;\t\n        line-height: normal;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{\t\n        display: flex;\t\n        align-items: center;\t\n      }\t\n      .apexcharts-legend-text {\t\n        position: relative;\t\n        font-size: 14px;\t\n      }\t\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\t\n        pointer-events: none;\t\n      }\t\n      .apexcharts-legend-marker {\t\n        position: relative;\t\n        display: inline-block;\t\n        cursor: pointer;\t\n        margin-right: 3px;\t\n        border-style: solid;\n      }\t\n      \t\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\t\n        display: inline-block;\t\n      }\t\n      .apexcharts-legend-series.apexcharts-no-click {\t\n        cursor: auto;\t\n      }\t\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\t\n        display: none !important;\t\n      }\t\n      .apexcharts-inactive-legend {\t\n        opacity: 0.45;\t\n      }"
                  );
                  return t.appendChild(e), t;
                },
              },
              {
                key: "getLegendBBox",
                value: function () {
                  var t = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(),
                    e = t.width;
                  return { clwh: t.height, clww: e };
                },
              },
              {
                key: "appendToForeignObject",
                value: function () {
                  var t = this.w.globals;
                  t.dom.elLegendForeign = document.createElementNS(t.SVGNS, "foreignObject");
                  var e = t.dom.elLegendForeign;
                  e.setAttribute("x", 0),
                    e.setAttribute("y", 0),
                    e.setAttribute("width", t.svgWidth),
                    e.setAttribute("height", t.svgHeight),
                    t.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"),
                    e.appendChild(t.dom.elLegendWrap),
                    e.appendChild(this.getLegendStyles()),
                    t.dom.Paper.node.insertBefore(e, t.dom.elGraphical.node);
                },
              },
              {
                key: "toggleDataSeries",
                value: function (t, e) {
                  var i = this,
                    s = this.w;
                  if (s.globals.axisCharts || "radialBar" === s.config.chart.type) {
                    s.globals.resized = !0;
                    var a = null,
                      n = null;
                    (s.globals.risingSeries = []),
                      s.globals.axisCharts
                        ? ((a = s.globals.dom.baseEl.querySelector(
                            ".apexcharts-series[data\\:realIndex='".concat(t, "']")
                          )),
                          (n = parseInt(a.getAttribute("data:realIndex"), 10)))
                        : ((a = s.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t + 1, "']"))),
                          (n = parseInt(a.getAttribute("rel"), 10) - 1)),
                      e
                        ? [
                            { cs: s.globals.collapsedSeries, csi: s.globals.collapsedSeriesIndices },
                            { cs: s.globals.ancillaryCollapsedSeries, csi: s.globals.ancillaryCollapsedSeriesIndices },
                          ].forEach(function (t) {
                            i.riseCollapsedSeries(t.cs, t.csi, n);
                          })
                        : this.hideSeries({ seriesEl: a, realIndex: n });
                  } else {
                    var r = s.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t + 1, "'] path")),
                      o = s.config.chart.type;
                    if ("pie" === o || "polarArea" === o || "donut" === o) {
                      var l = s.config.plotOptions.pie.donut.labels;
                      new k(this.lgCtx.ctx).pathMouseDown(r.members[0], null),
                        this.lgCtx.ctx.pie.printDataLabelsInner(r.members[0].node, l);
                    }
                    r.fire("click");
                  }
                },
              },
              {
                key: "hideSeries",
                value: function (t) {
                  var e = t.seriesEl,
                    i = t.realIndex,
                    s = this.w,
                    a = b.clone(s.config.series);
                  if (s.globals.axisCharts) {
                    var n = !1;
                    if (
                      (s.config.yaxis[i] &&
                        s.config.yaxis[i].show &&
                        s.config.yaxis[i].showAlways &&
                        ((n = !0),
                        s.globals.ancillaryCollapsedSeriesIndices.indexOf(i) < 0 &&
                          (s.globals.ancillaryCollapsedSeries.push({
                            index: i,
                            data: a[i].data.slice(),
                            type: e.parentNode.className.baseVal.split("-")[1],
                          }),
                          s.globals.ancillaryCollapsedSeriesIndices.push(i))),
                      !n)
                    ) {
                      s.globals.collapsedSeries.push({
                        index: i,
                        data: a[i].data.slice(),
                        type: e.parentNode.className.baseVal.split("-")[1],
                      }),
                        s.globals.collapsedSeriesIndices.push(i);
                      var r = s.globals.risingSeries.indexOf(i);
                      s.globals.risingSeries.splice(r, 1);
                    }
                  } else
                    s.globals.collapsedSeries.push({ index: i, data: a[i] }), s.globals.collapsedSeriesIndices.push(i);
                  for (var o = e.childNodes, l = 0; l < o.length; l++)
                    o[l].classList.contains("apexcharts-series-markers-wrap") &&
                      (o[l].classList.contains("apexcharts-hide")
                        ? o[l].classList.remove("apexcharts-hide")
                        : o[l].classList.add("apexcharts-hide"));
                  (s.globals.allSeriesCollapsed = s.globals.collapsedSeries.length === s.config.series.length),
                    (a = this._getSeriesBasedOnCollapsedState(a)),
                    this.lgCtx.ctx.updateHelpers._updateSeries(a, s.config.chart.animations.dynamicAnimation.enabled);
                },
              },
              {
                key: "riseCollapsedSeries",
                value: function (t, e, i) {
                  var s = this.w,
                    a = b.clone(s.config.series);
                  if (t.length > 0) {
                    for (var n = 0; n < t.length; n++)
                      t[n].index === i &&
                        (s.globals.axisCharts
                          ? ((a[i].data = t[n].data.slice()),
                            t.splice(n, 1),
                            e.splice(n, 1),
                            s.globals.risingSeries.push(i))
                          : ((a[i] = t[n].data), t.splice(n, 1), e.splice(n, 1), s.globals.risingSeries.push(i)));
                    (a = this._getSeriesBasedOnCollapsedState(a)),
                      this.lgCtx.ctx.updateHelpers._updateSeries(a, s.config.chart.animations.dynamicAnimation.enabled);
                  }
                },
              },
              {
                key: "_getSeriesBasedOnCollapsedState",
                value: function (t) {
                  var e = this.w;
                  return (
                    e.globals.axisCharts
                      ? t.forEach(function (i, s) {
                          e.globals.collapsedSeriesIndices.indexOf(s) > -1 && (t[s].data = []);
                        })
                      : t.forEach(function (i, s) {
                          e.globals.collapsedSeriesIndices.indexOf(s) > -1 && (t[s] = 0);
                        }),
                    t
                  );
                },
              },
            ]),
            t
          );
        })(),
        dt = (function () {
          function t(e, i) {
            o(this, t),
              (this.ctx = e),
              (this.w = e.w),
              (this.onLegendClick = this.onLegendClick.bind(this)),
              (this.onLegendHovered = this.onLegendHovered.bind(this)),
              (this.isBarsDistributed =
                "bar" === this.w.config.chart.type &&
                this.w.config.plotOptions.bar.distributed &&
                1 === this.w.config.series.length),
              (this.legendHelpers = new ht(this));
          }
          return (
            c(t, [
              {
                key: "init",
                value: function () {
                  var t = this.w,
                    e = t.globals,
                    i = t.config;
                  if (
                    ((i.legend.showForSingleSeries && 1 === e.series.length) ||
                      this.isBarsDistributed ||
                      e.series.length > 1 ||
                      !e.axisCharts) &&
                    i.legend.show
                  ) {
                    for (; e.dom.elLegendWrap.firstChild; )
                      e.dom.elLegendWrap.removeChild(e.dom.elLegendWrap.firstChild);
                    this.drawLegends(),
                      b.isIE11()
                        ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles())
                        : this.legendHelpers.appendToForeignObject(),
                      "bottom" === i.legend.position || "top" === i.legend.position
                        ? this.legendAlignHorizontal()
                        : ("right" !== i.legend.position && "left" !== i.legend.position) || this.legendAlignVertical();
                  }
                },
              },
              {
                key: "drawLegends",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = e.config.legend.fontFamily,
                    s = e.globals.seriesNames,
                    a = e.globals.colors.slice();
                  if ("heatmap" === e.config.chart.type) {
                    var n = e.config.plotOptions.heatmap.colorScale.ranges;
                    (s = n.map(function (t) {
                      return t.name ? t.name : t.from + " - " + t.to;
                    })),
                      (a = n.map(function (t) {
                        return t.color;
                      }));
                  } else this.isBarsDistributed && (s = e.globals.labels.slice());
                  e.config.legend.customLegendItems.length && (s = e.config.legend.customLegendItems);
                  for (
                    var r = e.globals.legendFormatter, o = e.config.legend.inverseOrder, l = o ? s.length - 1 : 0;
                    o ? l >= 0 : l <= s.length - 1;
                    o ? l-- : l++
                  ) {
                    var c = r(s[l], { seriesIndex: l, w: e }),
                      h = !1,
                      d = !1;
                    if (e.globals.collapsedSeries.length > 0)
                      for (var u = 0; u < e.globals.collapsedSeries.length; u++)
                        e.globals.collapsedSeries[u].index === l && (h = !0);
                    if (e.globals.ancillaryCollapsedSeriesIndices.length > 0)
                      for (var p = 0; p < e.globals.ancillaryCollapsedSeriesIndices.length; p++)
                        e.globals.ancillaryCollapsedSeriesIndices[p] === l && (d = !0);
                    var g = document.createElement("span");
                    g.classList.add("apexcharts-legend-marker");
                    var f = e.config.legend.markers.offsetX,
                      m = e.config.legend.markers.offsetY,
                      v = e.config.legend.markers.height,
                      x = e.config.legend.markers.width,
                      y = e.config.legend.markers.strokeWidth,
                      w = e.config.legend.markers.strokeColor,
                      C = e.config.legend.markers.radius,
                      A = g.style;
                    (A.background = a[l]),
                      (A.color = a[l]),
                      A.setProperty("background", a[l], "important"),
                      e.config.legend.markers.fillColors &&
                        e.config.legend.markers.fillColors[l] &&
                        (A.background = e.config.legend.markers.fillColors[l]),
                      void 0 !== e.globals.seriesColors[l] &&
                        ((A.background = e.globals.seriesColors[l]), (A.color = e.globals.seriesColors[l])),
                      (A.height = Array.isArray(v) ? parseFloat(v[l]) + "px" : parseFloat(v) + "px"),
                      (A.width = Array.isArray(x) ? parseFloat(x[l]) + "px" : parseFloat(x) + "px"),
                      (A.left = (Array.isArray(f) ? parseFloat(f[l]) : parseFloat(f)) + "px"),
                      (A.top = (Array.isArray(m) ? parseFloat(m[l]) : parseFloat(m)) + "px"),
                      (A.borderWidth = Array.isArray(y) ? y[l] : y),
                      (A.borderColor = Array.isArray(w) ? w[l] : w),
                      (A.borderRadius = Array.isArray(C) ? parseFloat(C[l]) + "px" : parseFloat(C) + "px"),
                      e.config.legend.markers.customHTML &&
                        (Array.isArray(e.config.legend.markers.customHTML)
                          ? e.config.legend.markers.customHTML[l] &&
                            (g.innerHTML = e.config.legend.markers.customHTML[l]())
                          : (g.innerHTML = e.config.legend.markers.customHTML())),
                      k.setAttrs(g, { rel: l + 1, "data:collapsed": h || d }),
                      (h || d) && g.classList.add("apexcharts-inactive-legend");
                    var E = document.createElement("div"),
                      T = document.createElement("span");
                    T.classList.add("apexcharts-legend-text"), (T.innerHTML = Array.isArray(c) ? c.join(" ") : c);
                    var L = e.config.legend.labels.useSeriesColors
                      ? e.globals.colors[l]
                      : e.config.legend.labels.colors;
                    L || (L = e.config.chart.foreColor),
                      (T.style.color = L),
                      (T.style.fontSize = parseFloat(e.config.legend.fontSize) + "px"),
                      (T.style.fontWeight = e.config.legend.fontWeight),
                      (T.style.fontFamily = i || e.config.chart.fontFamily),
                      k.setAttrs(T, {
                        rel: l + 1,
                        i: l,
                        "data:default-text": encodeURIComponent(c),
                        "data:collapsed": h || d,
                      }),
                      E.appendChild(g),
                      E.appendChild(T);
                    var P = new S(this.ctx);
                    e.config.legend.showForZeroSeries ||
                      (0 === P.getSeriesTotalByIndex(l) &&
                        P.seriesHaveSameValues(l) &&
                        !P.isSeriesNull(l) &&
                        -1 === e.globals.collapsedSeriesIndices.indexOf(l) &&
                        -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(l) &&
                        E.classList.add("apexcharts-hidden-zero-series")),
                      e.config.legend.showForNullSeries ||
                        (P.isSeriesNull(l) &&
                          -1 === e.globals.collapsedSeriesIndices.indexOf(l) &&
                          -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(l) &&
                          E.classList.add("apexcharts-hidden-null-series")),
                      e.globals.dom.elLegendWrap.appendChild(E),
                      e.globals.dom.elLegendWrap.classList.add(
                        "apexcharts-align-".concat(e.config.legend.horizontalAlign)
                      ),
                      e.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + e.config.legend.position),
                      E.classList.add("apexcharts-legend-series"),
                      (E.style.margin = ""
                        .concat(e.config.legend.itemMargin.vertical, "px ")
                        .concat(e.config.legend.itemMargin.horizontal, "px")),
                      (e.globals.dom.elLegendWrap.style.width = e.config.legend.width
                        ? e.config.legend.width + "px"
                        : ""),
                      (e.globals.dom.elLegendWrap.style.height = e.config.legend.height
                        ? e.config.legend.height + "px"
                        : ""),
                      k.setAttrs(E, { rel: l + 1, seriesName: b.escapeString(s[l]), "data:collapsed": h || d }),
                      (h || d) && E.classList.add("apexcharts-inactive-legend"),
                      e.config.legend.onItemClick.toggleDataSeries || E.classList.add("apexcharts-no-click");
                  }
                  e.globals.dom.elWrap.addEventListener("click", t.onLegendClick, !0),
                    e.config.legend.onItemHover.highlightDataSeries &&
                      0 === e.config.legend.customLegendItems.length &&
                      (e.globals.dom.elWrap.addEventListener("mousemove", t.onLegendHovered, !0),
                      e.globals.dom.elWrap.addEventListener("mouseout", t.onLegendHovered, !0));
                },
              },
              {
                key: "setLegendWrapXY",
                value: function (t, e) {
                  var i = this.w,
                    s = i.globals.dom.baseEl.querySelector(".apexcharts-legend"),
                    a = s.getBoundingClientRect(),
                    n = 0,
                    r = 0;
                  if ("bottom" === i.config.legend.position) r += i.globals.svgHeight - a.height / 2;
                  else if ("top" === i.config.legend.position) {
                    var o = new ct(this.ctx),
                      l = o.dimHelpers.getTitleSubtitleCoords("title").height,
                      c = o.dimHelpers.getTitleSubtitleCoords("subtitle").height;
                    r = r + (l > 0 ? l - 10 : 0) + (c > 0 ? c - 10 : 0);
                  }
                  (s.style.position = "absolute"),
                    (n = n + t + i.config.legend.offsetX),
                    (r = r + e + i.config.legend.offsetY),
                    (s.style.left = n + "px"),
                    (s.style.top = r + "px"),
                    "bottom" === i.config.legend.position
                      ? ((s.style.top = "auto"), (s.style.bottom = 5 - i.config.legend.offsetY + "px"))
                      : "right" === i.config.legend.position &&
                        ((s.style.left = "auto"), (s.style.right = 25 + i.config.legend.offsetX + "px")),
                    ["width", "height"].forEach(function (t) {
                      s.style[t] && (s.style[t] = parseInt(i.config.legend[t], 10) + "px");
                    });
                },
              },
              {
                key: "legendAlignHorizontal",
                value: function () {
                  var t = this.w;
                  t.globals.dom.baseEl.querySelector(".apexcharts-legend").style.right = 0;
                  var e = this.legendHelpers.getLegendBBox(),
                    i = new ct(this.ctx),
                    s = i.dimHelpers.getTitleSubtitleCoords("title"),
                    a = i.dimHelpers.getTitleSubtitleCoords("subtitle"),
                    n = 0;
                  "bottom" === t.config.legend.position
                    ? (n = -e.clwh / 1.8)
                    : "top" === t.config.legend.position &&
                      (n = s.height + a.height + t.config.title.margin + t.config.subtitle.margin - 10),
                    this.setLegendWrapXY(20, n);
                },
              },
              {
                key: "legendAlignVertical",
                value: function () {
                  var t = this.w,
                    e = this.legendHelpers.getLegendBBox(),
                    i = 0;
                  "left" === t.config.legend.position && (i = 20),
                    "right" === t.config.legend.position && (i = t.globals.svgWidth - e.clww - 10),
                    this.setLegendWrapXY(i, 20);
                },
              },
              {
                key: "onLegendHovered",
                value: function (t) {
                  var e = this.w,
                    i =
                      t.target.classList.contains("apexcharts-legend-text") ||
                      t.target.classList.contains("apexcharts-legend-marker");
                  if ("heatmap" === e.config.chart.type || this.isBarsDistributed) {
                    if (i) {
                      var s = parseInt(t.target.getAttribute("rel"), 10) - 1;
                      this.ctx.events.fireEvent("legendHover", [this.ctx, s, this.w]),
                        new Y(this.ctx).highlightRangeInSeries(t, t.target);
                    }
                  } else
                    !t.target.classList.contains("apexcharts-inactive-legend") &&
                      i &&
                      new Y(this.ctx).toggleSeriesOnHover(t, t.target);
                },
              },
              {
                key: "onLegendClick",
                value: function (t) {
                  var e = this.w;
                  if (
                    !e.config.legend.customLegendItems.length &&
                    (t.target.classList.contains("apexcharts-legend-text") ||
                      t.target.classList.contains("apexcharts-legend-marker"))
                  ) {
                    var i = parseInt(t.target.getAttribute("rel"), 10) - 1,
                      s = "true" === t.target.getAttribute("data:collapsed"),
                      a = this.w.config.chart.events.legendClick;
                    "function" == typeof a && a(this.ctx, i, this.w),
                      this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
                    var n = this.w.config.legend.markers.onClick;
                    "function" == typeof n &&
                      t.target.classList.contains("apexcharts-legend-marker") &&
                      (n(this.ctx, i, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])),
                      "treemap" !== e.config.chart.type &&
                        "heatmap" !== e.config.chart.type &&
                        !this.isBarsDistributed &&
                        e.config.legend.onItemClick.toggleDataSeries &&
                        this.legendHelpers.toggleDataSeries(i, s);
                  }
                },
              },
            ]),
            t
          );
        })(),
        ut = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
            var i = this.w;
            (this.ev = this.w.config.chart.events),
              (this.selectedClass = "apexcharts-selected"),
              (this.localeValues = this.w.globals.locale.toolbar),
              (this.minX = i.globals.minX),
              (this.maxX = i.globals.maxX);
          }
          return (
            c(t, [
              {
                key: "createToolbar",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = function () {
                      return document.createElement("div");
                    },
                    s = i();
                  if (
                    (s.setAttribute("class", "apexcharts-toolbar"),
                    (s.style.top = e.config.chart.toolbar.offsetY + "px"),
                    (s.style.right = 3 - e.config.chart.toolbar.offsetX + "px"),
                    e.globals.dom.elWrap.appendChild(s),
                    (this.elZoom = i()),
                    (this.elZoomIn = i()),
                    (this.elZoomOut = i()),
                    (this.elPan = i()),
                    (this.elSelection = i()),
                    (this.elZoomReset = i()),
                    (this.elMenuIcon = i()),
                    (this.elMenu = i()),
                    (this.elCustomIcons = []),
                    (this.t = e.config.chart.toolbar.tools),
                    Array.isArray(this.t.customIcons))
                  )
                    for (var a = 0; a < this.t.customIcons.length; a++) this.elCustomIcons.push(i());
                  var n = [],
                    r = function (i, s, a) {
                      var r = i.toLowerCase();
                      t.t[r] &&
                        e.config.chart.zoom.enabled &&
                        n.push({
                          el: s,
                          icon: "string" == typeof t.t[r] ? t.t[r] : a,
                          title: t.localeValues[i],
                          class: "apexcharts-".concat(r, "-icon"),
                        });
                    };
                  r(
                    "zoomIn",
                    this.elZoomIn,
                    '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'
                  ),
                    r(
                      "zoomOut",
                      this.elZoomOut,
                      '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'
                    );
                  var o = function (i) {
                    t.t[i] &&
                      e.config.chart[i].enabled &&
                      n.push({
                        el: "zoom" === i ? t.elZoom : t.elSelection,
                        icon:
                          "string" == typeof t.t[i]
                            ? t.t[i]
                            : "zoom" === i
                            ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>'
                            : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',
                        title: t.localeValues["zoom" === i ? "selectionZoom" : "selection"],
                        class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i, "-icon"),
                      });
                  };
                  o("zoom"),
                    o("selection"),
                    this.t.pan &&
                      e.config.chart.zoom.enabled &&
                      n.push({
                        el: this.elPan,
                        icon:
                          "string" == typeof this.t.pan
                            ? this.t.pan
                            : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',
                        title: this.localeValues.pan,
                        class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon",
                      }),
                    r(
                      "reset",
                      this.elZoomReset,
                      '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'
                    ),
                    this.t.download &&
                      n.push({
                        el: this.elMenuIcon,
                        icon:
                          "string" == typeof this.t.download
                            ? this.t.download
                            : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',
                        title: this.localeValues.menu,
                        class: "apexcharts-menu-icon",
                      });
                  for (var l = 0; l < this.elCustomIcons.length; l++)
                    n.push({
                      el: this.elCustomIcons[l],
                      icon: this.t.customIcons[l].icon,
                      title: this.t.customIcons[l].title,
                      index: this.t.customIcons[l].index,
                      class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l].class,
                    });
                  n.forEach(function (t, e) {
                    t.index && b.moveIndexInArray(n, e, t.index);
                  });
                  for (var c = 0; c < n.length; c++)
                    k.setAttrs(n[c].el, { class: n[c].class, title: n[c].title }),
                      (n[c].el.innerHTML = n[c].icon),
                      s.appendChild(n[c].el);
                  this._createHamburgerMenu(s),
                    e.globals.zoomEnabled
                      ? this.elZoom.classList.add(this.selectedClass)
                      : e.globals.panEnabled
                      ? this.elPan.classList.add(this.selectedClass)
                      : e.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass),
                    this.addToolbarEventListeners();
                },
              },
              {
                key: "_createHamburgerMenu",
                value: function (t) {
                  (this.elMenuItems = []),
                    t.appendChild(this.elMenu),
                    k.setAttrs(this.elMenu, { class: "apexcharts-menu" });
                  var e = [
                    { name: "exportSVG", title: this.localeValues.exportToSVG },
                    { name: "exportPNG", title: this.localeValues.exportToPNG },
                    { name: "exportCSV", title: this.localeValues.exportToCSV },
                  ];
                  this.w.globals.allSeriesHasEqualX || e.splice(2, 1);
                  for (var i = 0; i < e.length; i++)
                    this.elMenuItems.push(document.createElement("div")),
                      (this.elMenuItems[i].innerHTML = e[i].title),
                      k.setAttrs(this.elMenuItems[i], {
                        class: "apexcharts-menu-item ".concat(e[i].name),
                        title: e[i].title,
                      }),
                      this.elMenu.appendChild(this.elMenuItems[i]);
                },
              },
              {
                key: "addToolbarEventListeners",
                value: function () {
                  var t = this;
                  this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)),
                    this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")),
                    this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")),
                    this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)),
                    this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)),
                    this.elPan.addEventListener("click", this.togglePanning.bind(this)),
                    this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)),
                    this.elMenuItems.forEach(function (e) {
                      e.classList.contains("exportSVG")
                        ? e.addEventListener("click", t.handleDownload.bind(t, "svg"))
                        : e.classList.contains("exportPNG")
                        ? e.addEventListener("click", t.handleDownload.bind(t, "png"))
                        : e.classList.contains("exportCSV") &&
                          e.addEventListener("click", t.handleDownload.bind(t, "csv"));
                    });
                  for (var e = 0; e < this.t.customIcons.length; e++)
                    this.elCustomIcons[e].addEventListener(
                      "click",
                      this.t.customIcons[e].click.bind(this, this.ctx, this.ctx.w)
                    );
                },
              },
              {
                key: "toggleZoomSelection",
                value: function (t) {
                  this.ctx.getSyncedCharts().forEach(function (e) {
                    e.ctx.toolbar.toggleOtherControls();
                    var i = "selection" === t ? e.ctx.toolbar.elSelection : e.ctx.toolbar.elZoom,
                      s = "selection" === t ? "selectionEnabled" : "zoomEnabled";
                    (e.w.globals[s] = !e.w.globals[s]),
                      i.classList.contains(e.ctx.toolbar.selectedClass)
                        ? i.classList.remove(e.ctx.toolbar.selectedClass)
                        : i.classList.add(e.ctx.toolbar.selectedClass);
                  });
                },
              },
              {
                key: "getToolbarIconsReference",
                value: function () {
                  var t = this.w;
                  this.elZoom || (this.elZoom = t.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")),
                    this.elPan || (this.elPan = t.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")),
                    this.elSelection ||
                      (this.elSelection = t.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
                },
              },
              {
                key: "enableZoomPanFromToolbar",
                value: function (t) {
                  this.toggleOtherControls(),
                    "pan" === t ? (this.w.globals.panEnabled = !0) : (this.w.globals.zoomEnabled = !0);
                  var e = "pan" === t ? this.elPan : this.elZoom,
                    i = "pan" === t ? this.elZoom : this.elPan;
                  e && e.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass);
                },
              },
              {
                key: "togglePanning",
                value: function () {
                  this.ctx.getSyncedCharts().forEach(function (t) {
                    t.ctx.toolbar.toggleOtherControls(),
                      (t.w.globals.panEnabled = !t.w.globals.panEnabled),
                      t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass)
                        ? t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass)
                        : t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass);
                  });
                },
              },
              {
                key: "toggleOtherControls",
                value: function () {
                  var t = this,
                    e = this.w;
                  (e.globals.panEnabled = !1),
                    (e.globals.zoomEnabled = !1),
                    (e.globals.selectionEnabled = !1),
                    this.getToolbarIconsReference(),
                    [this.elPan, this.elSelection, this.elZoom].forEach(function (e) {
                      e && e.classList.remove(t.selectedClass);
                    });
                },
              },
              {
                key: "handleZoomIn",
                value: function () {
                  var t = this.w;
                  t.globals.isRangeBar && ((this.minX = t.globals.minY), (this.maxX = t.globals.maxY));
                  var e = (this.minX + this.maxX) / 2,
                    i = (this.minX + e) / 2,
                    s = (this.maxX + e) / 2,
                    a = this._getNewMinXMaxX(i, s);
                  t.globals.disableZoomIn || this.zoomUpdateOptions(a.minX, a.maxX);
                },
              },
              {
                key: "handleZoomOut",
                value: function () {
                  var t = this.w;
                  if (
                    (t.globals.isRangeBar && ((this.minX = t.globals.minY), (this.maxX = t.globals.maxY)),
                    !("datetime" === t.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3))
                  ) {
                    var e = (this.minX + this.maxX) / 2,
                      i = this.minX - (e - this.minX),
                      s = this.maxX - (e - this.maxX),
                      a = this._getNewMinXMaxX(i, s);
                    t.globals.disableZoomOut || this.zoomUpdateOptions(a.minX, a.maxX);
                  }
                },
              },
              {
                key: "_getNewMinXMaxX",
                value: function (t, e) {
                  var i = this.w.config.xaxis.convertedCatToNumeric;
                  return { minX: i ? Math.floor(t) : t, maxX: i ? Math.floor(e) : e };
                },
              },
              {
                key: "zoomUpdateOptions",
                value: function (t, e) {
                  var i = this.w;
                  if (void 0 !== t || void 0 !== e) {
                    if (
                      !(
                        i.config.xaxis.convertedCatToNumeric &&
                        (t < 1 && ((t = 1), (e = i.globals.dataPoints)), e - t < 2)
                      )
                    ) {
                      var s = { min: t, max: e },
                        a = this.getBeforeZoomRange(s);
                      a && (s = a.xaxis);
                      var n = { xaxis: s },
                        r = b.clone(i.globals.initialConfig.yaxis);
                      i.config.chart.zoom.autoScaleYaxis && (r = new q(this.ctx).autoScaleY(this.ctx, r, { xaxis: s })),
                        i.config.chart.group || (n.yaxis = r),
                        (this.w.globals.zoomed = !0),
                        this.ctx.updateHelpers._updateOptions(
                          n,
                          !1,
                          this.w.config.chart.animations.dynamicAnimation.enabled
                        ),
                        this.zoomCallback(s, r);
                    }
                  } else this.handleZoomReset();
                },
              },
              {
                key: "zoomCallback",
                value: function (t, e) {
                  "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, { xaxis: t, yaxis: e });
                },
              },
              {
                key: "getBeforeZoomRange",
                value: function (t, e) {
                  var i = null;
                  return (
                    "function" == typeof this.ev.beforeZoom && (i = this.ev.beforeZoom(this, { xaxis: t, yaxis: e })), i
                  );
                },
              },
              {
                key: "toggleMenu",
                value: function () {
                  var t = this;
                  window.setTimeout(function () {
                    t.elMenu.classList.contains("apexcharts-menu-open")
                      ? t.elMenu.classList.remove("apexcharts-menu-open")
                      : t.elMenu.classList.add("apexcharts-menu-open");
                  }, 0);
                },
              },
              {
                key: "handleDownload",
                value: function (t) {
                  var e = this.w,
                    i = new j(this.ctx);
                  switch (t) {
                    case "svg":
                      i.exportToSVG(this.ctx);
                      break;
                    case "png":
                      i.exportToPng(this.ctx);
                      break;
                    case "csv":
                      i.exportToCSV({
                        series: e.config.series,
                        columnDelimiter: e.config.chart.toolbar.export.csv.columnDelimiter,
                      });
                  }
                },
              },
              {
                key: "handleZoomReset",
                value: function (t) {
                  this.ctx.getSyncedCharts().forEach(function (t) {
                    var e = t.w;
                    if (
                      ((e.globals.lastXAxis.min = void 0),
                      (e.globals.lastXAxis.max = void 0),
                      t.updateHelpers.revertDefaultAxisMinMax(),
                      "function" == typeof e.config.chart.events.beforeResetZoom)
                    ) {
                      var i = e.config.chart.events.beforeResetZoom(t, e);
                      i && t.updateHelpers.revertDefaultAxisMinMax(i);
                    }
                    "function" == typeof e.config.chart.events.zoomed &&
                      t.ctx.toolbar.zoomCallback({ min: e.config.xaxis.min, max: e.config.xaxis.max }),
                      (e.globals.zoomed = !1);
                    var s = t.ctx.series.emptyCollapsedSeries(b.clone(e.globals.initialSeries));
                    t.updateHelpers._updateSeries(s, e.config.chart.animations.dynamicAnimation.enabled);
                  });
                },
              },
              {
                key: "destroy",
                value: function () {
                  (this.elZoom = null),
                    (this.elZoomIn = null),
                    (this.elZoomOut = null),
                    (this.elPan = null),
                    (this.elSelection = null),
                    (this.elZoomReset = null),
                    (this.elMenuIcon = null);
                },
              },
            ]),
            t
          );
        })(),
        pt = (function (t) {
          d(i, ut);
          var e = f(i);
          function i(t) {
            var s;
            return (
              o(this, i),
              ((s = e.call(this, t)).ctx = t),
              (s.w = t.w),
              (s.dragged = !1),
              (s.graphics = new k(s.ctx)),
              (s.eventList = [
                "mousedown",
                "mouseleave",
                "mousemove",
                "touchstart",
                "touchmove",
                "mouseup",
                "touchend",
              ]),
              (s.clientX = 0),
              (s.clientY = 0),
              (s.startX = 0),
              (s.endX = 0),
              (s.dragX = 0),
              (s.startY = 0),
              (s.endY = 0),
              (s.dragY = 0),
              (s.moveDirection = "none"),
              s
            );
          }
          return (
            c(i, [
              {
                key: "init",
                value: function (t) {
                  var e = this,
                    i = t.xyRatios,
                    s = this.w,
                    a = this;
                  (this.xyRatios = i),
                    (this.zoomRect = this.graphics.drawRect(0, 0, 0, 0)),
                    (this.selectionRect = this.graphics.drawRect(0, 0, 0, 0)),
                    (this.gridRect = s.globals.dom.baseEl.querySelector(".apexcharts-grid")),
                    this.zoomRect.node.classList.add("apexcharts-zoom-rect"),
                    this.selectionRect.node.classList.add("apexcharts-selection-rect"),
                    s.globals.dom.elGraphical.add(this.zoomRect),
                    s.globals.dom.elGraphical.add(this.selectionRect),
                    "x" === s.config.chart.selection.type
                      ? (this.slDraggableRect = this.selectionRect
                          .draggable({ minX: 0, minY: 0, maxX: s.globals.gridWidth, maxY: s.globals.gridHeight })
                          .on("dragmove", this.selectionDragging.bind(this, "dragging")))
                      : "y" === s.config.chart.selection.type
                      ? (this.slDraggableRect = this.selectionRect
                          .draggable({ minX: 0, maxX: s.globals.gridWidth })
                          .on("dragmove", this.selectionDragging.bind(this, "dragging")))
                      : (this.slDraggableRect = this.selectionRect
                          .draggable()
                          .on("dragmove", this.selectionDragging.bind(this, "dragging"))),
                    this.preselectedSelection(),
                    (this.hoverArea = s.globals.dom.baseEl.querySelector(
                      "".concat(s.globals.chartClass, " .apexcharts-svg")
                    )),
                    this.hoverArea.classList.add("apexcharts-zoomable"),
                    this.eventList.forEach(function (t) {
                      e.hoverArea.addEventListener(t, a.svgMouseEvents.bind(a, i), { capture: !1, passive: !0 });
                    });
                },
              },
              {
                key: "destroy",
                value: function () {
                  this.slDraggableRect &&
                    (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()),
                    (this.selectionRect = null),
                    (this.zoomRect = null),
                    (this.gridRect = null);
                },
              },
              {
                key: "svgMouseEvents",
                value: function (t, e) {
                  var i = this.w,
                    s = this,
                    a = this.ctx.toolbar,
                    n = i.globals.zoomEnabled ? i.config.chart.zoom.type : i.config.chart.selection.type,
                    r = i.config.chart.toolbar.autoSelected;
                  if (
                    (e.shiftKey
                      ? ((this.shiftWasPressed = !0), a.enableZoomPanFromToolbar("pan" === r ? "zoom" : "pan"))
                      : this.shiftWasPressed && (a.enableZoomPanFromToolbar(r), (this.shiftWasPressed = !1)),
                    e.target)
                  ) {
                    var o,
                      l = e.target.classList;
                    if (
                      (e.target.parentNode && null !== e.target.parentNode && (o = e.target.parentNode.classList),
                      !(
                        l.contains("apexcharts-selection-rect") ||
                        l.contains("apexcharts-legend-marker") ||
                        l.contains("apexcharts-legend-text") ||
                        (o && o.contains("apexcharts-toolbar"))
                      ))
                    ) {
                      if (
                        ((s.clientX =
                          "touchmove" === e.type || "touchstart" === e.type
                            ? e.touches[0].clientX
                            : "touchend" === e.type
                            ? e.changedTouches[0].clientX
                            : e.clientX),
                        (s.clientY =
                          "touchmove" === e.type || "touchstart" === e.type
                            ? e.touches[0].clientY
                            : "touchend" === e.type
                            ? e.changedTouches[0].clientY
                            : e.clientY),
                        "mousedown" === e.type && 1 === e.which)
                      ) {
                        var c = s.gridRect.getBoundingClientRect();
                        (s.startX = s.clientX - c.left),
                          (s.startY = s.clientY - c.top),
                          (s.dragged = !1),
                          (s.w.globals.mousedown = !0);
                      }
                      if (
                        ((("mousemove" === e.type && 1 === e.which) || "touchmove" === e.type) &&
                          ((s.dragged = !0),
                          i.globals.panEnabled
                            ? ((i.globals.selection = null),
                              s.w.globals.mousedown && s.panDragging({ context: s, zoomtype: n, xyRatios: t }))
                            : ((s.w.globals.mousedown && i.globals.zoomEnabled) ||
                                (s.w.globals.mousedown && i.globals.selectionEnabled)) &&
                              (s.selection = s.selectionDrawing({ context: s, zoomtype: n }))),
                        "mouseup" === e.type || "touchend" === e.type || "mouseleave" === e.type)
                      ) {
                        var h = s.gridRect.getBoundingClientRect();
                        s.w.globals.mousedown &&
                          ((s.endX = s.clientX - h.left),
                          (s.endY = s.clientY - h.top),
                          (s.dragX = Math.abs(s.endX - s.startX)),
                          (s.dragY = Math.abs(s.endY - s.startY)),
                          (i.globals.zoomEnabled || i.globals.selectionEnabled) &&
                            s.selectionDrawn({ context: s, zoomtype: n }),
                          i.globals.panEnabled && i.config.xaxis.convertedCatToNumeric && s.delayedPanScrolled()),
                          i.globals.zoomEnabled && s.hideSelectionRect(this.selectionRect),
                          (s.dragged = !1),
                          (s.w.globals.mousedown = !1);
                      }
                      this.makeSelectionRectDraggable();
                    }
                  }
                },
              },
              {
                key: "makeSelectionRectDraggable",
                value: function () {
                  var t = this.w;
                  if (this.selectionRect) {
                    var e = this.selectionRect.node.getBoundingClientRect();
                    e.width > 0 &&
                      e.height > 0 &&
                      this.slDraggableRect
                        .selectize({ points: "l, r", pointSize: 8, pointType: "rect" })
                        .resize({
                          constraint: { minX: 0, minY: 0, maxX: t.globals.gridWidth, maxY: t.globals.gridHeight },
                        })
                        .on("resizing", this.selectionDragging.bind(this, "resizing"));
                  }
                },
              },
              {
                key: "preselectedSelection",
                value: function () {
                  var t = this.w,
                    e = this.xyRatios;
                  if (!t.globals.zoomEnabled)
                    if (void 0 !== t.globals.selection && null !== t.globals.selection)
                      this.drawSelectionRect(t.globals.selection);
                    else if (
                      void 0 !== t.config.chart.selection.xaxis.min &&
                      void 0 !== t.config.chart.selection.xaxis.max
                    ) {
                      var i = (t.config.chart.selection.xaxis.min - t.globals.minX) / e.xRatio,
                        s = {
                          x: i,
                          y: 0,
                          width:
                            t.globals.gridWidth - (t.globals.maxX - t.config.chart.selection.xaxis.max) / e.xRatio - i,
                          height: t.globals.gridHeight,
                          translateX: 0,
                          translateY: 0,
                          selectionEnabled: !0,
                        };
                      this.drawSelectionRect(s),
                        this.makeSelectionRectDraggable(),
                        "function" == typeof t.config.chart.events.selection &&
                          t.config.chart.events.selection(this.ctx, {
                            xaxis: { min: t.config.chart.selection.xaxis.min, max: t.config.chart.selection.xaxis.max },
                            yaxis: {},
                          });
                    }
                },
              },
              {
                key: "drawSelectionRect",
                value: function (t) {
                  var e = t.x,
                    i = t.y,
                    s = t.width,
                    a = t.height,
                    n = t.translateX,
                    r = void 0 === n ? 0 : n,
                    o = t.translateY,
                    l = void 0 === o ? 0 : o,
                    c = this.w,
                    h = this.zoomRect,
                    d = this.selectionRect;
                  if (this.dragged || null !== c.globals.selection) {
                    var u = { transform: "translate(" + r + ", " + l + ")" };
                    c.globals.zoomEnabled &&
                      this.dragged &&
                      (s < 0 && (s = 1),
                      h.attr({
                        x: e,
                        y: i,
                        width: s,
                        height: a,
                        fill: c.config.chart.zoom.zoomedArea.fill.color,
                        "fill-opacity": c.config.chart.zoom.zoomedArea.fill.opacity,
                        stroke: c.config.chart.zoom.zoomedArea.stroke.color,
                        "stroke-width": c.config.chart.zoom.zoomedArea.stroke.width,
                        "stroke-opacity": c.config.chart.zoom.zoomedArea.stroke.opacity,
                      }),
                      k.setAttrs(h.node, u)),
                      c.globals.selectionEnabled &&
                        (d.attr({
                          x: e,
                          y: i,
                          width: s > 0 ? s : 0,
                          height: a > 0 ? a : 0,
                          fill: c.config.chart.selection.fill.color,
                          "fill-opacity": c.config.chart.selection.fill.opacity,
                          stroke: c.config.chart.selection.stroke.color,
                          "stroke-width": c.config.chart.selection.stroke.width,
                          "stroke-dasharray": c.config.chart.selection.stroke.dashArray,
                          "stroke-opacity": c.config.chart.selection.stroke.opacity,
                        }),
                        k.setAttrs(d.node, u));
                  }
                },
              },
              {
                key: "hideSelectionRect",
                value: function (t) {
                  t && t.attr({ x: 0, y: 0, width: 0, height: 0 });
                },
              },
              {
                key: "selectionDrawing",
                value: function (t) {
                  var e,
                    i = t.context,
                    s = t.zoomtype,
                    a = this.w,
                    n = i,
                    r = this.gridRect.getBoundingClientRect(),
                    o = n.startX - 1,
                    l = n.startY,
                    c = !1,
                    h = !1,
                    d = n.clientX - r.left - o,
                    u = n.clientY - r.top - l;
                  return (
                    Math.abs(d + o) > a.globals.gridWidth
                      ? (d = a.globals.gridWidth - o)
                      : n.clientX - r.left < 0 && (d = o),
                    o > n.clientX - r.left && ((c = !0), (d = Math.abs(d))),
                    l > n.clientY - r.top && ((h = !0), (u = Math.abs(u))),
                    (e =
                      "x" === s
                        ? { x: c ? o - d : o, y: 0, width: d, height: a.globals.gridHeight }
                        : "y" === s
                        ? { x: 0, y: h ? l - u : l, width: a.globals.gridWidth, height: u }
                        : { x: c ? o - d : o, y: h ? l - u : l, width: d, height: u }),
                    n.drawSelectionRect(e),
                    n.selectionDragging("resizing"),
                    e
                  );
                },
              },
              {
                key: "selectionDragging",
                value: function (t, e) {
                  var i = this,
                    s = this.w,
                    a = this.xyRatios,
                    n = this.selectionRect,
                    r = 0;
                  "resizing" === t && (r = 30);
                  var o = function (t) {
                      return parseFloat(n.node.getAttribute(t));
                    },
                    l = { x: o("x"), y: o("y"), width: o("width"), height: o("height") };
                  (s.globals.selection = l),
                    "function" == typeof s.config.chart.events.selection &&
                      s.globals.selectionEnabled &&
                      (clearTimeout(this.w.globals.selectionResizeTimer),
                      (this.w.globals.selectionResizeTimer = window.setTimeout(function () {
                        var t = i.gridRect.getBoundingClientRect(),
                          e = n.node.getBoundingClientRect(),
                          r = {
                            xaxis: {
                              min: s.globals.xAxisScale.niceMin + (e.left - t.left) * a.xRatio,
                              max: s.globals.xAxisScale.niceMin + (e.right - t.left) * a.xRatio,
                            },
                            yaxis: {
                              min: s.globals.yAxisScale[0].niceMin + (t.bottom - e.bottom) * a.yRatio[0],
                              max: s.globals.yAxisScale[0].niceMax - (e.top - t.top) * a.yRatio[0],
                            },
                          };
                        s.config.chart.events.selection(i.ctx, r),
                          s.config.chart.brush.enabled &&
                            void 0 !== s.config.chart.events.brushScrolled &&
                            s.config.chart.events.brushScrolled(i.ctx, r);
                      }, r)));
                },
              },
              {
                key: "selectionDrawn",
                value: function (t) {
                  var e = t.context,
                    i = t.zoomtype,
                    s = this.w,
                    a = e,
                    n = this.xyRatios,
                    r = this.ctx.toolbar;
                  if (a.startX > a.endX) {
                    var o = a.startX;
                    (a.startX = a.endX), (a.endX = o);
                  }
                  if (a.startY > a.endY) {
                    var l = a.startY;
                    (a.startY = a.endY), (a.endY = l);
                  }
                  var c = void 0,
                    h = void 0;
                  s.globals.isRangeBar
                    ? ((c = s.globals.yAxisScale[0].niceMin + a.startX * n.invertedYRatio),
                      (h = s.globals.yAxisScale[0].niceMin + a.endX * n.invertedYRatio))
                    : ((c = s.globals.xAxisScale.niceMin + a.startX * n.xRatio),
                      (h = s.globals.xAxisScale.niceMin + a.endX * n.xRatio));
                  var d = [],
                    u = [];
                  if (
                    (s.config.yaxis.forEach(function (t, e) {
                      d.push(s.globals.yAxisScale[e].niceMax - n.yRatio[e] * a.startY),
                        u.push(s.globals.yAxisScale[e].niceMax - n.yRatio[e] * a.endY);
                    }),
                    a.dragged && (a.dragX > 10 || a.dragY > 10) && c !== h)
                  )
                    if (s.globals.zoomEnabled) {
                      var p = b.clone(s.globals.initialConfig.yaxis),
                        g = b.clone(s.globals.initialConfig.xaxis);
                      if (
                        ((s.globals.zoomed = !0),
                        s.config.xaxis.convertedCatToNumeric &&
                          ((c = Math.floor(c)),
                          (h = Math.floor(h)),
                          c < 1 && ((c = 1), (h = s.globals.dataPoints)),
                          h - c < 2 && (h = c + 1)),
                        ("xy" !== i && "x" !== i) || (g = { min: c, max: h }),
                        ("xy" !== i && "y" !== i) ||
                          p.forEach(function (t, e) {
                            (p[e].min = u[e]), (p[e].max = d[e]);
                          }),
                        s.config.chart.zoom.autoScaleYaxis)
                      ) {
                        var f = new q(a.ctx);
                        p = f.autoScaleY(a.ctx, p, { xaxis: g });
                      }
                      if (r) {
                        var m = r.getBeforeZoomRange(g, p);
                        m && ((g = m.xaxis ? m.xaxis : g), (p = m.yaxis ? m.yaxis : p));
                      }
                      var v = { xaxis: g };
                      s.config.chart.group || (v.yaxis = p),
                        a.ctx.updateHelpers._updateOptions(v, !1, a.w.config.chart.animations.dynamicAnimation.enabled),
                        "function" == typeof s.config.chart.events.zoomed && r.zoomCallback(g, p);
                    } else if (s.globals.selectionEnabled) {
                      var x,
                        y = null;
                      (x = { min: c, max: h }),
                        ("xy" !== i && "y" !== i) ||
                          (y = b.clone(s.config.yaxis)).forEach(function (t, e) {
                            (y[e].min = u[e]), (y[e].max = d[e]);
                          }),
                        (s.globals.selection = a.selection),
                        "function" == typeof s.config.chart.events.selection &&
                          s.config.chart.events.selection(a.ctx, { xaxis: x, yaxis: y });
                    }
                },
              },
              {
                key: "panDragging",
                value: function (t) {
                  var e = t.context,
                    i = this.w,
                    s = e;
                  if (void 0 !== i.globals.lastClientPosition.x) {
                    var a = i.globals.lastClientPosition.x - s.clientX,
                      n = i.globals.lastClientPosition.y - s.clientY;
                    Math.abs(a) > Math.abs(n) && a > 0
                      ? (this.moveDirection = "left")
                      : Math.abs(a) > Math.abs(n) && a < 0
                      ? (this.moveDirection = "right")
                      : Math.abs(n) > Math.abs(a) && n > 0
                      ? (this.moveDirection = "up")
                      : Math.abs(n) > Math.abs(a) && n < 0 && (this.moveDirection = "down");
                  }
                  i.globals.lastClientPosition = { x: s.clientX, y: s.clientY };
                  var r = i.globals.isRangeBar ? i.globals.minY : i.globals.minX,
                    o = i.globals.isRangeBar ? i.globals.maxY : i.globals.maxX;
                  i.config.xaxis.convertedCatToNumeric || s.panScrolled(r, o);
                },
              },
              {
                key: "delayedPanScrolled",
                value: function () {
                  var t = this.w,
                    e = t.globals.minX,
                    i = t.globals.maxX,
                    s = (t.globals.maxX - t.globals.minX) / 2;
                  "left" === this.moveDirection
                    ? ((e = t.globals.minX + s), (i = t.globals.maxX + s))
                    : "right" === this.moveDirection && ((e = t.globals.minX - s), (i = t.globals.maxX - s)),
                    (e = Math.floor(e)),
                    (i = Math.floor(i)),
                    this.updateScrolledChart({ xaxis: { min: e, max: i } }, e, i);
                },
              },
              {
                key: "panScrolled",
                value: function (t, e) {
                  var i = this.w,
                    s = this.xyRatios,
                    a = b.clone(i.globals.initialConfig.yaxis),
                    n = s.xRatio,
                    r = i.globals.minX,
                    o = i.globals.maxX;
                  i.globals.isRangeBar && ((n = s.invertedYRatio), (r = i.globals.minY), (o = i.globals.maxY)),
                    "left" === this.moveDirection
                      ? ((t = r + (i.globals.gridWidth / 15) * n), (e = o + (i.globals.gridWidth / 15) * n))
                      : "right" === this.moveDirection &&
                        ((t = r - (i.globals.gridWidth / 15) * n), (e = o - (i.globals.gridWidth / 15) * n)),
                    i.globals.isRangeBar ||
                      ((t < i.globals.initialMinX || e > i.globals.initialMaxX) && ((t = r), (e = o)));
                  var l = { min: t, max: e };
                  i.config.chart.zoom.autoScaleYaxis && (a = new q(this.ctx).autoScaleY(this.ctx, a, { xaxis: l }));
                  var c = { xaxis: { min: t, max: e } };
                  i.config.chart.group || (c.yaxis = a), this.updateScrolledChart(c, t, e);
                },
              },
              {
                key: "updateScrolledChart",
                value: function (t, e, i) {
                  var s = this.w;
                  this.ctx.updateHelpers._updateOptions(t, !1, !1),
                    "function" == typeof s.config.chart.events.scrolled &&
                      s.config.chart.events.scrolled(this.ctx, { xaxis: { min: e, max: i } });
                },
              },
            ]),
            i
          );
        })(),
        gt = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.ttCtx = e), (this.ctx = e.ctx);
          }
          return (
            c(t, [
              {
                key: "getNearestValues",
                value: function (t) {
                  var e = t.hoverArea,
                    i = t.elGrid,
                    s = t.clientX,
                    a = t.clientY,
                    n = this.w,
                    r = i.getBoundingClientRect(),
                    o = r.width,
                    l = r.height,
                    c = o / (n.globals.dataPoints - 1),
                    h = l / n.globals.dataPoints,
                    d = this.hasBars();
                  (!n.globals.comboCharts && !d) ||
                    n.config.xaxis.convertedCatToNumeric ||
                    (c = o / n.globals.dataPoints);
                  var u = s - r.left - n.globals.barPadForNumericAxis,
                    p = a - r.top;
                  u < 0 || p < 0 || u > o || p > l
                    ? (e.classList.remove("hovering-zoom"), e.classList.remove("hovering-pan"))
                    : n.globals.zoomEnabled
                    ? (e.classList.remove("hovering-pan"), e.classList.add("hovering-zoom"))
                    : n.globals.panEnabled && (e.classList.remove("hovering-zoom"), e.classList.add("hovering-pan"));
                  var g = Math.round(u / c),
                    f = Math.floor(p / h);
                  d && !n.config.xaxis.convertedCatToNumeric && ((g = Math.ceil(u / c)), (g -= 1));
                  var m = null,
                    v = null,
                    x = [],
                    y = [];
                  if (
                    (n.globals.seriesXvalues.forEach(function (t) {
                      x.push([t[0] + 1e-6].concat(t));
                    }),
                    n.globals.seriesYvalues.forEach(function (t) {
                      y.push([t[0] + 1e-6].concat(t));
                    }),
                    (x = x.map(function (t) {
                      return t.filter(function (t) {
                        return b.isNumber(t);
                      });
                    })),
                    (y = y.map(function (t) {
                      return t.filter(function (t) {
                        return b.isNumber(t);
                      });
                    })),
                    n.globals.isXNumeric)
                  ) {
                    var w = this.ttCtx.getElGrid().getBoundingClientRect(),
                      k = u * (w.width / o),
                      S = p * (w.height / l);
                    (m = (v = this.closestInMultiArray(k, S, x, y)).index),
                      (g = v.j),
                      null !== m && ((x = n.globals.seriesXvalues[m]), (g = (v = this.closestInArray(k, x)).index));
                  }
                  return (
                    (n.globals.capturedSeriesIndex = null === m ? -1 : m),
                    (!g || g < 1) && (g = 0),
                    n.globals.isBarHorizontal
                      ? (n.globals.capturedDataPointIndex = f)
                      : (n.globals.capturedDataPointIndex = g),
                    { capturedSeries: m, j: n.globals.isBarHorizontal ? f : g, hoverX: u, hoverY: p }
                  );
                },
              },
              {
                key: "closestInMultiArray",
                value: function (t, e, i, s) {
                  var a = this.w,
                    n = 0,
                    r = null,
                    o = -1;
                  a.globals.series.length > 1 ? (n = this.getFirstActiveXArray(i)) : (r = 0);
                  var l = i[n][0],
                    c = Math.abs(t - l);
                  if (
                    (i.forEach(function (e) {
                      e.forEach(function (e, i) {
                        var s = Math.abs(t - e);
                        s < c && ((c = s), (o = i));
                      });
                    }),
                    -1 !== o)
                  ) {
                    var h = s[n][o],
                      d = Math.abs(e - h);
                    (r = n),
                      s.forEach(function (t, i) {
                        var s = Math.abs(e - t[o]);
                        s < d && ((d = s), (r = i));
                      });
                  }
                  return { index: r, j: o };
                },
              },
              {
                key: "getFirstActiveXArray",
                value: function (t) {
                  for (
                    var e = this.w,
                      i = 0,
                      s = t.map(function (t, e) {
                        return t.length > 0 ? e : -1;
                      }),
                      a = 0;
                    a < s.length;
                    a++
                  )
                    if (
                      -1 !== s[a] &&
                      -1 === e.globals.collapsedSeriesIndices.indexOf(a) &&
                      -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(a)
                    ) {
                      i = s[a];
                      break;
                    }
                  return i;
                },
              },
              {
                key: "closestInArray",
                value: function (t, e) {
                  for (var i = e[0], s = null, a = Math.abs(t - i), n = 0; n < e.length; n++) {
                    var r = Math.abs(t - e[n]);
                    r < a && ((a = r), (s = n));
                  }
                  return { index: s };
                },
              },
              {
                key: "isXoverlap",
                value: function (t) {
                  var e = [],
                    i = this.w.globals.seriesX.filter(function (t) {
                      return void 0 !== t[0];
                    });
                  if (i.length > 0)
                    for (var s = 0; s < i.length - 1; s++)
                      void 0 !== i[s][t] && void 0 !== i[s + 1][t] && i[s][t] !== i[s + 1][t] && e.push("unEqual");
                  return 0 === e.length;
                },
              },
              {
                key: "isInitialSeriesSameLen",
                value: function () {
                  for (var t = !0, e = this.w.globals.initialSeries, i = 0; i < e.length - 1; i++)
                    if (e[i].data.length !== e[i + 1].data.length) {
                      t = !1;
                      break;
                    }
                  return t;
                },
              },
              {
                key: "getBarsHeight",
                value: function (t) {
                  return m(t).reduce(function (t, e) {
                    return t + e.getBBox().height;
                  }, 0);
                },
              },
              {
                key: "getElMarkers",
                value: function () {
                  return this.w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series-markers");
                },
              },
              {
                key: "getAllMarkers",
                value: function () {
                  var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
                  (t = m(t)).sort(function (t, e) {
                    var i = Number(t.getAttribute("data:realIndex")),
                      s = Number(e.getAttribute("data:realIndex"));
                    return s < i ? 1 : s > i ? -1 : 0;
                  });
                  var e = [];
                  return (
                    t.forEach(function (t) {
                      e.push(t.querySelector(".apexcharts-marker"));
                    }),
                    e
                  );
                },
              },
              {
                key: "hasMarkers",
                value: function () {
                  return this.getElMarkers().length > 0;
                },
              },
              {
                key: "getElBars",
                value: function () {
                  return this.w.globals.dom.baseEl.querySelectorAll(
                    ".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series"
                  );
                },
              },
              {
                key: "hasBars",
                value: function () {
                  return this.getElBars().length > 0;
                },
              },
              {
                key: "getHoverMarkerSize",
                value: function (t) {
                  var e = this.w,
                    i = e.config.markers.hover.size;
                  return void 0 === i && (i = e.globals.markers.size[t] + e.config.markers.hover.sizeOffset), i;
                },
              },
              {
                key: "toggleAllTooltipSeriesGroups",
                value: function (t) {
                  var e = this.w,
                    i = this.ttCtx;
                  0 === i.allTooltipSeriesGroups.length &&
                    (i.allTooltipSeriesGroups = e.globals.dom.baseEl.querySelectorAll(
                      ".apexcharts-tooltip-series-group"
                    ));
                  for (var s = i.allTooltipSeriesGroups, a = 0; a < s.length; a++)
                    "enable" === t
                      ? (s[a].classList.add("apexcharts-active"), (s[a].style.display = e.config.tooltip.items.display))
                      : (s[a].classList.remove("apexcharts-active"), (s[a].style.display = "none"));
                },
              },
            ]),
            t
          );
        })(),
        ft = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.ctx = e.ctx), (this.ttCtx = e), (this.tooltipUtil = new gt(e));
          }
          return (
            c(t, [
              {
                key: "drawSeriesTexts",
                value: function (t) {
                  var e = t.shared,
                    i = void 0 === e || e,
                    s = t.ttItems,
                    a = t.i,
                    n = void 0 === a ? 0 : a,
                    r = t.j,
                    o = void 0 === r ? null : r,
                    l = t.y1,
                    c = t.y2,
                    h = t.e,
                    d = this.w;
                  void 0 !== d.config.tooltip.custom
                    ? this.handleCustomTooltip({ i: n, j: o, y1: l, y2: c, w: d })
                    : this.toggleActiveInactiveSeries(i);
                  var u = this.getValuesToPrint({ i: n, j: o });
                  this.printLabels({ i: n, j: o, values: u, ttItems: s, shared: i, e: h });
                  var p = this.ttCtx.getElTooltip();
                  (this.ttCtx.tooltipRect.ttWidth = p.getBoundingClientRect().width),
                    (this.ttCtx.tooltipRect.ttHeight = p.getBoundingClientRect().height);
                },
              },
              {
                key: "printLabels",
                value: function (t) {
                  var e,
                    i = this,
                    s = t.i,
                    a = t.j,
                    r = t.values,
                    o = t.ttItems,
                    l = t.shared,
                    c = t.e,
                    h = this.w,
                    d = [],
                    u = function (t) {
                      return (
                        h.globals.seriesGoals[t] &&
                        h.globals.seriesGoals[t][a] &&
                        Array.isArray(h.globals.seriesGoals[t][a])
                      );
                    },
                    p = r.xVal,
                    g = r.zVal,
                    f = r.xAxisTTVal,
                    m = "",
                    v = h.globals.colors[s];
                  null !== a && h.config.plotOptions.bar.distributed && (v = h.globals.colors[a]);
                  for (
                    var x = function (t, r) {
                        var x = i.getFormatters(s);
                        (m = i.getSeriesName({ fn: x.yLbTitleFormatter, index: s, seriesIndex: s, j: a })),
                          "treemap" === h.config.chart.type &&
                            (m = x.yLbTitleFormatter(String(h.config.series[s].data[a].x), {
                              series: h.globals.series,
                              seriesIndex: s,
                              dataPointIndex: a,
                              w: h,
                            }));
                        var b = h.config.tooltip.inverseOrder ? r : t;
                        if (h.globals.axisCharts) {
                          var y = function (t) {
                            return x.yLbFormatter(h.globals.series[t][a], {
                              series: h.globals.series,
                              seriesIndex: t,
                              dataPointIndex: a,
                              w: h,
                            });
                          };
                          if (l)
                            (x = i.getFormatters(b)),
                              (m = i.getSeriesName({ fn: x.yLbTitleFormatter, index: b, seriesIndex: s, j: a })),
                              (v = h.globals.colors[b]),
                              (e = y(b)),
                              u(b) &&
                                (d = h.globals.seriesGoals[b][a].map(function (t) {
                                  return {
                                    attrs: t,
                                    val: x.yLbFormatter(t.value, { seriesIndex: b, dataPointIndex: a, w: h }),
                                  };
                                }));
                          else {
                            var w,
                              k =
                                null == c || null === (w = c.target) || void 0 === w ? void 0 : w.getAttribute("fill");
                            k &&
                              (v =
                                -1 !== k.indexOf("url")
                                  ? document
                                      .querySelector(k.substr(4).slice(0, -1))
                                      .childNodes[0].getAttribute("stroke")
                                  : k),
                              (e = y(s)),
                              u(s) &&
                                Array.isArray(h.globals.seriesGoals[s][a]) &&
                                (d = h.globals.seriesGoals[s][a].map(function (t) {
                                  return {
                                    attrs: t,
                                    val: x.yLbFormatter(t.value, { seriesIndex: s, dataPointIndex: a, w: h }),
                                  };
                                }));
                          }
                        }
                        null === a &&
                          (e = x.yLbFormatter(
                            h.globals.series[s],
                            n(n({}, h), {}, { seriesIndex: s, dataPointIndex: s })
                          )),
                          i.DOMHandling({
                            i: s,
                            t: b,
                            j: a,
                            ttItems: o,
                            values: { val: e, goalVals: d, xVal: p, xAxisTTVal: f, zVal: g },
                            seriesName: m,
                            shared: l,
                            pColor: v,
                          });
                      },
                      b = 0,
                      y = h.globals.series.length - 1;
                    b < h.globals.series.length;
                    b++, y--
                  )
                    x(b, y);
                },
              },
              {
                key: "getFormatters",
                value: function (t) {
                  var e,
                    i = this.w,
                    s = i.globals.yLabelFormatters[t];
                  return (
                    void 0 !== i.globals.ttVal
                      ? Array.isArray(i.globals.ttVal)
                        ? ((s = i.globals.ttVal[t] && i.globals.ttVal[t].formatter),
                          (e = i.globals.ttVal[t] && i.globals.ttVal[t].title && i.globals.ttVal[t].title.formatter))
                        : ((s = i.globals.ttVal.formatter),
                          "function" == typeof i.globals.ttVal.title.formatter && (e = i.globals.ttVal.title.formatter))
                      : (e = i.config.tooltip.y.title.formatter),
                    "function" != typeof s &&
                      (s = i.globals.yLabelFormatters[0]
                        ? i.globals.yLabelFormatters[0]
                        : function (t) {
                            return t;
                          }),
                    "function" != typeof e &&
                      (e = function (t) {
                        return t;
                      }),
                    { yLbFormatter: s, yLbTitleFormatter: e }
                  );
                },
              },
              {
                key: "getSeriesName",
                value: function (t) {
                  var e = t.fn,
                    i = t.index,
                    s = t.seriesIndex,
                    a = t.j,
                    n = this.w;
                  return e(String(n.globals.seriesNames[i]), {
                    series: n.globals.series,
                    seriesIndex: s,
                    dataPointIndex: a,
                    w: n,
                  });
                },
              },
              {
                key: "DOMHandling",
                value: function (t) {
                  t.i;
                  var e = t.t,
                    i = t.j,
                    s = t.ttItems,
                    a = t.values,
                    n = t.seriesName,
                    r = t.shared,
                    o = t.pColor,
                    l = this.w,
                    c = this.ttCtx,
                    h = a.val,
                    d = a.goalVals,
                    u = a.xVal,
                    p = a.xAxisTTVal,
                    g = a.zVal,
                    f = null;
                  (f = s[e].children),
                    l.config.tooltip.fillSeriesColor &&
                      ((s[e].style.backgroundColor = o), (f[0].style.display = "none")),
                    c.showTooltipTitle &&
                      (null === c.tooltipTitle &&
                        (c.tooltipTitle = l.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")),
                      (c.tooltipTitle.innerHTML = u)),
                    c.isXAxisTooltipEnabled && (c.xaxisTooltipText.innerHTML = "" !== p ? p : u);
                  var m = s[e].querySelector(".apexcharts-tooltip-text-y-label");
                  m && (m.innerHTML = n || "");
                  var v = s[e].querySelector(".apexcharts-tooltip-text-y-value");
                  v && (v.innerHTML = void 0 !== h ? h : ""),
                    f[0] &&
                      f[0].classList.contains("apexcharts-tooltip-marker") &&
                      (l.config.tooltip.marker.fillColors &&
                        Array.isArray(l.config.tooltip.marker.fillColors) &&
                        (o = l.config.tooltip.marker.fillColors[e]),
                      (f[0].style.backgroundColor = o)),
                    l.config.tooltip.marker.show || (f[0].style.display = "none");
                  var x = s[e].querySelector(".apexcharts-tooltip-text-goals-label"),
                    b = s[e].querySelector(".apexcharts-tooltip-text-goals-value");
                  if (d.length && l.globals.seriesGoals[e]) {
                    var y = function () {
                      var t = "<div >",
                        e = "<div>";
                      d.forEach(function (i, s) {
                        (t +=
                          ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '
                            .concat(i.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ')
                            .concat(i.attrs.name, "</div>")),
                          (e += "<div>".concat(i.val, "</div>"));
                      }),
                        (x.innerHTML = t + "</div>"),
                        (b.innerHTML = e + "</div>");
                    };
                    r
                      ? l.globals.seriesGoals[e][i] && Array.isArray(l.globals.seriesGoals[e][i])
                        ? y()
                        : ((x.innerHTML = ""), (b.innerHTML = ""))
                      : y();
                  } else (x.innerHTML = ""), (b.innerHTML = "");
                  null !== g &&
                    ((s[e].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l.config.tooltip.z.title),
                    (s[e].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== g ? g : "")),
                    r &&
                      f[0] &&
                      (null == h ||
                      l.globals.ancillaryCollapsedSeriesIndices.indexOf(e) > -1 ||
                      l.globals.collapsedSeriesIndices.indexOf(e) > -1
                        ? (f[0].parentNode.style.display = "none")
                        : (f[0].parentNode.style.display = l.config.tooltip.items.display));
                },
              },
              {
                key: "toggleActiveInactiveSeries",
                value: function (t) {
                  var e = this.w;
                  if (t) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
                  else {
                    this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
                    var i = e.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
                    i && (i.classList.add("apexcharts-active"), (i.style.display = e.config.tooltip.items.display));
                  }
                },
              },
              {
                key: "getValuesToPrint",
                value: function (t) {
                  var e = t.i,
                    i = t.j,
                    s = this.w,
                    a = this.ctx.series.filteredSeriesX(),
                    n = "",
                    r = "",
                    o = null,
                    l = null,
                    c = { series: s.globals.series, seriesIndex: e, dataPointIndex: i, w: s },
                    h = s.globals.ttZFormatter;
                  null === i
                    ? (l = s.globals.series[e])
                    : s.globals.isXNumeric && "treemap" !== s.config.chart.type
                    ? ((n = a[e][i]), 0 === a[e].length && (n = a[this.tooltipUtil.getFirstActiveXArray(a)][i]))
                    : (n = void 0 !== s.globals.labels[i] ? s.globals.labels[i] : "");
                  var d = n;
                  return (
                    (n =
                      s.globals.isXNumeric && "datetime" === s.config.xaxis.type
                        ? new $(this.ctx).xLabelFormat(s.globals.ttKeyFormatter, d, d, {
                            i: void 0,
                            dateFormatter: new O(this.ctx).formatDate,
                            w: this.w,
                          })
                        : s.globals.isBarHorizontal
                        ? s.globals.yLabelFormatters[0](d, c)
                        : s.globals.xLabelFormatter(d, c)),
                    void 0 !== s.config.tooltip.x.formatter && (n = s.globals.ttKeyFormatter(d, c)),
                    s.globals.seriesZ.length > 0 &&
                      s.globals.seriesZ[e].length > 0 &&
                      (o = h(s.globals.seriesZ[e][i], s)),
                    (r =
                      "function" == typeof s.config.xaxis.tooltip.formatter
                        ? s.globals.xaxisTooltipFormatter(d, c)
                        : n),
                    {
                      val: Array.isArray(l) ? l.join(" ") : l,
                      xVal: Array.isArray(n) ? n.join(" ") : n,
                      xAxisTTVal: Array.isArray(r) ? r.join(" ") : r,
                      zVal: o,
                    }
                  );
                },
              },
              {
                key: "handleCustomTooltip",
                value: function (t) {
                  var e = t.i,
                    i = t.j,
                    s = t.y1,
                    a = t.y2,
                    n = t.w,
                    r = this.ttCtx.getElTooltip(),
                    o = n.config.tooltip.custom;
                  Array.isArray(o) && o[e] && (o = o[e]),
                    (r.innerHTML = o({
                      ctx: this.ctx,
                      series: n.globals.series,
                      seriesIndex: e,
                      dataPointIndex: i,
                      y1: s,
                      y2: a,
                      w: n,
                    }));
                },
              },
            ]),
            t
          );
        })(),
        mt = (function () {
          function t(e) {
            o(this, t), (this.ttCtx = e), (this.ctx = e.ctx), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "moveXCrosshairs",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                    i = this.ttCtx,
                    s = this.w,
                    a = i.getElXCrosshairs(),
                    n = t - i.xcrosshairsWidth / 2,
                    r = s.globals.labels.slice().length;
                  if (
                    (null !== e && (n = (s.globals.gridWidth / r) * e),
                    null === a ||
                      s.globals.isBarHorizontal ||
                      (a.setAttribute("x", n),
                      a.setAttribute("x1", n),
                      a.setAttribute("x2", n),
                      a.setAttribute("y2", s.globals.gridHeight),
                      a.classList.add("apexcharts-active")),
                    n < 0 && (n = 0),
                    n > s.globals.gridWidth && (n = s.globals.gridWidth),
                    i.isXAxisTooltipEnabled)
                  ) {
                    var o = n;
                    ("tickWidth" !== s.config.xaxis.crosshairs.width &&
                      "barWidth" !== s.config.xaxis.crosshairs.width) ||
                      (o = n + i.xcrosshairsWidth / 2),
                      this.moveXAxisTooltip(o);
                  }
                },
              },
              {
                key: "moveYCrosshairs",
                value: function (t) {
                  var e = this.ttCtx;
                  null !== e.ycrosshairs && k.setAttrs(e.ycrosshairs, { y1: t, y2: t }),
                    null !== e.ycrosshairsHidden && k.setAttrs(e.ycrosshairsHidden, { y1: t, y2: t });
                },
              },
              {
                key: "moveXAxisTooltip",
                value: function (t) {
                  var e = this.w,
                    i = this.ttCtx;
                  if (null !== i.xaxisTooltip && 0 !== i.xcrosshairsWidth) {
                    i.xaxisTooltip.classList.add("apexcharts-active");
                    var s,
                      a =
                        i.xaxisOffY +
                        e.config.xaxis.tooltip.offsetY +
                        e.globals.translateY +
                        1 +
                        e.config.xaxis.offsetY;
                    (t -= i.xaxisTooltip.getBoundingClientRect().width / 2),
                      isNaN(t) ||
                        ((t += e.globals.translateX),
                        (s = new k(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML)),
                        (i.xaxisTooltipText.style.minWidth = s.width + "px"),
                        (i.xaxisTooltip.style.left = t + "px"),
                        (i.xaxisTooltip.style.top = a + "px"));
                  }
                },
              },
              {
                key: "moveYAxisTooltip",
                value: function (t) {
                  var e = this.w,
                    i = this.ttCtx;
                  null === i.yaxisTTEls &&
                    (i.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                  var s = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10),
                    a = e.globals.translateY + s,
                    n = i.yaxisTTEls[t].getBoundingClientRect().height,
                    r = e.globals.translateYAxisX[t] - 2;
                  e.config.yaxis[t].opposite && (r -= 26),
                    (a -= n / 2),
                    -1 === e.globals.ignoreYAxisIndexes.indexOf(t)
                      ? (i.yaxisTTEls[t].classList.add("apexcharts-active"),
                        (i.yaxisTTEls[t].style.top = a + "px"),
                        (i.yaxisTTEls[t].style.left = r + e.config.yaxis[t].tooltip.offsetX + "px"))
                      : i.yaxisTTEls[t].classList.remove("apexcharts-active");
                },
              },
              {
                key: "moveTooltip",
                value: function (t, e) {
                  var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    s = this.w,
                    a = this.ttCtx,
                    n = a.getElTooltip(),
                    r = a.tooltipRect,
                    o = null !== i ? parseFloat(i) : 1,
                    l = parseFloat(t) + o + 5,
                    c = parseFloat(e) + o / 2;
                  if (
                    (l > s.globals.gridWidth / 2 && (l = l - r.ttWidth - o - 10),
                    l > s.globals.gridWidth - r.ttWidth - 10 && (l = s.globals.gridWidth - r.ttWidth),
                    l < -20 && (l = -20),
                    s.config.tooltip.followCursor)
                  ) {
                    var h = a.getElGrid(),
                      d = h.getBoundingClientRect();
                    c = a.e.clientY + s.globals.translateY - d.top - r.ttHeight / 2;
                  } else
                    s.globals.isBarHorizontal ||
                      (r.ttHeight / 2 + c > s.globals.gridHeight &&
                        (c = s.globals.gridHeight - r.ttHeight + s.globals.translateY),
                      c < 0 && (c = 0));
                  isNaN(l) || ((l += s.globals.translateX), (n.style.left = l + "px"), (n.style.top = c + "px"));
                },
              },
              {
                key: "moveMarkers",
                value: function (t, e) {
                  var i = this.w,
                    s = this.ttCtx;
                  if (i.globals.markers.size[t] > 0)
                    for (
                      var a = i.globals.dom.baseEl.querySelectorAll(
                          " .apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-marker")
                        ),
                        n = 0;
                      n < a.length;
                      n++
                    )
                      parseInt(a[n].getAttribute("rel"), 10) === e &&
                        (s.marker.resetPointsSize(), s.marker.enlargeCurrentPoint(e, a[n]));
                  else s.marker.resetPointsSize(), this.moveDynamicPointOnHover(e, t);
                },
              },
              {
                key: "moveDynamicPointOnHover",
                value: function (t, e) {
                  var i,
                    s,
                    a = this.w,
                    n = this.ttCtx,
                    r = a.globals.pointsArray,
                    o = n.tooltipUtil.getHoverMarkerSize(e),
                    l = a.config.series[e].type;
                  if (!l || ("column" !== l && "candlestick" !== l && "boxPlot" !== l)) {
                    (i = r[e][t][0]), (s = r[e][t][1] ? r[e][t][1] : 0);
                    var c = a.globals.dom.baseEl.querySelector(
                      ".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers circle")
                    );
                    c &&
                      s < a.globals.gridHeight &&
                      s > 0 &&
                      (c.setAttribute("r", o), c.setAttribute("cx", i), c.setAttribute("cy", s)),
                      this.moveXCrosshairs(i),
                      n.fixedTooltip || this.moveTooltip(i, s, o);
                  }
                },
              },
              {
                key: "moveDynamicPointsOnHover",
                value: function (t) {
                  var e,
                    i = this.ttCtx,
                    s = i.w,
                    a = 0,
                    n = 0,
                    r = s.globals.pointsArray;
                  e = new Y(this.ctx).getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
                  var o = i.tooltipUtil.getHoverMarkerSize(e);
                  r[e] && ((a = r[e][t][0]), (n = r[e][t][1]));
                  var l = i.tooltipUtil.getAllMarkers();
                  if (null !== l)
                    for (var c = 0; c < s.globals.series.length; c++) {
                      var h = r[c];
                      if ((s.globals.comboCharts && void 0 === h && l.splice(c, 0, null), h && h.length)) {
                        var d = r[c][t][1],
                          u = void 0;
                        if (
                          (l[c].setAttribute("cx", a), "rangeArea" === s.config.chart.type && !s.globals.comboCharts)
                        ) {
                          var p = t + s.globals.series[c].length;
                          (u = r[c][p][1]), (d -= Math.abs(d - u) / 2);
                        }
                        null !== d && !isNaN(d) && d < s.globals.gridHeight + o && d + o > 0
                          ? (l[c] && l[c].setAttribute("r", o), l[c] && l[c].setAttribute("cy", d))
                          : l[c] && l[c].setAttribute("r", 0);
                      }
                    }
                  if ((this.moveXCrosshairs(a), !i.fixedTooltip)) {
                    var g = n || s.globals.gridHeight;
                    this.moveTooltip(a, g, o);
                  }
                },
              },
              {
                key: "moveStickyTooltipOverBars",
                value: function (t) {
                  var e = this.w,
                    i = this.ttCtx,
                    s = e.globals.columnSeries ? e.globals.columnSeries.length : e.globals.series.length,
                    a = s >= 2 && s % 2 == 0 ? Math.floor(s / 2) : Math.floor(s / 2) + 1;
                  e.globals.isBarHorizontal && (a = new Y(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
                  var n = e.globals.dom.baseEl.querySelector(
                      ".apexcharts-bar-series .apexcharts-series[rel='"
                        .concat(a, "'] path[j='")
                        .concat(t, "'], .apexcharts-candlestick-series .apexcharts-series[rel='")
                        .concat(a, "'] path[j='")
                        .concat(t, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='")
                        .concat(a, "'] path[j='")
                        .concat(t, "'], .apexcharts-rangebar-series .apexcharts-series[rel='")
                        .concat(a, "'] path[j='")
                        .concat(t, "']")
                    ),
                    r = n ? parseFloat(n.getAttribute("cx")) : 0,
                    o = n ? parseFloat(n.getAttribute("cy")) : 0,
                    l = n ? parseFloat(n.getAttribute("barWidth")) : 0,
                    c = n ? parseFloat(n.getAttribute("barHeight")) : 0,
                    h = i.getElGrid().getBoundingClientRect(),
                    d =
                      n.classList.contains("apexcharts-candlestick-area") ||
                      n.classList.contains("apexcharts-boxPlot-area");
                  if (
                    (e.globals.isXNumeric
                      ? (n && !d && (r -= s % 2 != 0 ? l / 2 : 0), n && d && e.globals.comboCharts && (r -= l / 2))
                      : e.globals.isBarHorizontal ||
                        ((r = i.xAxisTicksPositions[t - 1] + i.dataPointsDividedWidth / 2),
                        isNaN(r) && (r = i.xAxisTicksPositions[t] - i.dataPointsDividedWidth / 2)),
                    e.globals.isBarHorizontal
                      ? (o > e.globals.gridHeight / 2 && (o -= i.tooltipRect.ttHeight),
                        (o = o + e.config.grid.padding.top + c / 3) + c > e.globals.gridHeight &&
                          (o = e.globals.gridHeight - c))
                      : e.config.tooltip.followCursor
                      ? (o = i.e.clientY - h.top - i.tooltipRect.ttHeight / 2)
                      : o + i.tooltipRect.ttHeight + 15 > e.globals.gridHeight && (o = e.globals.gridHeight),
                    o < -10 && (o = -10),
                    e.globals.isBarHorizontal || this.moveXCrosshairs(r),
                    !i.fixedTooltip)
                  ) {
                    var u = o || e.globals.gridHeight;
                    this.moveTooltip(r, u);
                  }
                },
              },
            ]),
            t
          );
        })(),
        vt = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.ttCtx = e), (this.ctx = e.ctx), (this.tooltipPosition = new mt(e));
          }
          return (
            c(t, [
              {
                key: "drawDynamicPoints",
                value: function () {
                  var t = this.w,
                    e = new k(this.ctx),
                    i = new B(this.ctx),
                    s = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                  (s = m(s)),
                    t.config.chart.stacked &&
                      s.sort(function (t, e) {
                        return (
                          parseFloat(t.getAttribute("data:realIndex")) - parseFloat(e.getAttribute("data:realIndex"))
                        );
                      });
                  for (var a = 0; a < s.length; a++) {
                    var n = s[a].querySelector(".apexcharts-series-markers-wrap");
                    if (null !== n) {
                      var r = void 0,
                        o = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
                      ("line" !== t.config.chart.type && "area" !== t.config.chart.type) ||
                        t.globals.comboCharts ||
                        t.config.tooltip.intersect ||
                        (o += " no-pointer-events");
                      var l = i.getMarkerConfig({ cssClass: o, seriesIndex: Number(n.getAttribute("data:realIndex")) });
                      (r = e.drawMarker(0, 0, l)).node.setAttribute("default-marker-size", 0);
                      var c = document.createElementNS(t.globals.SVGNS, "g");
                      c.classList.add("apexcharts-series-markers"), c.appendChild(r.node), n.appendChild(c);
                    }
                  }
                },
              },
              {
                key: "enlargeCurrentPoint",
                value: function (t, e) {
                  var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                    a = this.w;
                  "bubble" !== a.config.chart.type && this.newPointSize(t, e);
                  var n = e.getAttribute("cx"),
                    r = e.getAttribute("cy");
                  if (
                    (null !== i && null !== s && ((n = i), (r = s)),
                    this.tooltipPosition.moveXCrosshairs(n),
                    !this.fixedTooltip)
                  ) {
                    if ("radar" === a.config.chart.type) {
                      var o = this.ttCtx.getElGrid(),
                        l = o.getBoundingClientRect();
                      n = this.ttCtx.e.clientX - l.left;
                    }
                    this.tooltipPosition.moveTooltip(n, r, a.config.markers.hover.size);
                  }
                },
              },
              {
                key: "enlargePoints",
                value: function (t) {
                  for (
                    var e = this.w,
                      i = this,
                      s = this.ttCtx,
                      a = t,
                      n = e.globals.dom.baseEl.querySelectorAll(
                        ".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"
                      ),
                      r = e.config.markers.hover.size,
                      o = 0;
                    o < n.length;
                    o++
                  ) {
                    var l = n[o].getAttribute("rel"),
                      c = n[o].getAttribute("index");
                    if (
                      (void 0 === r && (r = e.globals.markers.size[c] + e.config.markers.hover.sizeOffset),
                      a === parseInt(l, 10))
                    ) {
                      i.newPointSize(a, n[o]);
                      var h = n[o].getAttribute("cx"),
                        d = n[o].getAttribute("cy");
                      i.tooltipPosition.moveXCrosshairs(h), s.fixedTooltip || i.tooltipPosition.moveTooltip(h, d, r);
                    } else i.oldPointSize(n[o]);
                  }
                },
              },
              {
                key: "newPointSize",
                value: function (t, e) {
                  var i = this.w,
                    s = i.config.markers.hover.size,
                    a = 0 === t ? e.parentNode.firstChild : e.parentNode.lastChild;
                  if ("0" !== a.getAttribute("default-marker-size")) {
                    var n = parseInt(a.getAttribute("index"), 10);
                    void 0 === s && (s = i.globals.markers.size[n] + i.config.markers.hover.sizeOffset),
                      s < 0 && (s = 0),
                      a.setAttribute("r", s);
                  }
                },
              },
              {
                key: "oldPointSize",
                value: function (t) {
                  var e = parseFloat(t.getAttribute("default-marker-size"));
                  t.setAttribute("r", e);
                },
              },
              {
                key: "resetPointsSize",
                value: function () {
                  for (
                    var t = this.w.globals.dom.baseEl.querySelectorAll(
                        ".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"
                      ),
                      e = 0;
                    e < t.length;
                    e++
                  ) {
                    var i = parseFloat(t[e].getAttribute("default-marker-size"));
                    b.isNumber(i) && i >= 0 ? t[e].setAttribute("r", i) : t[e].setAttribute("r", 0);
                  }
                },
              },
            ]),
            t
          );
        })(),
        xt = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.ttCtx = e);
          }
          return (
            c(t, [
              {
                key: "getAttr",
                value: function (t, e) {
                  return parseFloat(t.target.getAttribute(e));
                },
              },
              {
                key: "handleHeatTreeTooltip",
                value: function (t) {
                  var e = t.e,
                    i = t.opt,
                    s = t.x,
                    a = t.y,
                    n = t.type,
                    r = this.ttCtx,
                    o = this.w;
                  if (e.target.classList.contains("apexcharts-".concat(n, "-rect"))) {
                    var l = this.getAttr(e, "i"),
                      c = this.getAttr(e, "j"),
                      h = this.getAttr(e, "cx"),
                      d = this.getAttr(e, "cy"),
                      u = this.getAttr(e, "width"),
                      p = this.getAttr(e, "height");
                    if (
                      (r.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: l, j: c, shared: !1, e: e }),
                      (o.globals.capturedSeriesIndex = l),
                      (o.globals.capturedDataPointIndex = c),
                      (s = h + r.tooltipRect.ttWidth / 2 + u),
                      (a = d + r.tooltipRect.ttHeight / 2 - p / 2),
                      r.tooltipPosition.moveXCrosshairs(h + u / 2),
                      s > o.globals.gridWidth / 2 && (s = h - r.tooltipRect.ttWidth / 2 + u),
                      r.w.config.tooltip.followCursor)
                    ) {
                      var g = o.globals.dom.elWrap.getBoundingClientRect();
                      (s = o.globals.clientX - g.left - (s > o.globals.gridWidth / 2 ? r.tooltipRect.ttWidth : 0)),
                        (a = o.globals.clientY - g.top - (a > o.globals.gridHeight / 2 ? r.tooltipRect.ttHeight : 0));
                    }
                  }
                  return { x: s, y: a };
                },
              },
              {
                key: "handleMarkerTooltip",
                value: function (t) {
                  var e,
                    i,
                    s = t.e,
                    a = t.opt,
                    n = t.x,
                    r = t.y,
                    o = this.w,
                    l = this.ttCtx;
                  if (s.target.classList.contains("apexcharts-marker")) {
                    var c = parseInt(a.paths.getAttribute("cx"), 10),
                      h = parseInt(a.paths.getAttribute("cy"), 10),
                      d = parseFloat(a.paths.getAttribute("val"));
                    if (
                      ((i = parseInt(a.paths.getAttribute("rel"), 10)),
                      (e = parseInt(a.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1),
                      l.intersect)
                    ) {
                      var u = b.findAncestor(a.paths, "apexcharts-series");
                      u && (e = parseInt(u.getAttribute("data:realIndex"), 10));
                    }
                    if (
                      (l.tooltipLabels.drawSeriesTexts({
                        ttItems: a.ttItems,
                        i: e,
                        j: i,
                        shared: !l.showOnIntersect && o.config.tooltip.shared,
                        e: s,
                      }),
                      "mouseup" === s.type && l.markerClick(s, e, i),
                      (o.globals.capturedSeriesIndex = e),
                      (o.globals.capturedDataPointIndex = i),
                      (n = c),
                      (r = h + o.globals.translateY - 1.4 * l.tooltipRect.ttHeight),
                      l.w.config.tooltip.followCursor)
                    ) {
                      var p = l.getElGrid().getBoundingClientRect();
                      r = l.e.clientY + o.globals.translateY - p.top;
                    }
                    d < 0 && (r = h), l.marker.enlargeCurrentPoint(i, a.paths, n, r);
                  }
                  return { x: n, y: r };
                },
              },
              {
                key: "handleBarTooltip",
                value: function (t) {
                  var e,
                    i,
                    s = t.e,
                    a = t.opt,
                    n = this.w,
                    r = this.ttCtx,
                    o = r.getElTooltip(),
                    l = 0,
                    c = 0,
                    h = 0,
                    d = this.getBarTooltipXY({ e: s, opt: a });
                  e = d.i;
                  var u = d.barHeight,
                    p = d.j;
                  (n.globals.capturedSeriesIndex = e),
                    (n.globals.capturedDataPointIndex = p),
                    (n.globals.isBarHorizontal && r.tooltipUtil.hasBars()) || !n.config.tooltip.shared
                      ? ((c = d.x),
                        (h = d.y),
                        (i = Array.isArray(n.config.stroke.width) ? n.config.stroke.width[e] : n.config.stroke.width),
                        (l = c))
                      : n.globals.comboCharts || n.config.tooltip.shared || (l /= 2),
                    isNaN(h) ? (h = n.globals.svgHeight - r.tooltipRect.ttHeight) : h < 0 && (h = 0);
                  var g = parseInt(a.paths.parentNode.getAttribute("data:realIndex"), 10),
                    f = n.globals.isMultipleYAxis
                      ? n.config.yaxis[g] && n.config.yaxis[g].reversed
                      : n.config.yaxis[0].reversed;
                  if (
                    (c + r.tooltipRect.ttWidth > n.globals.gridWidth && !f
                      ? (c -= r.tooltipRect.ttWidth)
                      : c < 0 && (c = 0),
                    r.w.config.tooltip.followCursor)
                  ) {
                    var m = r.getElGrid().getBoundingClientRect();
                    h = r.e.clientY - m.top;
                  }
                  null === r.tooltip && (r.tooltip = n.globals.dom.baseEl.querySelector(".apexcharts-tooltip")),
                    n.config.tooltip.shared ||
                      (n.globals.comboBarCount > 0
                        ? r.tooltipPosition.moveXCrosshairs(l + i / 2)
                        : r.tooltipPosition.moveXCrosshairs(l)),
                    !r.fixedTooltip &&
                      (!n.config.tooltip.shared || (n.globals.isBarHorizontal && r.tooltipUtil.hasBars())) &&
                      (f && (c -= r.tooltipRect.ttWidth) < 0 && (c = 0),
                      !f ||
                        (n.globals.isBarHorizontal && r.tooltipUtil.hasBars()) ||
                        (h = h + u - 2 * (n.globals.series[e][p] < 0 ? u : 0)),
                      r.tooltipRect.ttHeight + h > n.globals.gridHeight
                        ? (h = n.globals.gridHeight - r.tooltipRect.ttHeight + n.globals.translateY)
                        : (h = h + n.globals.translateY - r.tooltipRect.ttHeight / 2) < 0 && (h = 0),
                      (o.style.left = c + n.globals.translateX + "px"),
                      (o.style.top = h + "px"));
                },
              },
              {
                key: "getBarTooltipXY",
                value: function (t) {
                  var e = t.e,
                    i = t.opt,
                    s = this.w,
                    a = null,
                    n = this.ttCtx,
                    r = 0,
                    o = 0,
                    l = 0,
                    c = 0,
                    h = 0,
                    d = e.target.classList;
                  if (
                    d.contains("apexcharts-bar-area") ||
                    d.contains("apexcharts-candlestick-area") ||
                    d.contains("apexcharts-boxPlot-area") ||
                    d.contains("apexcharts-rangebar-area")
                  ) {
                    var u = e.target,
                      p = u.getBoundingClientRect(),
                      g = i.elGrid.getBoundingClientRect(),
                      f = p.height;
                    h = p.height;
                    var m = p.width,
                      v = parseInt(u.getAttribute("cx"), 10),
                      x = parseInt(u.getAttribute("cy"), 10);
                    c = parseFloat(u.getAttribute("barWidth"));
                    var b = "touchmove" === e.type ? e.touches[0].clientX : e.clientX;
                    (a = parseInt(u.getAttribute("j"), 10)), (r = parseInt(u.parentNode.getAttribute("rel"), 10) - 1);
                    var y = u.getAttribute("data-range-y1"),
                      w = u.getAttribute("data-range-y2");
                    s.globals.comboCharts && (r = parseInt(u.parentNode.getAttribute("data:realIndex"), 10)),
                      n.tooltipLabels.drawSeriesTexts({
                        ttItems: i.ttItems,
                        i: r,
                        j: a,
                        y1: y ? parseInt(y, 10) : null,
                        y2: w ? parseInt(w, 10) : null,
                        shared: !n.showOnIntersect && s.config.tooltip.shared,
                        e: e,
                      }),
                      s.config.tooltip.followCursor
                        ? s.globals.isBarHorizontal
                          ? ((o = b - g.left + 15),
                            (l = x - n.dataPointsDividedHeight + f / 2 - n.tooltipRect.ttHeight / 2))
                          : ((o = s.globals.isXNumeric ? v - m / 2 : v - n.dataPointsDividedWidth + m / 2),
                            (l = e.clientY - g.top - n.tooltipRect.ttHeight / 2 - 15))
                        : s.globals.isBarHorizontal
                        ? ((o = v) < n.xyRatios.baseLineInvertedY && (o = v - n.tooltipRect.ttWidth),
                          (l = x - n.dataPointsDividedHeight + f / 2 - n.tooltipRect.ttHeight / 2))
                        : ((o = s.globals.isXNumeric ? v - m / 2 : v - n.dataPointsDividedWidth + m / 2), (l = x));
                  }
                  return { x: o, y: l, barHeight: h, barWidth: c, i: r, j: a };
                },
              },
            ]),
            t
          );
        })(),
        bt = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.ttCtx = e);
          }
          return (
            c(t, [
              {
                key: "drawXaxisTooltip",
                value: function () {
                  var t = this.w,
                    e = this.ttCtx,
                    i = "bottom" === t.config.xaxis.position;
                  e.xaxisOffY = i
                    ? t.globals.gridHeight + 1
                    : -t.globals.xAxisHeight - t.config.xaxis.axisTicks.height + 3;
                  var s = i
                      ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom"
                      : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top",
                    a = t.globals.dom.elWrap;
                  e.isXAxisTooltipEnabled &&
                    null === t.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") &&
                    ((e.xaxisTooltip = document.createElement("div")),
                    e.xaxisTooltip.setAttribute("class", s + " apexcharts-theme-" + t.config.tooltip.theme),
                    a.appendChild(e.xaxisTooltip),
                    (e.xaxisTooltipText = document.createElement("div")),
                    e.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"),
                    (e.xaxisTooltipText.style.fontFamily =
                      t.config.xaxis.tooltip.style.fontFamily || t.config.chart.fontFamily),
                    (e.xaxisTooltipText.style.fontSize = t.config.xaxis.tooltip.style.fontSize),
                    e.xaxisTooltip.appendChild(e.xaxisTooltipText));
                },
              },
              {
                key: "drawYaxisTooltip",
                value: function () {
                  for (
                    var t = this.w,
                      e = this.ttCtx,
                      i = function (i) {
                        var s = t.config.yaxis[i].opposite || t.config.yaxis[i].crosshairs.opposite;
                        e.yaxisOffX = s ? t.globals.gridWidth + 1 : 1;
                        var a = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(
                          i,
                          s ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left"
                        );
                        t.globals.yAxisSameScaleIndices.map(function (e, s) {
                          e.map(function (e, s) {
                            s === i && (a += t.config.yaxis[s].show ? " " : " apexcharts-yaxistooltip-hidden");
                          });
                        });
                        var n = t.globals.dom.elWrap;
                        null ===
                          t.globals.dom.baseEl.querySelector(
                            ".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i)
                          ) &&
                          ((e.yaxisTooltip = document.createElement("div")),
                          e.yaxisTooltip.setAttribute("class", a + " apexcharts-theme-" + t.config.tooltip.theme),
                          n.appendChild(e.yaxisTooltip),
                          0 === i && (e.yaxisTooltipText = []),
                          (e.yaxisTooltipText[i] = document.createElement("div")),
                          e.yaxisTooltipText[i].classList.add("apexcharts-yaxistooltip-text"),
                          e.yaxisTooltip.appendChild(e.yaxisTooltipText[i]));
                      },
                      s = 0;
                    s < t.config.yaxis.length;
                    s++
                  )
                    i(s);
                },
              },
              {
                key: "setXCrosshairWidth",
                value: function () {
                  var t = this.w,
                    e = this.ttCtx,
                    i = e.getElXCrosshairs();
                  if (((e.xcrosshairsWidth = parseInt(t.config.xaxis.crosshairs.width, 10)), t.globals.comboCharts)) {
                    var s = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                    if (null !== s && "barWidth" === t.config.xaxis.crosshairs.width) {
                      var a = parseFloat(s.getAttribute("barWidth"));
                      e.xcrosshairsWidth = a;
                    } else if ("tickWidth" === t.config.xaxis.crosshairs.width) {
                      var n = t.globals.labels.length;
                      e.xcrosshairsWidth = t.globals.gridWidth / n;
                    }
                  } else if ("tickWidth" === t.config.xaxis.crosshairs.width) {
                    var r = t.globals.labels.length;
                    e.xcrosshairsWidth = t.globals.gridWidth / r;
                  } else if ("barWidth" === t.config.xaxis.crosshairs.width) {
                    var o = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                    if (null !== o) {
                      var l = parseFloat(o.getAttribute("barWidth"));
                      e.xcrosshairsWidth = l;
                    } else e.xcrosshairsWidth = 1;
                  }
                  t.globals.isBarHorizontal && (e.xcrosshairsWidth = 0),
                    null !== i && e.xcrosshairsWidth > 0 && i.setAttribute("width", e.xcrosshairsWidth);
                },
              },
              {
                key: "handleYCrosshair",
                value: function () {
                  var t = this.w,
                    e = this.ttCtx;
                  (e.ycrosshairs = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs")),
                    (e.ycrosshairsHidden = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden"));
                },
              },
              {
                key: "drawYaxisTooltipText",
                value: function (t, e, i) {
                  var s = this.ttCtx,
                    a = this.w,
                    n = a.globals.yLabelFormatters[t];
                  if (s.yaxisTooltips[t]) {
                    var r = s.getElGrid().getBoundingClientRect(),
                      o = (e - r.top) * i.yRatio[t],
                      l = a.globals.maxYArr[t] - a.globals.minYArr[t],
                      c = a.globals.minYArr[t] + (l - o);
                    s.tooltipPosition.moveYCrosshairs(e - r.top),
                      (s.yaxisTooltipText[t].innerHTML = n(c)),
                      s.tooltipPosition.moveYAxisTooltip(t);
                  }
                },
              },
            ]),
            t
          );
        })(),
        yt = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
            var i = this.w;
            (this.tConfig = i.config.tooltip),
              (this.tooltipUtil = new gt(this)),
              (this.tooltipLabels = new ft(this)),
              (this.tooltipPosition = new mt(this)),
              (this.marker = new vt(this)),
              (this.intersect = new xt(this)),
              (this.axesTooltip = new bt(this)),
              (this.showOnIntersect = this.tConfig.intersect),
              (this.showTooltipTitle = this.tConfig.x.show),
              (this.fixedTooltip = this.tConfig.fixed.enabled),
              (this.xaxisTooltip = null),
              (this.yaxisTTEls = null),
              (this.isBarShared = !i.globals.isBarHorizontal && this.tConfig.shared),
              (this.lastHoverTime = Date.now());
          }
          return (
            c(t, [
              {
                key: "getElTooltip",
                value: function (t) {
                  return (
                    t || (t = this),
                    t.w.globals.dom.baseEl ? t.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null
                  );
                },
              },
              {
                key: "getElXCrosshairs",
                value: function () {
                  return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
                },
              },
              {
                key: "getElGrid",
                value: function () {
                  return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
                },
              },
              {
                key: "drawTooltip",
                value: function (t) {
                  var e = this.w;
                  (this.xyRatios = t),
                    (this.isXAxisTooltipEnabled = e.config.xaxis.tooltip.enabled && e.globals.axisCharts),
                    (this.yaxisTooltips = e.config.yaxis.map(function (t, i) {
                      return !!(t.show && t.tooltip.enabled && e.globals.axisCharts);
                    })),
                    (this.allTooltipSeriesGroups = []),
                    e.globals.axisCharts || (this.showTooltipTitle = !1);
                  var i = document.createElement("div");
                  if (
                    (i.classList.add("apexcharts-tooltip"),
                    e.config.tooltip.cssClass && i.classList.add(e.config.tooltip.cssClass),
                    i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)),
                    e.globals.dom.elWrap.appendChild(i),
                    e.globals.axisCharts)
                  ) {
                    this.axesTooltip.drawXaxisTooltip(),
                      this.axesTooltip.drawYaxisTooltip(),
                      this.axesTooltip.setXCrosshairWidth(),
                      this.axesTooltip.handleYCrosshair();
                    var s = new G(this.ctx);
                    this.xAxisTicksPositions = s.getXAxisTicksPositions();
                  }
                  if (
                    ((!e.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e.config.chart.type) ||
                      this.tConfig.shared ||
                      (this.showOnIntersect = !0),
                    (0 !== e.config.markers.size && 0 !== e.globals.markers.largestSize) ||
                      this.marker.drawDynamicPoints(this),
                    e.globals.collapsedSeries.length !== e.globals.series.length)
                  ) {
                    (this.dataPointsDividedHeight = e.globals.gridHeight / e.globals.dataPoints),
                      (this.dataPointsDividedWidth = e.globals.gridWidth / e.globals.dataPoints),
                      this.showTooltipTitle &&
                        ((this.tooltipTitle = document.createElement("div")),
                        this.tooltipTitle.classList.add("apexcharts-tooltip-title"),
                        (this.tooltipTitle.style.fontFamily =
                          this.tConfig.style.fontFamily || e.config.chart.fontFamily),
                        (this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize),
                        i.appendChild(this.tooltipTitle));
                    var a = e.globals.series.length;
                    (e.globals.xyCharts || e.globals.comboCharts) &&
                      this.tConfig.shared &&
                      (a = this.showOnIntersect ? 1 : e.globals.series.length),
                      (this.legendLabels = e.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text")),
                      (this.ttItems = this.createTTElements(a)),
                      this.addSVGEvents();
                  }
                },
              },
              {
                key: "createTTElements",
                value: function (t) {
                  for (
                    var e = this,
                      i = this.w,
                      s = [],
                      a = this.getElTooltip(),
                      n = function (n) {
                        var r = document.createElement("div");
                        r.classList.add("apexcharts-tooltip-series-group"),
                          (r.style.order = i.config.tooltip.inverseOrder ? t - n : n + 1),
                          e.tConfig.shared &&
                            e.tConfig.enabledOnSeries &&
                            Array.isArray(e.tConfig.enabledOnSeries) &&
                            e.tConfig.enabledOnSeries.indexOf(n) < 0 &&
                            r.classList.add("apexcharts-tooltip-series-group-hidden");
                        var o = document.createElement("span");
                        o.classList.add("apexcharts-tooltip-marker"),
                          (o.style.backgroundColor = i.globals.colors[n]),
                          r.appendChild(o);
                        var l = document.createElement("div");
                        l.classList.add("apexcharts-tooltip-text"),
                          (l.style.fontFamily = e.tConfig.style.fontFamily || i.config.chart.fontFamily),
                          (l.style.fontSize = e.tConfig.style.fontSize),
                          ["y", "goals", "z"].forEach(function (t) {
                            var e = document.createElement("div");
                            e.classList.add("apexcharts-tooltip-".concat(t, "-group"));
                            var i = document.createElement("span");
                            i.classList.add("apexcharts-tooltip-text-".concat(t, "-label")), e.appendChild(i);
                            var s = document.createElement("span");
                            s.classList.add("apexcharts-tooltip-text-".concat(t, "-value")),
                              e.appendChild(s),
                              l.appendChild(e);
                          }),
                          r.appendChild(l),
                          a.appendChild(r),
                          s.push(r);
                      },
                      r = 0;
                    r < t;
                    r++
                  )
                    n(r);
                  return s;
                },
              },
              {
                key: "addSVGEvents",
                value: function () {
                  var t = this.w,
                    e = t.config.chart.type,
                    i = this.getElTooltip(),
                    s = !("bar" !== e && "candlestick" !== e && "boxPlot" !== e && "rangeBar" !== e),
                    a = "area" === e || "line" === e || "scatter" === e || "bubble" === e || "radar" === e,
                    n = t.globals.dom.Paper.node,
                    r = this.getElGrid();
                  r && (this.seriesBound = r.getBoundingClientRect());
                  var o,
                    l = [],
                    c = [],
                    h = { hoverArea: n, elGrid: r, tooltipEl: i, tooltipY: l, tooltipX: c, ttItems: this.ttItems };
                  if (
                    t.globals.axisCharts &&
                    (a
                      ? (o = t.globals.dom.baseEl.querySelectorAll(
                          ".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker"
                        ))
                      : s
                      ? (o = t.globals.dom.baseEl.querySelectorAll(
                          ".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area"
                        ))
                      : ("heatmap" !== e && "treemap" !== e) ||
                        (o = t.globals.dom.baseEl.querySelectorAll(
                          ".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap"
                        )),
                    o && o.length)
                  )
                    for (var d = 0; d < o.length; d++) l.push(o[d].getAttribute("cy")), c.push(o[d].getAttribute("cx"));
                  if (
                    (t.globals.xyCharts && !this.showOnIntersect) ||
                    (t.globals.comboCharts && !this.showOnIntersect) ||
                    (s && this.tooltipUtil.hasBars() && this.tConfig.shared)
                  )
                    this.addPathsEventListeners([n], h);
                  else if ((s && !t.globals.comboCharts) || (a && this.showOnIntersect))
                    this.addDatapointEventsListeners(h);
                  else if (!t.globals.axisCharts || "heatmap" === e || "treemap" === e) {
                    var u = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                    this.addPathsEventListeners(u, h);
                  }
                  if (this.showOnIntersect) {
                    var p = t.globals.dom.baseEl.querySelectorAll(
                      ".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker"
                    );
                    p.length > 0 && this.addPathsEventListeners(p, h),
                      this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(h);
                  }
                },
              },
              {
                key: "drawFixedTooltipRect",
                value: function () {
                  var t = this.w,
                    e = this.getElTooltip(),
                    i = e.getBoundingClientRect(),
                    s = i.width + 10,
                    a = i.height + 10,
                    n = this.tConfig.fixed.offsetX,
                    r = this.tConfig.fixed.offsetY,
                    o = this.tConfig.fixed.position.toLowerCase();
                  return (
                    o.indexOf("right") > -1 && (n = n + t.globals.svgWidth - s + 10),
                    o.indexOf("bottom") > -1 && (r = r + t.globals.svgHeight - a - 10),
                    (e.style.left = n + "px"),
                    (e.style.top = r + "px"),
                    { x: n, y: r, ttWidth: s, ttHeight: a }
                  );
                },
              },
              {
                key: "addDatapointEventsListeners",
                value: function (t) {
                  var e = this.w.globals.dom.baseEl.querySelectorAll(
                    ".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area"
                  );
                  this.addPathsEventListeners(e, t);
                },
              },
              {
                key: "addPathsEventListeners",
                value: function (t, e) {
                  for (
                    var i = this,
                      s = function (s) {
                        var a = {
                          paths: t[s],
                          tooltipEl: e.tooltipEl,
                          tooltipY: e.tooltipY,
                          tooltipX: e.tooltipX,
                          elGrid: e.elGrid,
                          hoverArea: e.hoverArea,
                          ttItems: e.ttItems,
                        };
                        ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function (e) {
                          return t[s].addEventListener(e, i.onSeriesHover.bind(i, a), { capture: !1, passive: !0 });
                        });
                      },
                      a = 0;
                    a < t.length;
                    a++
                  )
                    s(a);
                },
              },
              {
                key: "onSeriesHover",
                value: function (t, e) {
                  var i = this,
                    s = Date.now() - this.lastHoverTime;
                  s >= 100
                    ? this.seriesHover(t, e)
                    : (clearTimeout(this.seriesHoverTimeout),
                      (this.seriesHoverTimeout = setTimeout(function () {
                        i.seriesHover(t, e);
                      }, 100 - s)));
                },
              },
              {
                key: "seriesHover",
                value: function (t, e) {
                  var i = this;
                  this.lastHoverTime = Date.now();
                  var s = [],
                    a = this.w;
                  a.config.chart.group && (s = this.ctx.getGroupedCharts()),
                    (a.globals.axisCharts &&
                      ((a.globals.minX === -1 / 0 && a.globals.maxX === 1 / 0) || 0 === a.globals.dataPoints)) ||
                      (s.length
                        ? s.forEach(function (s) {
                            var a = i.getElTooltip(s),
                              n = {
                                paths: t.paths,
                                tooltipEl: a,
                                tooltipY: t.tooltipY,
                                tooltipX: t.tooltipX,
                                elGrid: t.elGrid,
                                hoverArea: t.hoverArea,
                                ttItems: s.w.globals.tooltip.ttItems,
                              };
                            s.w.globals.minX === i.w.globals.minX &&
                              s.w.globals.maxX === i.w.globals.maxX &&
                              s.w.globals.tooltip.seriesHoverByContext({
                                chartCtx: s,
                                ttCtx: s.w.globals.tooltip,
                                opt: n,
                                e: e,
                              });
                          })
                        : this.seriesHoverByContext({
                            chartCtx: this.ctx,
                            ttCtx: this.w.globals.tooltip,
                            opt: t,
                            e: e,
                          }));
                },
              },
              {
                key: "seriesHoverByContext",
                value: function (t) {
                  var e = t.chartCtx,
                    i = t.ttCtx,
                    s = t.opt,
                    a = t.e,
                    n = e.w,
                    r = this.getElTooltip();
                  r &&
                    ((i.tooltipRect = {
                      x: 0,
                      y: 0,
                      ttWidth: r.getBoundingClientRect().width,
                      ttHeight: r.getBoundingClientRect().height,
                    }),
                    (i.e = a),
                    !i.tooltipUtil.hasBars() ||
                      n.globals.comboCharts ||
                      i.isBarShared ||
                      (this.tConfig.onDatasetHover.highlightDataSeries &&
                        new Y(e).toggleSeriesOnHover(a, a.target.parentNode)),
                    i.fixedTooltip && i.drawFixedTooltipRect(),
                    n.globals.axisCharts
                      ? i.axisChartsTooltips({ e: a, opt: s, tooltipRect: i.tooltipRect })
                      : i.nonAxisChartsTooltips({ e: a, opt: s, tooltipRect: i.tooltipRect }));
                },
              },
              {
                key: "axisChartsTooltips",
                value: function (t) {
                  var e,
                    i,
                    s = t.e,
                    a = t.opt,
                    n = this.w,
                    r = a.elGrid.getBoundingClientRect(),
                    o = "touchmove" === s.type ? s.touches[0].clientX : s.clientX,
                    l = "touchmove" === s.type ? s.touches[0].clientY : s.clientY;
                  if (
                    ((this.clientY = l),
                    (this.clientX = o),
                    (n.globals.capturedSeriesIndex = -1),
                    (n.globals.capturedDataPointIndex = -1),
                    l < r.top || l > r.top + r.height)
                  )
                    this.handleMouseOut(a);
                  else {
                    if (Array.isArray(this.tConfig.enabledOnSeries) && !n.config.tooltip.shared) {
                      var c = parseInt(a.paths.getAttribute("index"), 10);
                      if (this.tConfig.enabledOnSeries.indexOf(c) < 0) return void this.handleMouseOut(a);
                    }
                    var h = this.getElTooltip(),
                      d = this.getElXCrosshairs(),
                      u =
                        n.globals.xyCharts ||
                        ("bar" === n.config.chart.type &&
                          !n.globals.isBarHorizontal &&
                          this.tooltipUtil.hasBars() &&
                          this.tConfig.shared) ||
                        (n.globals.comboCharts && this.tooltipUtil.hasBars());
                    if ("mousemove" === s.type || "touchmove" === s.type || "mouseup" === s.type) {
                      if (
                        n.globals.collapsedSeries.length + n.globals.ancillaryCollapsedSeries.length ===
                        n.globals.series.length
                      )
                        return;
                      null !== d && d.classList.add("apexcharts-active");
                      var p = this.yaxisTooltips.filter(function (t) {
                        return !0 === t;
                      });
                      if (
                        (null !== this.ycrosshairs && p.length && this.ycrosshairs.classList.add("apexcharts-active"),
                        u && !this.showOnIntersect)
                      )
                        this.handleStickyTooltip(s, o, l, a);
                      else if ("heatmap" === n.config.chart.type || "treemap" === n.config.chart.type) {
                        var g = this.intersect.handleHeatTreeTooltip({
                          e: s,
                          opt: a,
                          x: e,
                          y: i,
                          type: n.config.chart.type,
                        });
                        (e = g.x), (i = g.y), (h.style.left = e + "px"), (h.style.top = i + "px");
                      } else
                        this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: s, opt: a }),
                          this.tooltipUtil.hasMarkers() &&
                            this.intersect.handleMarkerTooltip({ e: s, opt: a, x: e, y: i });
                      if (this.yaxisTooltips.length)
                        for (var f = 0; f < n.config.yaxis.length; f++)
                          this.axesTooltip.drawYaxisTooltipText(f, l, this.xyRatios);
                      a.tooltipEl.classList.add("apexcharts-active");
                    } else ("mouseout" !== s.type && "touchend" !== s.type) || this.handleMouseOut(a);
                  }
                },
              },
              {
                key: "nonAxisChartsTooltips",
                value: function (t) {
                  var e = t.e,
                    i = t.opt,
                    s = t.tooltipRect,
                    a = this.w,
                    n = i.paths.getAttribute("rel"),
                    r = this.getElTooltip(),
                    o = a.globals.dom.elWrap.getBoundingClientRect();
                  if ("mousemove" === e.type || "touchmove" === e.type) {
                    r.classList.add("apexcharts-active"),
                      this.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: parseInt(n, 10) - 1, shared: !1 });
                    var l = a.globals.clientX - o.left - s.ttWidth / 2,
                      c = a.globals.clientY - o.top - s.ttHeight - 10;
                    if (((r.style.left = l + "px"), (r.style.top = c + "px"), a.config.legend.tooltipHoverFormatter)) {
                      var h = n - 1,
                        d = (0, a.config.legend.tooltipHoverFormatter)(
                          this.legendLabels[h].getAttribute("data:default-text"),
                          { seriesIndex: h, dataPointIndex: h, w: a }
                        );
                      this.legendLabels[h].innerHTML = d;
                    }
                  } else
                    ("mouseout" !== e.type && "touchend" !== e.type) ||
                      (r.classList.remove("apexcharts-active"),
                      a.config.legend.tooltipHoverFormatter &&
                        this.legendLabels.forEach(function (t) {
                          var e = t.getAttribute("data:default-text");
                          t.innerHTML = decodeURIComponent(e);
                        }));
                },
              },
              {
                key: "handleStickyTooltip",
                value: function (t, e, i, s) {
                  var a = this.w,
                    n = this.tooltipUtil.getNearestValues({
                      context: this,
                      hoverArea: s.hoverArea,
                      elGrid: s.elGrid,
                      clientX: e,
                      clientY: i,
                    }),
                    r = n.j,
                    o = n.capturedSeries,
                    l = s.elGrid.getBoundingClientRect();
                  n.hoverX < 0 || n.hoverX > l.width
                    ? this.handleMouseOut(s)
                    : null !== o
                    ? this.handleStickyCapturedSeries(t, o, s, r)
                    : (this.tooltipUtil.isXoverlap(r) || a.globals.isBarHorizontal) &&
                      this.create(t, this, 0, r, s.ttItems);
                },
              },
              {
                key: "handleStickyCapturedSeries",
                value: function (t, e, i, s) {
                  var a = this.w;
                  this.tConfig.shared || null !== a.globals.series[e][s]
                    ? void 0 !== a.globals.series[e][s]
                      ? this.tConfig.shared &&
                        this.tooltipUtil.isXoverlap(s) &&
                        this.tooltipUtil.isInitialSeriesSameLen()
                        ? this.create(t, this, e, s, i.ttItems)
                        : this.create(t, this, e, s, i.ttItems, !1)
                      : this.tooltipUtil.isXoverlap(s) && this.create(t, this, 0, s, i.ttItems)
                    : this.handleMouseOut(i);
                },
              },
              {
                key: "deactivateHoverFilter",
                value: function () {
                  for (
                    var t = this.w, e = new k(this.ctx), i = t.globals.dom.Paper.select(".apexcharts-bar-area"), s = 0;
                    s < i.length;
                    s++
                  )
                    e.pathMouseLeave(i[s]);
                },
              },
              {
                key: "handleMouseOut",
                value: function (t) {
                  var e = this.w,
                    i = this.getElXCrosshairs();
                  if (
                    (t.tooltipEl.classList.remove("apexcharts-active"),
                    this.deactivateHoverFilter(),
                    "bubble" !== e.config.chart.type && this.marker.resetPointsSize(),
                    null !== i && i.classList.remove("apexcharts-active"),
                    null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"),
                    this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"),
                    this.yaxisTooltips.length)
                  ) {
                    null === this.yaxisTTEls &&
                      (this.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                    for (var s = 0; s < this.yaxisTTEls.length; s++)
                      this.yaxisTTEls[s].classList.remove("apexcharts-active");
                  }
                  e.config.legend.tooltipHoverFormatter &&
                    this.legendLabels.forEach(function (t) {
                      var e = t.getAttribute("data:default-text");
                      t.innerHTML = decodeURIComponent(e);
                    });
                },
              },
              {
                key: "markerClick",
                value: function (t, e, i) {
                  var s = this.w;
                  "function" == typeof s.config.chart.events.markerClick &&
                    s.config.chart.events.markerClick(t, this.ctx, { seriesIndex: e, dataPointIndex: i, w: s }),
                    this.ctx.events.fireEvent("markerClick", [
                      t,
                      this.ctx,
                      { seriesIndex: e, dataPointIndex: i, w: s },
                    ]);
                },
              },
              {
                key: "create",
                value: function (t, e, i, s, a) {
                  var n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
                    r = this.w,
                    o = e;
                  "mouseup" === t.type && this.markerClick(t, i, s), null === n && (n = this.tConfig.shared);
                  var l = this.tooltipUtil.hasMarkers(),
                    c = this.tooltipUtil.getElBars();
                  if (r.config.legend.tooltipHoverFormatter) {
                    var h = r.config.legend.tooltipHoverFormatter,
                      d = Array.from(this.legendLabels);
                    d.forEach(function (t) {
                      var e = t.getAttribute("data:default-text");
                      t.innerHTML = decodeURIComponent(e);
                    });
                    for (var u = 0; u < d.length; u++) {
                      var p = d[u],
                        g = parseInt(p.getAttribute("i"), 10),
                        f = decodeURIComponent(p.getAttribute("data:default-text")),
                        m = h(f, { seriesIndex: n ? g : i, dataPointIndex: s, w: r });
                      if (n) p.innerHTML = r.globals.collapsedSeriesIndices.indexOf(g) < 0 ? m : f;
                      else if (((p.innerHTML = g === i ? m : f), i === g)) break;
                    }
                  }
                  if (n) {
                    if (
                      (o.tooltipLabels.drawSeriesTexts({
                        ttItems: a,
                        i: i,
                        j: s,
                        shared: !this.showOnIntersect && this.tConfig.shared,
                      }),
                      l &&
                        (r.globals.markers.largestSize > 0
                          ? o.marker.enlargePoints(s)
                          : o.tooltipPosition.moveDynamicPointsOnHover(s)),
                      this.tooltipUtil.hasBars() &&
                        ((this.barSeriesHeight = this.tooltipUtil.getBarsHeight(c)), this.barSeriesHeight > 0))
                    ) {
                      var v = new k(this.ctx),
                        x = r.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(s, "']"));
                      this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(s);
                      for (var b = 0; b < x.length; b++) v.pathMouseEnter(x[b]);
                    }
                  } else
                    o.tooltipLabels.drawSeriesTexts({ shared: !1, ttItems: a, i: i, j: s }),
                      this.tooltipUtil.hasBars() && o.tooltipPosition.moveStickyTooltipOverBars(s),
                      l && o.tooltipPosition.moveMarkers(i, s);
                },
              },
            ]),
            t
          );
        })(),
        wt = (function () {
          function t(e) {
            o(this, t),
              (this.w = e.w),
              (this.barCtx = e),
              (this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter),
              this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
          }
          return (
            c(t, [
              {
                key: "handleBarDataLabels",
                value: function (t) {
                  var e = t.x,
                    i = t.y,
                    s = t.y1,
                    a = t.y2,
                    n = t.i,
                    r = t.j,
                    o = t.realIndex,
                    l = t.series,
                    c = t.barHeight,
                    h = t.barWidth,
                    d = t.barYPosition,
                    u = t.visibleSeries,
                    p = t.renderedPath,
                    g = this.w,
                    f = new k(this.barCtx.ctx),
                    m = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[o] : this.barCtx.strokeWidth,
                    v = e + parseFloat(h * u),
                    x = i + parseFloat(c * u);
                  g.globals.isXNumeric &&
                    !g.globals.isBarHorizontal &&
                    ((v = e + parseFloat(h * (u + 1))), (x = i + parseFloat(c * (u + 1)) - m));
                  var b,
                    y,
                    w = null,
                    S = e,
                    C = i,
                    A = g.config.dataLabels,
                    E = this.barCtx.barOptions.dataLabels,
                    T = this.barCtx.barOptions.dataLabels.total;
                  void 0 !== d && this.barCtx.isRangeBar && ((x = d), (C = d));
                  var L = A.offsetX,
                    P = A.offsetY,
                    M = { width: 0, height: 0 };
                  if (g.config.dataLabels.enabled) {
                    var O = this.barCtx.series[n][r];
                    M = f.getTextRects(g.globals.yLabelFormatters[0](O), parseFloat(A.style.fontSize));
                  }
                  var I = {
                    x: e,
                    y: i,
                    i: n,
                    j: r,
                    realIndex: o,
                    renderedPath: p,
                    bcx: v,
                    bcy: x,
                    barHeight: c,
                    barWidth: h,
                    textRects: M,
                    strokeWidth: m,
                    dataLabelsX: S,
                    dataLabelsY: C,
                    dataLabelsConfig: A,
                    barDataLabelsConfig: E,
                    barTotalDataLabelsConfig: T,
                    offX: L,
                    offY: P,
                  };
                  return (
                    (y = this.barCtx.isHorizontal
                      ? this.calculateBarsDataLabelsPosition(I)
                      : this.calculateColumnsDataLabelsPosition(I)),
                    p.attr({ cy: y.bcy, cx: y.bcx, j: r, val: l[n][r], barHeight: c, barWidth: h }),
                    (b = this.drawCalculatedDataLabels({
                      x: y.dataLabelsX,
                      y: y.dataLabelsY,
                      val: this.barCtx.isRangeBar ? [s, a] : l[n][r],
                      i: o,
                      j: r,
                      barWidth: h,
                      barHeight: c,
                      textRects: M,
                      dataLabelsConfig: A,
                    })),
                    g.config.chart.stacked &&
                      T.enabled &&
                      (w = this.drawTotalDataLabels({
                        x: y.totalDataLabelsX,
                        y: y.totalDataLabelsY,
                        realIndex: o,
                        textAnchor: y.totalDataLabelsAnchor,
                        val: this.getStackedTotalDataLabel({ realIndex: o, j: r }),
                        dataLabelsConfig: A,
                        barTotalDataLabelsConfig: T,
                      })),
                    { dataLabels: b, totalDataLabels: w }
                  );
                },
              },
              {
                key: "getStackedTotalDataLabel",
                value: function (t) {
                  var e = t.realIndex,
                    i = t.j,
                    s = this.w,
                    a = this.barCtx.stackedSeriesTotals[i];
                  return (
                    this.totalFormatter &&
                      (a = this.totalFormatter(a, n(n({}, s), {}, { seriesIndex: e, dataPointIndex: i, w: s }))),
                    a
                  );
                },
              },
              {
                key: "calculateColumnsDataLabelsPosition",
                value: function (t) {
                  var e,
                    i,
                    s,
                    a = this.w,
                    n = t.i,
                    r = t.j,
                    o = t.realIndex,
                    l = t.y,
                    c = t.bcx,
                    h = t.barWidth,
                    d = t.barHeight,
                    u = t.textRects,
                    p = t.dataLabelsY,
                    g = t.dataLabelsConfig,
                    f = t.barDataLabelsConfig,
                    m = t.barTotalDataLabelsConfig,
                    v = t.strokeWidth,
                    x = t.offX,
                    b = t.offY;
                  d = Math.abs(d);
                  var y = "vertical" === a.config.plotOptions.bar.dataLabels.orientation;
                  c -= v / 2;
                  var w = a.globals.gridWidth / a.globals.dataPoints;
                  (e = a.globals.isXNumeric ? c - h / 2 + x : c - w + h / 2 + x),
                    y && (e = e + u.height / 2 - v / 2 - 2);
                  var S = this.barCtx.series[n][r] < 0,
                    C = l;
                  switch ((this.barCtx.isReversed && ((C = l - d + (S ? 2 * d : 0)), (l -= d)), f.position)) {
                    case "center":
                      p = y
                        ? S
                          ? C + d / 2 + b
                          : C + d / 2 - b
                        : S
                        ? C - d / 2 + u.height / 2 + b
                        : C + d / 2 + u.height / 2 - b;
                      break;
                    case "bottom":
                      p = y ? (S ? C + d + b : C + d - b) : S ? C - d + u.height + v + b : C + d - u.height / 2 + v - b;
                      break;
                    case "top":
                      p = y ? (S ? C + b : C - b) : S ? C - u.height / 2 - b : C + u.height + b;
                  }
                  if (this.barCtx.lastActiveBarSerieIndex === o && m.enabled) {
                    var A = new k(this.barCtx.ctx).getTextRects(
                      this.getStackedTotalDataLabel({ realIndex: o, j: r }),
                      g.fontSize
                    );
                    (i = S ? C - A.height / 2 - b - m.offsetY + 18 : C + A.height + b + m.offsetY - 18),
                      (s = e + m.offsetX);
                  }
                  return (
                    a.config.chart.stacked ||
                      (p < 0 ? (p = 0 + v) : p + u.height / 3 > a.globals.gridHeight && (p = a.globals.gridHeight - v)),
                    {
                      bcx: c,
                      bcy: l,
                      dataLabelsX: e,
                      dataLabelsY: p,
                      totalDataLabelsX: s,
                      totalDataLabelsY: i,
                      totalDataLabelsAnchor: "middle",
                    }
                  );
                },
              },
              {
                key: "calculateBarsDataLabelsPosition",
                value: function (t) {
                  var e = this.w,
                    i = t.x,
                    s = t.i,
                    a = t.j,
                    n = t.realIndex,
                    r = t.bcy,
                    o = t.barHeight,
                    l = t.barWidth,
                    c = t.textRects,
                    h = t.dataLabelsX,
                    d = t.strokeWidth,
                    u = t.dataLabelsConfig,
                    p = t.barDataLabelsConfig,
                    g = t.barTotalDataLabelsConfig,
                    f = t.offX,
                    m = t.offY,
                    v = e.globals.gridHeight / e.globals.dataPoints;
                  l = Math.abs(l);
                  var x,
                    b,
                    y = r - (this.barCtx.isRangeBar ? 0 : v) + o / 2 + c.height / 2 + m - 3,
                    w = "start",
                    S = this.barCtx.series[s][a] < 0,
                    C = i;
                  switch (
                    (this.barCtx.isReversed && ((C = i + l - (S ? 2 * l : 0)), (i = e.globals.gridWidth - l)),
                    p.position)
                  ) {
                    case "center":
                      h = S ? C + l / 2 - f : Math.max(c.width / 2, C - l / 2) + f;
                      break;
                    case "bottom":
                      h = S ? C + l - d - Math.round(c.width / 2) - f : C - l + d + Math.round(c.width / 2) + f;
                      break;
                    case "top":
                      h = S ? C - d + Math.round(c.width / 2) - f : C - d - Math.round(c.width / 2) + f;
                  }
                  if (this.barCtx.lastActiveBarSerieIndex === n && g.enabled) {
                    var A = new k(this.barCtx.ctx).getTextRects(
                      this.getStackedTotalDataLabel({ realIndex: n, j: a }),
                      u.fontSize
                    );
                    S
                      ? ((x = C - d + Math.round(A.width / 2) - f - g.offsetX - 15), (w = "end"))
                      : (x = C - d - Math.round(A.width / 2) + f + g.offsetX + 15),
                      (b = y + g.offsetY);
                  }
                  return (
                    e.config.chart.stacked ||
                      (h < 0
                        ? (h = h + c.width + d)
                        : h + c.width / 2 > e.globals.gridWidth && (h = e.globals.gridWidth - c.width - d)),
                    {
                      bcx: i,
                      bcy: r,
                      dataLabelsX: h,
                      dataLabelsY: y,
                      totalDataLabelsX: x,
                      totalDataLabelsY: b,
                      totalDataLabelsAnchor: w,
                    }
                  );
                },
              },
              {
                key: "drawCalculatedDataLabels",
                value: function (t) {
                  var e = t.x,
                    i = t.y,
                    s = t.val,
                    a = t.i,
                    r = t.j,
                    o = t.textRects,
                    l = t.barHeight,
                    c = t.barWidth,
                    h = t.dataLabelsConfig,
                    d = this.w,
                    u = "rotate(0)";
                  "vertical" === d.config.plotOptions.bar.dataLabels.orientation &&
                    (u = "rotate(-90, ".concat(e, ", ").concat(i, ")"));
                  var p = new H(this.barCtx.ctx),
                    g = new k(this.barCtx.ctx),
                    f = h.formatter,
                    m = null,
                    v = d.globals.collapsedSeriesIndices.indexOf(a) > -1;
                  if (h.enabled && !v) {
                    m = g.group({ class: "apexcharts-data-labels", transform: u });
                    var x = "";
                    void 0 !== s && (x = f(s, n(n({}, d), {}, { seriesIndex: a, dataPointIndex: r, w: d })));
                    var b = d.globals.series[a][r] < 0,
                      y = d.config.plotOptions.bar.dataLabels.position;
                    "vertical" === d.config.plotOptions.bar.dataLabels.orientation &&
                      ("top" === y && (h.textAnchor = b ? "end" : "start"),
                      "center" === y && (h.textAnchor = "middle"),
                      "bottom" === y && (h.textAnchor = b ? "end" : "start")),
                      this.barCtx.isRangeBar &&
                        this.barCtx.barOptions.dataLabels.hideOverflowingLabels &&
                        c < g.getTextRects(x, parseFloat(h.style.fontSize)).width &&
                        (x = ""),
                      d.config.chart.stacked &&
                        this.barCtx.barOptions.dataLabels.hideOverflowingLabels &&
                        (this.barCtx.isHorizontal
                          ? o.width / 1.6 > Math.abs(c) && (x = "")
                          : o.height / 1.6 > Math.abs(l) && (x = ""));
                    var w = n({}, h);
                    this.barCtx.isHorizontal &&
                      s < 0 &&
                      ("start" === h.textAnchor
                        ? (w.textAnchor = "end")
                        : "end" === h.textAnchor && (w.textAnchor = "start")),
                      p.plotDataLabelsText({
                        x: e,
                        y: i,
                        text: x,
                        i: a,
                        j: r,
                        parent: m,
                        dataLabelsConfig: w,
                        alwaysDrawDataLabel: !0,
                        offsetCorrection: !0,
                      });
                  }
                  return m;
                },
              },
              {
                key: "drawTotalDataLabels",
                value: function (t) {
                  var e,
                    i = t.x,
                    s = t.y,
                    a = t.val,
                    n = t.realIndex,
                    r = t.textAnchor,
                    o = t.barTotalDataLabelsConfig,
                    l = new k(this.barCtx.ctx);
                  return (
                    o.enabled &&
                      void 0 !== i &&
                      void 0 !== s &&
                      this.barCtx.lastActiveBarSerieIndex === n &&
                      (e = l.drawText({
                        x: i,
                        y: s,
                        foreColor: o.style.color,
                        text: a,
                        textAnchor: r,
                        fontFamily: o.style.fontFamily,
                        fontSize: o.style.fontSize,
                        fontWeight: o.style.fontWeight,
                      })),
                    e
                  );
                },
              },
            ]),
            t
          );
        })(),
        kt = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.barCtx = e);
          }
          return (
            c(t, [
              {
                key: "initVariables",
                value: function (t) {
                  var e = this.w;
                  (this.barCtx.series = t),
                    (this.barCtx.totalItems = 0),
                    (this.barCtx.seriesLen = 0),
                    (this.barCtx.visibleI = -1),
                    (this.barCtx.visibleItems = 1);
                  for (var i = 0; i < t.length; i++)
                    if (
                      (t[i].length > 0 &&
                        ((this.barCtx.seriesLen = this.barCtx.seriesLen + 1), (this.barCtx.totalItems += t[i].length)),
                      e.globals.isXNumeric)
                    )
                      for (var s = 0; s < t[i].length; s++)
                        e.globals.seriesX[i][s] > e.globals.minX &&
                          e.globals.seriesX[i][s] < e.globals.maxX &&
                          this.barCtx.visibleItems++;
                    else this.barCtx.visibleItems = e.globals.dataPoints;
                  0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1),
                    (this.barCtx.zeroSerieses = []),
                    (this.barCtx.radiusOnSeriesNumber = t.length - 1),
                    e.globals.comboCharts || this.checkZeroSeries({ series: t });
                },
              },
              {
                key: "initialPositions",
                value: function () {
                  var t,
                    e,
                    i,
                    s,
                    a,
                    n,
                    r,
                    o,
                    l = this.w,
                    c = l.globals.dataPoints;
                  this.barCtx.isRangeBar && (c = l.globals.labels.length);
                  var h = this.barCtx.seriesLen;
                  if ((l.config.plotOptions.bar.rangeBarGroupRows && (h = 1), this.barCtx.isHorizontal))
                    (a = (i = l.globals.gridHeight / c) / h),
                      l.globals.isXNumeric &&
                        (a = (i = l.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen),
                      (a = (a * parseInt(this.barCtx.barOptions.barHeight, 10)) / 100),
                      (o =
                        this.barCtx.baseLineInvertedY +
                        l.globals.padHorizontal +
                        (this.barCtx.isReversed ? l.globals.gridWidth : 0) -
                        (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0)),
                      (e = (i - a * this.barCtx.seriesLen) / 2);
                  else {
                    if (
                      ((s = l.globals.gridWidth / this.barCtx.visibleItems),
                      l.config.xaxis.convertedCatToNumeric && (s = l.globals.gridWidth / l.globals.dataPoints),
                      (n = ((s / this.barCtx.seriesLen) * parseInt(this.barCtx.barOptions.columnWidth, 10)) / 100),
                      l.globals.isXNumeric)
                    ) {
                      var d = this.barCtx.xRatio;
                      l.config.xaxis.convertedCatToNumeric && (d = this.barCtx.initialXRatio),
                        l.globals.minXDiff &&
                          0.5 !== l.globals.minXDiff &&
                          l.globals.minXDiff / d > 0 &&
                          (s = l.globals.minXDiff / d),
                        (n = ((s / this.barCtx.seriesLen) * parseInt(this.barCtx.barOptions.columnWidth, 10)) / 100) <
                          1 && (n = 1);
                    }
                    (r =
                      l.globals.gridHeight -
                      this.barCtx.baseLineY[this.barCtx.yaxisIndex] -
                      (this.barCtx.isReversed ? l.globals.gridHeight : 0) +
                      (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0)),
                      (t = l.globals.padHorizontal + (s - n * this.barCtx.seriesLen) / 2);
                  }
                  return { x: t, y: e, yDivision: i, xDivision: s, barHeight: a, barWidth: n, zeroH: r, zeroW: o };
                },
              },
              {
                key: "getPathFillColor",
                value: function (t, e, i, s) {
                  var a,
                    n,
                    r,
                    o,
                    l = this.w,
                    c = new _(this.barCtx.ctx),
                    h = null,
                    d = this.barCtx.barOptions.distributed ? i : e;
                  return (
                    this.barCtx.barOptions.colors.ranges.length > 0 &&
                      this.barCtx.barOptions.colors.ranges.map(function (s) {
                        t[e][i] >= s.from && t[e][i] <= s.to && (h = s.color);
                      }),
                    l.config.series[e].data[i] &&
                      l.config.series[e].data[i].fillColor &&
                      (h = l.config.series[e].data[i].fillColor),
                    c.fillPath({
                      seriesNumber: this.barCtx.barOptions.distributed ? d : s,
                      dataPointIndex: i,
                      color: h,
                      value: t[e][i],
                      fillConfig: null === (a = l.config.series[e].data[i]) || void 0 === a ? void 0 : a.fill,
                      fillType:
                        null !== (n = l.config.series[e].data[i]) &&
                        void 0 !== n &&
                        null !== (r = n.fill) &&
                        void 0 !== r &&
                        r.type
                          ? null === (o = l.config.series[e].data[i]) || void 0 === o
                            ? void 0
                            : o.fill.type
                          : l.config.fill.type,
                    })
                  );
                },
              },
              {
                key: "getStrokeWidth",
                value: function (t, e, i) {
                  var s = 0,
                    a = this.w;
                  return (
                    void 0 === this.barCtx.series[t][e] || null === this.barCtx.series[t][e]
                      ? (this.barCtx.isNullValue = !0)
                      : (this.barCtx.isNullValue = !1),
                    a.config.stroke.show &&
                      (this.barCtx.isNullValue ||
                        (s = Array.isArray(this.barCtx.strokeWidth)
                          ? this.barCtx.strokeWidth[i]
                          : this.barCtx.strokeWidth)),
                    s
                  );
                },
              },
              {
                key: "shouldApplyRadius",
                value: function (t) {
                  var e = this.w,
                    i = !1;
                  return (
                    e.config.plotOptions.bar.borderRadius > 0 &&
                      (e.config.chart.stacked && "last" === e.config.plotOptions.bar.borderRadiusWhenStacked
                        ? this.barCtx.lastActiveBarSerieIndex === t && (i = !0)
                        : (i = !0)),
                    i
                  );
                },
              },
              {
                key: "barBackground",
                value: function (t) {
                  var e = t.j,
                    i = t.i,
                    s = t.x1,
                    a = t.x2,
                    n = t.y1,
                    r = t.y2,
                    o = t.elSeries,
                    l = this.w,
                    c = new k(this.barCtx.ctx),
                    h = new Y(this.barCtx.ctx).getActiveConfigSeriesIndex();
                  if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && h === i) {
                    e >= this.barCtx.barOptions.colors.backgroundBarColors.length &&
                      (e %= this.barCtx.barOptions.colors.backgroundBarColors.length);
                    var d = this.barCtx.barOptions.colors.backgroundBarColors[e],
                      u = c.drawRect(
                        void 0 !== s ? s : 0,
                        void 0 !== n ? n : 0,
                        void 0 !== a ? a : l.globals.gridWidth,
                        void 0 !== r ? r : l.globals.gridHeight,
                        this.barCtx.barOptions.colors.backgroundBarRadius,
                        d,
                        this.barCtx.barOptions.colors.backgroundBarOpacity
                      );
                    o.add(u), u.node.classList.add("apexcharts-backgroundBar");
                  }
                },
              },
              {
                key: "getColumnPaths",
                value: function (t) {
                  var e,
                    i = t.barWidth,
                    s = t.barXPosition,
                    a = t.y1,
                    n = t.y2,
                    r = t.strokeWidth,
                    o = t.realIndex,
                    l = t.i,
                    c = t.j,
                    h = t.w,
                    d = new k(this.barCtx.ctx);
                  (r = Array.isArray(r) ? r[o] : r) || (r = 0);
                  var u = i,
                    p = s;
                  null !== (e = h.config.series[o].data[c]) &&
                    void 0 !== e &&
                    e.columnWidthOffset &&
                    ((p = s - h.config.series[o].data[c].columnWidthOffset / 2),
                    (u = i + h.config.series[o].data[c].columnWidthOffset));
                  var g = p,
                    f = p + u;
                  (a += 0.001), (n += 0.001);
                  var m = d.move(g, a),
                    v = d.move(g, a),
                    x = d.line(f - r, a);
                  return (
                    h.globals.previousPaths.length > 0 && (v = this.barCtx.getPreviousPath(o, c, !1)),
                    (m =
                      m +
                      d.line(g, n) +
                      d.line(f - r, n) +
                      d.line(f - r, a) +
                      ("around" === h.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z")),
                    (v =
                      v +
                      d.line(g, a) +
                      x +
                      x +
                      x +
                      x +
                      x +
                      d.line(g, a) +
                      ("around" === h.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z")),
                    this.shouldApplyRadius(o) && (m = d.roundPathCorners(m, h.config.plotOptions.bar.borderRadius)),
                    h.config.chart.stacked &&
                      (this.barCtx.yArrj.push(n),
                      this.barCtx.yArrjF.push(Math.abs(a - n)),
                      this.barCtx.yArrjVal.push(this.barCtx.series[l][c])),
                    { pathTo: m, pathFrom: v }
                  );
                },
              },
              {
                key: "getBarpaths",
                value: function (t) {
                  var e,
                    i = t.barYPosition,
                    s = t.barHeight,
                    a = t.x1,
                    n = t.x2,
                    r = t.strokeWidth,
                    o = t.realIndex,
                    l = t.i,
                    c = t.j,
                    h = t.w,
                    d = new k(this.barCtx.ctx);
                  (r = Array.isArray(r) ? r[o] : r) || (r = 0);
                  var u = i,
                    p = s;
                  null !== (e = h.config.series[o].data[c]) &&
                    void 0 !== e &&
                    e.barHeightOffset &&
                    ((u = i - h.config.series[o].data[c].barHeightOffset / 2),
                    (p = s + h.config.series[o].data[c].barHeightOffset));
                  var g = u,
                    f = u + p;
                  (a += 0.001), (n += 0.001);
                  var m = d.move(a, g),
                    v = d.move(a, g);
                  h.globals.previousPaths.length > 0 && (v = this.barCtx.getPreviousPath(o, c, !1));
                  var x = d.line(a, f - r);
                  return (
                    (m =
                      m +
                      d.line(n, g) +
                      d.line(n, f - r) +
                      x +
                      ("around" === h.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z")),
                    (v =
                      v +
                      d.line(a, g) +
                      x +
                      x +
                      x +
                      x +
                      x +
                      d.line(a, g) +
                      ("around" === h.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z")),
                    this.shouldApplyRadius(o) && (m = d.roundPathCorners(m, h.config.plotOptions.bar.borderRadius)),
                    h.config.chart.stacked &&
                      (this.barCtx.xArrj.push(n),
                      this.barCtx.xArrjF.push(Math.abs(a - n)),
                      this.barCtx.xArrjVal.push(this.barCtx.series[l][c])),
                    { pathTo: m, pathFrom: v }
                  );
                },
              },
              {
                key: "checkZeroSeries",
                value: function (t) {
                  for (var e = t.series, i = this.w, s = 0; s < e.length; s++) {
                    for (var a = 0, n = 0; n < e[i.globals.maxValsInArrayIndex].length; n++) a += e[s][n];
                    0 === a && this.barCtx.zeroSerieses.push(s);
                  }
                  for (var r = e.length - 1; r >= 0; r--)
                    this.barCtx.zeroSerieses.indexOf(r) > -1 &&
                      r === this.radiusOnSeriesNumber &&
                      (this.barCtx.radiusOnSeriesNumber -= 1);
                  for (var o = e.length - 1; o >= 0; o--)
                    i.globals.collapsedSeriesIndices.indexOf(this.barCtx.radiusOnSeriesNumber) > -1 &&
                      (this.barCtx.radiusOnSeriesNumber -= 1);
                },
              },
              {
                key: "getXForValue",
                value: function (t, e) {
                  var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                    s = i ? e : null;
                  return (
                    null != t &&
                      (s =
                        e +
                        t / this.barCtx.invertedYRatio -
                        2 * (this.barCtx.isReversed ? t / this.barCtx.invertedYRatio : 0)),
                    s
                  );
                },
              },
              {
                key: "getYForValue",
                value: function (t, e) {
                  var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                    s = i ? e : null;
                  return (
                    null != t &&
                      (s =
                        e -
                        t / this.barCtx.yRatio[this.barCtx.yaxisIndex] +
                        2 * (this.barCtx.isReversed ? t / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)),
                    s
                  );
                },
              },
              {
                key: "getGoalValues",
                value: function (t, e, i, s, a) {
                  var n = this,
                    r = this.w,
                    o = [];
                  return (
                    r.globals.seriesGoals[s] &&
                      r.globals.seriesGoals[s][a] &&
                      Array.isArray(r.globals.seriesGoals[s][a]) &&
                      r.globals.seriesGoals[s][a].forEach(function (s) {
                        var a;
                        o.push(
                          (h((a = {}), t, "x" === t ? n.getXForValue(s.value, e, !1) : n.getYForValue(s.value, i, !1)),
                          h(a, "attrs", s),
                          a)
                        );
                      }),
                    o
                  );
                },
              },
              {
                key: "drawGoalLine",
                value: function (t) {
                  var e = t.barXPosition,
                    i = t.barYPosition,
                    s = t.goalX,
                    a = t.goalY,
                    n = t.barWidth,
                    r = t.barHeight,
                    o = new k(this.barCtx.ctx),
                    l = o.group({ className: "apexcharts-bar-goals-groups" }),
                    c = null;
                  return (
                    this.barCtx.isHorizontal
                      ? Array.isArray(s) &&
                        s.forEach(function (t) {
                          var e = void 0 !== t.attrs.strokeHeight ? t.attrs.strokeHeight : r / 2,
                            s = i + e + r / 2;
                          (c = o.drawLine(
                            t.x,
                            s - 2 * e,
                            t.x,
                            s,
                            t.attrs.strokeColor ? t.attrs.strokeColor : void 0,
                            t.attrs.strokeDashArray,
                            t.attrs.strokeWidth ? t.attrs.strokeWidth : 2,
                            t.attrs.strokeLineCap
                          )),
                            l.add(c);
                        })
                      : Array.isArray(a) &&
                        a.forEach(function (t) {
                          var i = void 0 !== t.attrs.strokeWidth ? t.attrs.strokeWidth : n / 2,
                            s = e + i + n / 2;
                          (c = o.drawLine(
                            s - 2 * i,
                            t.y,
                            s,
                            t.y,
                            t.attrs.strokeColor ? t.attrs.strokeColor : void 0,
                            t.attrs.strokeDashArray,
                            t.attrs.strokeHeight ? t.attrs.strokeHeight : 2,
                            t.attrs.strokeLineCap
                          )),
                            l.add(c);
                        }),
                    l
                  );
                },
              },
            ]),
            t
          );
        })(),
        St = (function () {
          function t(e, i) {
            o(this, t), (this.ctx = e), (this.w = e.w);
            var s = this.w;
            (this.barOptions = s.config.plotOptions.bar),
              (this.isHorizontal = this.barOptions.horizontal),
              (this.strokeWidth = s.config.stroke.width),
              (this.isNullValue = !1),
              (this.isRangeBar = s.globals.seriesRange.length && this.isHorizontal),
              (this.xyRatios = i),
              null !== this.xyRatios &&
                ((this.xRatio = i.xRatio),
                (this.initialXRatio = i.initialXRatio),
                (this.yRatio = i.yRatio),
                (this.invertedXRatio = i.invertedXRatio),
                (this.invertedYRatio = i.invertedYRatio),
                (this.baseLineY = i.baseLineY),
                (this.baseLineInvertedY = i.baseLineInvertedY)),
              (this.yaxisIndex = 0),
              (this.seriesLen = 0);
            var a = new Y(this.ctx);
            this.lastActiveBarSerieIndex = a.getActiveConfigSeriesIndex("desc", ["bar", "column"]);
            var n = a.getBarSeriesIndices(),
              r = new S(this.ctx);
            (this.stackedSeriesTotals = r.getStackedSeriesTotals(
              this.w.config.series
                .map(function (t, e) {
                  return -1 === n.indexOf(e) ? e : -1;
                })
                .filter(function (t) {
                  return -1 !== t;
                })
            )),
              (this.barHelpers = new kt(this));
          }
          return (
            c(t, [
              {
                key: "draw",
                value: function (t, e) {
                  var i = this.w,
                    s = new k(this.ctx),
                    a = new S(this.ctx, i);
                  (t = a.getLogSeries(t)),
                    (this.series = t),
                    (this.yRatio = a.getLogYRatios(this.yRatio)),
                    this.barHelpers.initVariables(t);
                  var r = s.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
                  i.config.dataLabels.enabled &&
                    this.totalItems > this.barOptions.dataLabels.maxItems &&
                    console.warn(
                      "WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering."
                    );
                  for (var o = 0, l = 0; o < t.length; o++, l++) {
                    var c,
                      h,
                      d,
                      u,
                      p = void 0,
                      g = void 0,
                      f = [],
                      m = [],
                      v = i.globals.comboCharts ? e[o] : o,
                      x = s.group({
                        class: "apexcharts-series",
                        rel: o + 1,
                        seriesName: b.escapeString(i.globals.seriesNames[v]),
                        "data:realIndex": v,
                      });
                    this.ctx.series.addCollapsedClassToSeries(x, v),
                      t[o].length > 0 && (this.visibleI = this.visibleI + 1);
                    var y = 0,
                      w = 0;
                    this.yRatio.length > 1 && (this.yaxisIndex = v),
                      (this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed);
                    var C = this.barHelpers.initialPositions();
                    (g = C.y),
                      (y = C.barHeight),
                      (h = C.yDivision),
                      (u = C.zeroW),
                      (p = C.x),
                      (w = C.barWidth),
                      (c = C.xDivision),
                      (d = C.zeroH),
                      this.horizontal || m.push(p + w / 2);
                    for (
                      var A = s.group({ class: "apexcharts-datalabels", "data:realIndex": v }),
                        E = s.group({ class: "apexcharts-bar-goals-markers", style: "pointer-events: none" }),
                        T = 0;
                      T < i.globals.dataPoints;
                      T++
                    ) {
                      var L = this.barHelpers.getStrokeWidth(o, T, v),
                        P = null,
                        M = { indexes: { i: o, j: T, realIndex: v, bc: l }, x: p, y: g, strokeWidth: L, elSeries: x };
                      this.isHorizontal
                        ? ((P = this.drawBarPaths(n(n({}, M), {}, { barHeight: y, zeroW: u, yDivision: h }))),
                          (w = this.series[o][T] / this.invertedYRatio))
                        : ((P = this.drawColumnPaths(n(n({}, M), {}, { xDivision: c, barWidth: w, zeroH: d }))),
                          (y = this.series[o][T] / this.yRatio[this.yaxisIndex]));
                      var O = this.barHelpers.drawGoalLine({
                        barXPosition: P.barXPosition,
                        barYPosition: P.barYPosition,
                        goalX: P.goalX,
                        goalY: P.goalY,
                        barHeight: y,
                        barWidth: w,
                      });
                      O && E.add(O), (g = P.y), (p = P.x), T > 0 && m.push(p + w / 2), f.push(g);
                      var I = this.barHelpers.getPathFillColor(t, o, T, v);
                      this.renderSeries({
                        realIndex: v,
                        pathFill: I,
                        j: T,
                        i: o,
                        pathFrom: P.pathFrom,
                        pathTo: P.pathTo,
                        strokeWidth: L,
                        elSeries: x,
                        x: p,
                        y: g,
                        series: t,
                        barHeight: y,
                        barWidth: w,
                        elDataLabelsWrap: A,
                        elGoalsMarkers: E,
                        visibleSeries: this.visibleI,
                        type: "bar",
                      });
                    }
                    (i.globals.seriesXvalues[v] = m), (i.globals.seriesYvalues[v] = f), r.add(x);
                  }
                  return r;
                },
              },
              {
                key: "renderSeries",
                value: function (t) {
                  var e = t.realIndex,
                    i = t.pathFill,
                    s = t.lineFill,
                    a = t.j,
                    n = t.i,
                    r = t.pathFrom,
                    o = t.pathTo,
                    l = t.strokeWidth,
                    c = t.elSeries,
                    h = t.x,
                    d = t.y,
                    u = t.y1,
                    p = t.y2,
                    g = t.series,
                    f = t.barHeight,
                    m = t.barWidth,
                    v = t.barYPosition,
                    x = t.elDataLabelsWrap,
                    b = t.elGoalsMarkers,
                    y = t.visibleSeries,
                    S = t.type,
                    C = this.w,
                    A = new k(this.ctx);
                  s || (s = this.barOptions.distributed ? C.globals.stroke.colors[a] : C.globals.stroke.colors[e]),
                    C.config.series[n].data[a] &&
                      C.config.series[n].data[a].strokeColor &&
                      (s = C.config.series[n].data[a].strokeColor),
                    this.isNullValue && (i = "none");
                  var E =
                      ((a / C.config.chart.animations.animateGradually.delay) *
                        (C.config.chart.animations.speed / C.globals.dataPoints)) /
                      2.4,
                    T = A.renderPaths({
                      i: n,
                      j: a,
                      realIndex: e,
                      pathFrom: r,
                      pathTo: o,
                      stroke: s,
                      strokeWidth: l,
                      strokeLineCap: C.config.stroke.lineCap,
                      fill: i,
                      animationDelay: E,
                      initialSpeed: C.config.chart.animations.speed,
                      dataChangeSpeed: C.config.chart.animations.dynamicAnimation.speed,
                      className: "apexcharts-".concat(S, "-area"),
                    });
                  T.attr("clip-path", "url(#gridRectMask".concat(C.globals.cuid, ")"));
                  var L = C.config.forecastDataPoints;
                  L.count > 0 &&
                    a >= C.globals.dataPoints - L.count &&
                    (T.node.setAttribute("stroke-dasharray", L.dashArray),
                    T.node.setAttribute("stroke-width", L.strokeWidth),
                    T.node.setAttribute("fill-opacity", L.fillOpacity)),
                    void 0 !== u && void 0 !== p && (T.attr("data-range-y1", u), T.attr("data-range-y2", p)),
                    new w(this.ctx).setSelectionFilter(T, e, a),
                    c.add(T);
                  var P = new wt(this).handleBarDataLabels({
                    x: h,
                    y: d,
                    y1: u,
                    y2: p,
                    i: n,
                    j: a,
                    series: g,
                    realIndex: e,
                    barHeight: f,
                    barWidth: m,
                    barYPosition: v,
                    renderedPath: T,
                    visibleSeries: y,
                  });
                  return (
                    null !== P.dataLabels && x.add(P.dataLabels),
                    P.totalDataLabels && x.add(P.totalDataLabels),
                    c.add(x),
                    b && c.add(b),
                    c
                  );
                },
              },
              {
                key: "drawBarPaths",
                value: function (t) {
                  var e = t.indexes,
                    i = t.barHeight,
                    s = t.strokeWidth,
                    a = t.zeroW,
                    n = t.x,
                    r = t.y,
                    o = t.yDivision,
                    l = t.elSeries,
                    c = this.w,
                    h = e.i,
                    d = e.j;
                  c.globals.isXNumeric && (r = (c.globals.seriesX[h][d] - c.globals.minX) / this.invertedXRatio - i);
                  var u = r + i * this.visibleI;
                  n = this.barHelpers.getXForValue(this.series[h][d], a);
                  var p = this.barHelpers.getBarpaths({
                    barYPosition: u,
                    barHeight: i,
                    x1: a,
                    x2: n,
                    strokeWidth: s,
                    series: this.series,
                    realIndex: e.realIndex,
                    i: h,
                    j: d,
                    w: c,
                  });
                  return (
                    c.globals.isXNumeric || (r += o),
                    this.barHelpers.barBackground({
                      j: d,
                      i: h,
                      y1: u - i * this.visibleI,
                      y2: i * this.seriesLen,
                      elSeries: l,
                    }),
                    {
                      pathTo: p.pathTo,
                      pathFrom: p.pathFrom,
                      x: n,
                      y: r,
                      goalX: this.barHelpers.getGoalValues("x", a, null, h, d),
                      barYPosition: u,
                    }
                  );
                },
              },
              {
                key: "drawColumnPaths",
                value: function (t) {
                  var e = t.indexes,
                    i = t.x,
                    s = t.y,
                    a = t.xDivision,
                    n = t.barWidth,
                    r = t.zeroH,
                    o = t.strokeWidth,
                    l = t.elSeries,
                    c = this.w,
                    h = e.realIndex,
                    d = e.i,
                    u = e.j,
                    p = e.bc;
                  if (c.globals.isXNumeric) {
                    var g = h;
                    c.globals.seriesX[h].length || (g = c.globals.maxValsInArrayIndex),
                      (i = (c.globals.seriesX[g][u] - c.globals.minX) / this.xRatio - (n * this.seriesLen) / 2);
                  }
                  var f = i + n * this.visibleI;
                  s = this.barHelpers.getYForValue(this.series[d][u], r);
                  var m = this.barHelpers.getColumnPaths({
                    barXPosition: f,
                    barWidth: n,
                    y1: r,
                    y2: s,
                    strokeWidth: o,
                    series: this.series,
                    realIndex: e.realIndex,
                    i: d,
                    j: u,
                    w: c,
                  });
                  return (
                    c.globals.isXNumeric || (i += a),
                    this.barHelpers.barBackground({
                      bc: p,
                      j: u,
                      i: d,
                      x1: f - o / 2 - n * this.visibleI,
                      x2: n * this.seriesLen + o / 2,
                      elSeries: l,
                    }),
                    {
                      pathTo: m.pathTo,
                      pathFrom: m.pathFrom,
                      x: i,
                      y: s,
                      goalY: this.barHelpers.getGoalValues("y", null, r, d, u),
                      barXPosition: f,
                    }
                  );
                },
              },
              {
                key: "getPreviousPath",
                value: function (t, e) {
                  for (var i, s = this.w, a = 0; a < s.globals.previousPaths.length; a++) {
                    var n = s.globals.previousPaths[a];
                    n.paths &&
                      n.paths.length > 0 &&
                      parseInt(n.realIndex, 10) === parseInt(t, 10) &&
                      void 0 !== s.globals.previousPaths[a].paths[e] &&
                      (i = s.globals.previousPaths[a].paths[e].d);
                  }
                  return i;
                },
              },
            ]),
            t
          );
        })(),
        Ct = (function (t) {
          d(i, St);
          var e = f(i);
          function i() {
            return o(this, i), e.apply(this, arguments);
          }
          return (
            c(i, [
              {
                key: "draw",
                value: function (t, e) {
                  var i = this,
                    s = this.w;
                  (this.graphics = new k(this.ctx)), (this.bar = new St(this.ctx, this.xyRatios));
                  var a = new S(this.ctx, s);
                  (t = a.getLogSeries(t)),
                    (this.yRatio = a.getLogYRatios(this.yRatio)),
                    this.barHelpers.initVariables(t),
                    "100%" === s.config.chart.stackType && (t = s.globals.seriesPercent.slice()),
                    (this.series = t),
                    (this.totalItems = 0),
                    (this.prevY = []),
                    (this.prevX = []),
                    (this.prevYF = []),
                    (this.prevXF = []),
                    (this.prevYVal = []),
                    (this.prevXVal = []),
                    (this.xArrj = []),
                    (this.xArrjF = []),
                    (this.xArrjVal = []),
                    (this.yArrj = []),
                    (this.yArrjF = []),
                    (this.yArrjVal = []);
                  for (var r = 0; r < t.length; r++) t[r].length > 0 && (this.totalItems += t[r].length);
                  for (
                    var o = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }),
                      l = 0,
                      c = 0,
                      h = function (a, r) {
                        var h = void 0,
                          d = void 0,
                          u = void 0,
                          p = void 0,
                          g = [],
                          f = [],
                          m = s.globals.comboCharts ? e[a] : a;
                        i.yRatio.length > 1 && (i.yaxisIndex = m),
                          (i.isReversed = s.config.yaxis[i.yaxisIndex] && s.config.yaxis[i.yaxisIndex].reversed);
                        var v = i.graphics.group({
                          class: "apexcharts-series",
                          seriesName: b.escapeString(s.globals.seriesNames[m]),
                          rel: a + 1,
                          "data:realIndex": m,
                        });
                        i.ctx.series.addCollapsedClassToSeries(v, m);
                        var x = i.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": m }),
                          y = i.graphics.group({
                            class: "apexcharts-bar-goals-markers",
                            style: "pointer-events: none",
                          }),
                          w = 0,
                          k = 0,
                          S = i.initialPositions(l, c, h, d, u, p);
                        (c = S.y),
                          (w = S.barHeight),
                          (d = S.yDivision),
                          (p = S.zeroW),
                          (l = S.x),
                          (k = S.barWidth),
                          (h = S.xDivision),
                          (u = S.zeroH),
                          (i.yArrj = []),
                          (i.yArrjF = []),
                          (i.yArrjVal = []),
                          (i.xArrj = []),
                          (i.xArrjF = []),
                          (i.xArrjVal = []),
                          1 === i.prevY.length &&
                            i.prevY[0].every(function (t) {
                              return isNaN(t);
                            }) &&
                            ((i.prevY[0] = i.prevY[0].map(function (t) {
                              return u;
                            })),
                            (i.prevYF[0] = i.prevYF[0].map(function (t) {
                              return 0;
                            })));
                        for (var C = 0; C < s.globals.dataPoints; C++) {
                          var A = i.barHelpers.getStrokeWidth(a, C, m),
                            E = {
                              indexes: { i: a, j: C, realIndex: m, bc: r },
                              strokeWidth: A,
                              x: l,
                              y: c,
                              elSeries: v,
                            },
                            T = null;
                          i.isHorizontal
                            ? ((T = i.drawStackedBarPaths(n(n({}, E), {}, { zeroW: p, barHeight: w, yDivision: d }))),
                              (k = i.series[a][C] / i.invertedYRatio))
                            : ((T = i.drawStackedColumnPaths(n(n({}, E), {}, { xDivision: h, barWidth: k, zeroH: u }))),
                              (w = i.series[a][C] / i.yRatio[i.yaxisIndex]));
                          var L = i.barHelpers.drawGoalLine({
                            barXPosition: T.barXPosition,
                            barYPosition: T.barYPosition,
                            goalX: T.goalX,
                            goalY: T.goalY,
                            barHeight: w,
                            barWidth: k,
                          });
                          L && y.add(L), (c = T.y), (l = T.x), g.push(l), f.push(c);
                          var P = i.barHelpers.getPathFillColor(t, a, C, m);
                          v = i.renderSeries({
                            realIndex: m,
                            pathFill: P,
                            j: C,
                            i: a,
                            pathFrom: T.pathFrom,
                            pathTo: T.pathTo,
                            strokeWidth: A,
                            elSeries: v,
                            x: l,
                            y: c,
                            series: t,
                            barHeight: w,
                            barWidth: k,
                            elDataLabelsWrap: x,
                            elGoalsMarkers: y,
                            type: "bar",
                            visibleSeries: 0,
                          });
                        }
                        (s.globals.seriesXvalues[m] = g),
                          (s.globals.seriesYvalues[m] = f),
                          i.prevY.push(i.yArrj),
                          i.prevYF.push(i.yArrjF),
                          i.prevYVal.push(i.yArrjVal),
                          i.prevX.push(i.xArrj),
                          i.prevXF.push(i.xArrjF),
                          i.prevXVal.push(i.xArrjVal),
                          o.add(v);
                      },
                      d = 0,
                      u = 0;
                    d < t.length;
                    d++, u++
                  )
                    h(d, u);
                  return o;
                },
              },
              {
                key: "initialPositions",
                value: function (t, e, i, s, a, n) {
                  var r,
                    o,
                    l = this.w;
                  return (
                    this.isHorizontal
                      ? ((r =
                          ((r = s = l.globals.gridHeight / l.globals.dataPoints) *
                            parseInt(l.config.plotOptions.bar.barHeight, 10)) /
                          100),
                        (n =
                          this.baseLineInvertedY +
                          l.globals.padHorizontal +
                          (this.isReversed ? l.globals.gridWidth : 0) -
                          (this.isReversed ? 2 * this.baseLineInvertedY : 0)),
                        (e = (s - r) / 2))
                      : ((o = i = l.globals.gridWidth / l.globals.dataPoints),
                        (o =
                          l.globals.isXNumeric && l.globals.dataPoints > 1
                            ? ((i = l.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10)) / 100
                            : (o * parseInt(l.config.plotOptions.bar.columnWidth, 10)) / 100),
                        (a =
                          l.globals.gridHeight -
                          this.baseLineY[this.yaxisIndex] -
                          (this.isReversed ? l.globals.gridHeight : 0) +
                          (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0)),
                        (t = l.globals.padHorizontal + (i - o) / 2)),
                    { x: t, y: e, yDivision: s, xDivision: i, barHeight: r, barWidth: o, zeroH: a, zeroW: n }
                  );
                },
              },
              {
                key: "drawStackedBarPaths",
                value: function (t) {
                  for (
                    var e,
                      i = t.indexes,
                      s = t.barHeight,
                      a = t.strokeWidth,
                      n = t.zeroW,
                      r = t.x,
                      o = t.y,
                      l = t.yDivision,
                      c = t.elSeries,
                      h = this.w,
                      d = o,
                      u = i.i,
                      p = i.j,
                      g = 0,
                      f = 0;
                    f < this.prevXF.length;
                    f++
                  )
                    g += this.prevXF[f][p];
                  if (u > 0) {
                    var m = n;
                    this.prevXVal[u - 1][p] < 0
                      ? (m =
                          this.series[u][p] >= 0
                            ? this.prevX[u - 1][p] + g - 2 * (this.isReversed ? g : 0)
                            : this.prevX[u - 1][p])
                      : this.prevXVal[u - 1][p] >= 0 &&
                        (m =
                          this.series[u][p] >= 0
                            ? this.prevX[u - 1][p]
                            : this.prevX[u - 1][p] - g + 2 * (this.isReversed ? g : 0)),
                      (e = m);
                  } else e = n;
                  r =
                    null === this.series[u][p]
                      ? e
                      : e +
                        this.series[u][p] / this.invertedYRatio -
                        2 * (this.isReversed ? this.series[u][p] / this.invertedYRatio : 0);
                  var v = this.barHelpers.getBarpaths({
                    barYPosition: d,
                    barHeight: s,
                    x1: e,
                    x2: r,
                    strokeWidth: a,
                    series: this.series,
                    realIndex: i.realIndex,
                    i: u,
                    j: p,
                    w: h,
                  });
                  return (
                    this.barHelpers.barBackground({ j: p, i: u, y1: d, y2: s, elSeries: c }),
                    (o += l),
                    {
                      pathTo: v.pathTo,
                      pathFrom: v.pathFrom,
                      goalX: this.barHelpers.getGoalValues("x", n, null, u, p),
                      barYPosition: d,
                      x: r,
                      y: o,
                    }
                  );
                },
              },
              {
                key: "drawStackedColumnPaths",
                value: function (t) {
                  var e = t.indexes,
                    i = t.x,
                    s = t.y,
                    a = t.xDivision,
                    n = t.barWidth,
                    r = t.zeroH;
                  t.strokeWidth;
                  var o = t.elSeries,
                    l = this.w,
                    c = e.i,
                    h = e.j,
                    d = e.bc;
                  if (l.globals.isXNumeric) {
                    var u = l.globals.seriesX[c][h];
                    u || (u = 0), (i = (u - l.globals.minX) / this.xRatio - n / 2);
                  }
                  for (var p, g = i, f = 0, m = 0; m < this.prevYF.length; m++)
                    f += isNaN(this.prevYF[m][h]) ? 0 : this.prevYF[m][h];
                  if (
                    (c > 0 && !l.globals.isXNumeric) ||
                    (c > 0 && l.globals.isXNumeric && l.globals.seriesX[c - 1][h] === l.globals.seriesX[c][h])
                  ) {
                    var v,
                      x,
                      b = Math.min(this.yRatio.length + 1, c + 1);
                    if (void 0 !== this.prevY[c - 1])
                      for (var y = 1; y < b; y++)
                        if (!isNaN(this.prevY[c - y][h])) {
                          x = this.prevY[c - y][h];
                          break;
                        }
                    for (var w = 1; w < b; w++) {
                      if (this.prevYVal[c - w][h] < 0) {
                        v = this.series[c][h] >= 0 ? x - f + 2 * (this.isReversed ? f : 0) : x;
                        break;
                      }
                      if (this.prevYVal[c - w][h] >= 0) {
                        v = this.series[c][h] >= 0 ? x : x + f - 2 * (this.isReversed ? f : 0);
                        break;
                      }
                    }
                    void 0 === v && (v = l.globals.gridHeight),
                      (p =
                        this.prevYF[0].every(function (t) {
                          return 0 === t;
                        }) &&
                        this.prevYF.slice(1, c).every(function (t) {
                          return t.every(function (t) {
                            return isNaN(t);
                          });
                        })
                          ? r
                          : v);
                  } else p = r;
                  s =
                    p -
                    this.series[c][h] / this.yRatio[this.yaxisIndex] +
                    2 * (this.isReversed ? this.series[c][h] / this.yRatio[this.yaxisIndex] : 0);
                  var k = this.barHelpers.getColumnPaths({
                    barXPosition: g,
                    barWidth: n,
                    y1: p,
                    y2: s,
                    yRatio: this.yRatio[this.yaxisIndex],
                    strokeWidth: this.strokeWidth,
                    series: this.series,
                    realIndex: e.realIndex,
                    i: c,
                    j: h,
                    w: l,
                  });
                  return (
                    this.barHelpers.barBackground({ bc: d, j: h, i: c, x1: g, x2: n, elSeries: o }),
                    (i += a),
                    {
                      pathTo: k.pathTo,
                      pathFrom: k.pathFrom,
                      goalY: this.barHelpers.getGoalValues("y", null, r, c, h),
                      barXPosition: g,
                      x: l.globals.isXNumeric ? i - a : i,
                      y: s,
                    }
                  );
                },
              },
            ]),
            i
          );
        })(),
        At = (function (t) {
          d(i, St);
          var e = f(i);
          function i() {
            return o(this, i), e.apply(this, arguments);
          }
          return (
            c(i, [
              {
                key: "draw",
                value: function (t, e) {
                  var i = this,
                    s = this.w,
                    a = new k(this.ctx),
                    r = new _(this.ctx);
                  (this.candlestickOptions = this.w.config.plotOptions.candlestick),
                    (this.boxOptions = this.w.config.plotOptions.boxPlot),
                    (this.isHorizontal = s.config.plotOptions.bar.horizontal);
                  var o = new S(this.ctx, s);
                  (t = o.getLogSeries(t)),
                    (this.series = t),
                    (this.yRatio = o.getLogYRatios(this.yRatio)),
                    this.barHelpers.initVariables(t);
                  for (
                    var l = a.group({
                        class: "apexcharts-".concat(s.config.chart.type, "-series apexcharts-plot-series"),
                      }),
                      c = function (o) {
                        i.isBoxPlot = "boxPlot" === s.config.chart.type || "boxPlot" === s.config.series[o].type;
                        var c,
                          h,
                          d,
                          u,
                          p,
                          g,
                          f = void 0,
                          m = void 0,
                          v = [],
                          x = [],
                          y = s.globals.comboCharts ? e[o] : o,
                          w = a.group({
                            class: "apexcharts-series",
                            seriesName: b.escapeString(s.globals.seriesNames[y]),
                            rel: o + 1,
                            "data:realIndex": y,
                          });
                        i.ctx.series.addCollapsedClassToSeries(w, y),
                          t[o].length > 0 && (i.visibleI = i.visibleI + 1),
                          i.yRatio.length > 1 && (i.yaxisIndex = y);
                        var k = i.barHelpers.initialPositions();
                        (m = k.y),
                          (p = k.barHeight),
                          (h = k.yDivision),
                          (u = k.zeroW),
                          (f = k.x),
                          (g = k.barWidth),
                          (c = k.xDivision),
                          (d = k.zeroH),
                          x.push(f + g / 2);
                        for (
                          var S = a.group({ class: "apexcharts-datalabels", "data:realIndex": y }),
                            C = function (e) {
                              var a = i.barHelpers.getStrokeWidth(o, e, y),
                                l = null,
                                b = { indexes: { i: o, j: e, realIndex: y }, x: f, y: m, strokeWidth: a, elSeries: w };
                              (l = i.isHorizontal
                                ? i.drawHorizontalBoxPaths(n(n({}, b), {}, { yDivision: h, barHeight: p, zeroW: u }))
                                : i.drawVerticalBoxPaths(n(n({}, b), {}, { xDivision: c, barWidth: g, zeroH: d }))),
                                (m = l.y),
                                (f = l.x),
                                e > 0 && x.push(f + g / 2),
                                v.push(m),
                                l.pathTo.forEach(function (n, c) {
                                  var h =
                                      !i.isBoxPlot && i.candlestickOptions.wick.useFillColor
                                        ? l.color[c]
                                        : s.globals.stroke.colors[o],
                                    d = r.fillPath({
                                      seriesNumber: y,
                                      dataPointIndex: e,
                                      color: l.color[c],
                                      value: t[o][e],
                                    });
                                  i.renderSeries({
                                    realIndex: y,
                                    pathFill: d,
                                    lineFill: h,
                                    j: e,
                                    i: o,
                                    pathFrom: l.pathFrom,
                                    pathTo: n,
                                    strokeWidth: a,
                                    elSeries: w,
                                    x: f,
                                    y: m,
                                    series: t,
                                    barHeight: p,
                                    barWidth: g,
                                    elDataLabelsWrap: S,
                                    visibleSeries: i.visibleI,
                                    type: s.config.chart.type,
                                  });
                                });
                            },
                            A = 0;
                          A < s.globals.dataPoints;
                          A++
                        )
                          C(A);
                        (s.globals.seriesXvalues[y] = x), (s.globals.seriesYvalues[y] = v), l.add(w);
                      },
                      h = 0;
                    h < t.length;
                    h++
                  )
                    c(h);
                  return l;
                },
              },
              {
                key: "drawVerticalBoxPaths",
                value: function (t) {
                  var e = t.indexes,
                    i = t.x;
                  t.y;
                  var s = t.xDivision,
                    a = t.barWidth,
                    n = t.zeroH,
                    r = t.strokeWidth,
                    o = this.w,
                    l = new k(this.ctx),
                    c = e.i,
                    h = e.j,
                    d = !0,
                    u = o.config.plotOptions.candlestick.colors.upward,
                    p = o.config.plotOptions.candlestick.colors.downward,
                    g = "";
                  this.isBoxPlot && (g = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
                  var f = this.yRatio[this.yaxisIndex],
                    m = e.realIndex,
                    v = this.getOHLCValue(m, h),
                    x = n,
                    b = n;
                  v.o > v.c && (d = !1);
                  var y = Math.min(v.o, v.c),
                    w = Math.max(v.o, v.c),
                    S = v.m;
                  o.globals.isXNumeric && (i = (o.globals.seriesX[m][h] - o.globals.minX) / this.xRatio - a / 2);
                  var C = i + a * this.visibleI;
                  void 0 === this.series[c][h] || null === this.series[c][h]
                    ? ((y = n), (w = n))
                    : ((y = n - y / f), (w = n - w / f), (x = n - v.h / f), (b = n - v.l / f), (S = n - v.m / f));
                  var A = l.move(C, n),
                    E = l.move(C + a / 2, y);
                  return (
                    o.globals.previousPaths.length > 0 && (E = this.getPreviousPath(m, h, !0)),
                    (A = this.isBoxPlot
                      ? [
                          l.move(C, y) +
                            l.line(C + a / 2, y) +
                            l.line(C + a / 2, x) +
                            l.line(C + a / 4, x) +
                            l.line(C + a - a / 4, x) +
                            l.line(C + a / 2, x) +
                            l.line(C + a / 2, y) +
                            l.line(C + a, y) +
                            l.line(C + a, S) +
                            l.line(C, S) +
                            l.line(C, y + r / 2),
                          l.move(C, S) +
                            l.line(C + a, S) +
                            l.line(C + a, w) +
                            l.line(C + a / 2, w) +
                            l.line(C + a / 2, b) +
                            l.line(C + a - a / 4, b) +
                            l.line(C + a / 4, b) +
                            l.line(C + a / 2, b) +
                            l.line(C + a / 2, w) +
                            l.line(C, w) +
                            l.line(C, S) +
                            "z",
                        ]
                      : [
                          l.move(C, w) +
                            l.line(C + a / 2, w) +
                            l.line(C + a / 2, x) +
                            l.line(C + a / 2, w) +
                            l.line(C + a, w) +
                            l.line(C + a, y) +
                            l.line(C + a / 2, y) +
                            l.line(C + a / 2, b) +
                            l.line(C + a / 2, y) +
                            l.line(C, y) +
                            l.line(C, w - r / 2),
                        ]),
                    (E += l.move(C, y)),
                    o.globals.isXNumeric || (i += s),
                    { pathTo: A, pathFrom: E, x: i, y: w, barXPosition: C, color: this.isBoxPlot ? g : d ? [u] : [p] }
                  );
                },
              },
              {
                key: "drawHorizontalBoxPaths",
                value: function (t) {
                  var e = t.indexes;
                  t.x;
                  var i = t.y,
                    s = t.yDivision,
                    a = t.barHeight,
                    n = t.zeroW,
                    r = t.strokeWidth,
                    o = this.w,
                    l = new k(this.ctx),
                    c = e.i,
                    h = e.j,
                    d = this.boxOptions.colors.lower;
                  this.isBoxPlot && (d = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
                  var u = this.invertedYRatio,
                    p = e.realIndex,
                    g = this.getOHLCValue(p, h),
                    f = n,
                    m = n,
                    v = Math.min(g.o, g.c),
                    x = Math.max(g.o, g.c),
                    b = g.m;
                  o.globals.isXNumeric &&
                    (i = (o.globals.seriesX[p][h] - o.globals.minX) / this.invertedXRatio - a / 2);
                  var y = i + a * this.visibleI;
                  void 0 === this.series[c][h] || null === this.series[c][h]
                    ? ((v = n), (x = n))
                    : ((v = n + v / u), (x = n + x / u), (f = n + g.h / u), (m = n + g.l / u), (b = n + g.m / u));
                  var w = l.move(n, y),
                    S = l.move(v, y + a / 2);
                  return (
                    o.globals.previousPaths.length > 0 && (S = this.getPreviousPath(p, h, !0)),
                    (w = [
                      l.move(v, y) +
                        l.line(v, y + a / 2) +
                        l.line(f, y + a / 2) +
                        l.line(f, y + a / 2 - a / 4) +
                        l.line(f, y + a / 2 + a / 4) +
                        l.line(f, y + a / 2) +
                        l.line(v, y + a / 2) +
                        l.line(v, y + a) +
                        l.line(b, y + a) +
                        l.line(b, y) +
                        l.line(v + r / 2, y),
                      l.move(b, y) +
                        l.line(b, y + a) +
                        l.line(x, y + a) +
                        l.line(x, y + a / 2) +
                        l.line(m, y + a / 2) +
                        l.line(m, y + a - a / 4) +
                        l.line(m, y + a / 4) +
                        l.line(m, y + a / 2) +
                        l.line(x, y + a / 2) +
                        l.line(x, y) +
                        l.line(b, y) +
                        "z",
                    ]),
                    (S += l.move(v, y)),
                    o.globals.isXNumeric || (i += s),
                    { pathTo: w, pathFrom: S, x: x, y: i, barYPosition: y, color: d }
                  );
                },
              },
              {
                key: "getOHLCValue",
                value: function (t, e) {
                  var i = this.w;
                  return {
                    o: this.isBoxPlot ? i.globals.seriesCandleH[t][e] : i.globals.seriesCandleO[t][e],
                    h: this.isBoxPlot ? i.globals.seriesCandleO[t][e] : i.globals.seriesCandleH[t][e],
                    m: i.globals.seriesCandleM[t][e],
                    l: this.isBoxPlot ? i.globals.seriesCandleC[t][e] : i.globals.seriesCandleL[t][e],
                    c: this.isBoxPlot ? i.globals.seriesCandleL[t][e] : i.globals.seriesCandleC[t][e],
                  };
                },
              },
            ]),
            i
          );
        })(),
        Et = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "checkColorRange",
                value: function () {
                  var t = this.w,
                    e = !1,
                    i = t.config.plotOptions[t.config.chart.type];
                  return (
                    i.colorScale.ranges.length > 0 &&
                      i.colorScale.ranges.map(function (t, i) {
                        t.from <= 0 && (e = !0);
                      }),
                    e
                  );
                },
              },
              {
                key: "getShadeColor",
                value: function (t, e, i, s) {
                  var a = this.w,
                    n = 1,
                    r = a.config.plotOptions[t].shadeIntensity,
                    o = this.determineColor(t, e, i);
                  a.globals.hasNegs || s
                    ? (n = a.config.plotOptions[t].reverseNegativeShade
                        ? o.percent < 0
                          ? (o.percent / 100) * (1.25 * r)
                          : (1 - o.percent / 100) * (1.25 * r)
                        : o.percent <= 0
                        ? 1 - (1 + o.percent / 100) * r
                        : (1 - o.percent / 100) * r)
                    : ((n = 1 - o.percent / 100), "treemap" === t && (n = (1 - o.percent / 100) * (1.25 * r)));
                  var l = o.color,
                    c = new b();
                  return (
                    a.config.plotOptions[t].enableShades &&
                      (l =
                        "dark" === this.w.config.theme.mode
                          ? b.hexToRgba(c.shadeColor(-1 * n, o.color), a.config.fill.opacity)
                          : b.hexToRgba(c.shadeColor(n, o.color), a.config.fill.opacity)),
                    { color: l, colorProps: o }
                  );
                },
              },
              {
                key: "determineColor",
                value: function (t, e, i) {
                  var s = this.w,
                    a = s.globals.series[e][i],
                    n = s.config.plotOptions[t],
                    r = n.colorScale.inverse ? i : e;
                  n.distributed && "treemap" === s.config.chart.type && (r = i);
                  var o = s.globals.colors[r],
                    l = null,
                    c = Math.min.apply(Math, m(s.globals.series[e])),
                    h = Math.max.apply(Math, m(s.globals.series[e]));
                  n.distributed || "heatmap" !== t || ((c = s.globals.minY), (h = s.globals.maxY)),
                    void 0 !== n.colorScale.min &&
                      ((c = n.colorScale.min < s.globals.minY ? n.colorScale.min : s.globals.minY),
                      (h = n.colorScale.max > s.globals.maxY ? n.colorScale.max : s.globals.maxY));
                  var d = Math.abs(h) + Math.abs(c),
                    u = (100 * a) / (0 === d ? d - 1e-6 : d);
                  return (
                    n.colorScale.ranges.length > 0 &&
                      n.colorScale.ranges.map(function (t, e) {
                        if (a >= t.from && a <= t.to) {
                          (o = t.color), (l = t.foreColor ? t.foreColor : null), (c = t.from), (h = t.to);
                          var i = Math.abs(h) + Math.abs(c);
                          u = (100 * a) / (0 === i ? i - 1e-6 : i);
                        }
                      }),
                    { color: o, foreColor: l, percent: u }
                  );
                },
              },
              {
                key: "calculateDataLabels",
                value: function (t) {
                  var e = t.text,
                    i = t.x,
                    s = t.y,
                    a = t.i,
                    n = t.j,
                    r = t.colorProps,
                    o = t.fontSize,
                    l = this.w.config.dataLabels,
                    c = new k(this.ctx),
                    h = new H(this.ctx),
                    d = null;
                  if (l.enabled) {
                    d = c.group({ class: "apexcharts-data-labels" });
                    var u = l.offsetX,
                      p = l.offsetY,
                      g = i + u,
                      f = s + parseFloat(l.style.fontSize) / 3 + p;
                    h.plotDataLabelsText({
                      x: g,
                      y: f,
                      text: e,
                      i: a,
                      j: n,
                      color: r.foreColor,
                      parent: d,
                      fontSize: o,
                      dataLabelsConfig: l,
                    });
                  }
                  return d;
                },
              },
              {
                key: "addListeners",
                value: function (t) {
                  var e = new k(this.ctx);
                  t.node.addEventListener("mouseenter", e.pathMouseEnter.bind(this, t)),
                    t.node.addEventListener("mouseleave", e.pathMouseLeave.bind(this, t)),
                    t.node.addEventListener("mousedown", e.pathMouseDown.bind(this, t));
                },
              },
            ]),
            t
          );
        })(),
        Tt = (function () {
          function t(e, i) {
            o(this, t),
              (this.ctx = e),
              (this.w = e.w),
              (this.xRatio = i.xRatio),
              (this.yRatio = i.yRatio),
              (this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation),
              (this.helpers = new Et(e)),
              (this.rectRadius = this.w.config.plotOptions.heatmap.radius),
              (this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0);
          }
          return (
            c(t, [
              {
                key: "draw",
                value: function (t) {
                  var e = this.w,
                    i = new k(this.ctx),
                    s = i.group({ class: "apexcharts-heatmap" });
                  s.attr("clip-path", "url(#gridRectMask".concat(e.globals.cuid, ")"));
                  var a = e.globals.gridWidth / e.globals.dataPoints,
                    n = e.globals.gridHeight / e.globals.series.length,
                    r = 0,
                    o = !1;
                  this.negRange = this.helpers.checkColorRange();
                  var l = t.slice();
                  e.config.yaxis[0].reversed && ((o = !0), l.reverse());
                  for (var c = o ? 0 : l.length - 1; o ? c < l.length : c >= 0; o ? c++ : c--) {
                    var h = i.group({
                      class: "apexcharts-series apexcharts-heatmap-series",
                      seriesName: b.escapeString(e.globals.seriesNames[c]),
                      rel: c + 1,
                      "data:realIndex": c,
                    });
                    if ((this.ctx.series.addCollapsedClassToSeries(h, c), e.config.chart.dropShadow.enabled)) {
                      var d = e.config.chart.dropShadow;
                      new w(this.ctx).dropShadow(h, d, c);
                    }
                    for (var u = 0, p = e.config.plotOptions.heatmap.shadeIntensity, g = 0; g < l[c].length; g++) {
                      var f = this.helpers.getShadeColor(e.config.chart.type, c, g, this.negRange),
                        m = f.color,
                        v = f.colorProps;
                      "image" === e.config.fill.type &&
                        (m = new _(this.ctx).fillPath({
                          seriesNumber: c,
                          dataPointIndex: g,
                          opacity: e.globals.hasNegs
                            ? v.percent < 0
                              ? 1 - (1 + v.percent / 100)
                              : p + v.percent / 100
                            : v.percent / 100,
                          patternID: b.randomId(),
                          width: e.config.fill.image.width ? e.config.fill.image.width : a,
                          height: e.config.fill.image.height ? e.config.fill.image.height : n,
                        }));
                      var x = this.rectRadius,
                        y = i.drawRect(u, r, a, n, x);
                      if (
                        (y.attr({ cx: u, cy: r }),
                        y.node.classList.add("apexcharts-heatmap-rect"),
                        h.add(y),
                        y.attr({
                          fill: m,
                          i: c,
                          index: c,
                          j: g,
                          val: l[c][g],
                          "stroke-width": this.strokeWidth,
                          stroke: e.config.plotOptions.heatmap.useFillColorAsStroke ? m : e.globals.stroke.colors[0],
                          color: m,
                        }),
                        this.helpers.addListeners(y),
                        e.config.chart.animations.enabled && !e.globals.dataChanged)
                      ) {
                        var S = 1;
                        e.globals.resized || (S = e.config.chart.animations.speed),
                          this.animateHeatMap(y, u, r, a, n, S);
                      }
                      if (e.globals.dataChanged) {
                        var C = 1;
                        if (this.dynamicAnim.enabled && e.globals.shouldAnimate) {
                          C = this.dynamicAnim.speed;
                          var A =
                            e.globals.previousPaths[c] &&
                            e.globals.previousPaths[c][g] &&
                            e.globals.previousPaths[c][g].color;
                          A || (A = "rgba(255, 255, 255, 0)"),
                            this.animateHeatColor(
                              y,
                              b.isColorHex(A) ? A : b.rgb2hex(A),
                              b.isColorHex(m) ? m : b.rgb2hex(m),
                              C
                            );
                        }
                      }
                      var E = (0, e.config.dataLabels.formatter)(e.globals.series[c][g], {
                          value: e.globals.series[c][g],
                          seriesIndex: c,
                          dataPointIndex: g,
                          w: e,
                        }),
                        T = this.helpers.calculateDataLabels({
                          text: E,
                          x: u + a / 2,
                          y: r + n / 2,
                          i: c,
                          j: g,
                          colorProps: v,
                          series: l,
                        });
                      null !== T && h.add(T), (u += a);
                    }
                    (r += n), s.add(h);
                  }
                  var L = e.globals.yAxisScale[0].result.slice();
                  e.config.yaxis[0].reversed ? L.unshift("") : L.push(""), (e.globals.yAxisScale[0].result = L);
                  var P = e.globals.gridHeight / e.globals.series.length;
                  return (e.config.yaxis[0].labels.offsetY = -P / 2), s;
                },
              },
              {
                key: "animateHeatMap",
                value: function (t, e, i, s, a, n) {
                  var r = new y(this.ctx);
                  r.animateRect(
                    t,
                    { x: e + s / 2, y: i + a / 2, width: 0, height: 0 },
                    { x: e, y: i, width: s, height: a },
                    n,
                    function () {
                      r.animationCompleted(t);
                    }
                  );
                },
              },
              {
                key: "animateHeatColor",
                value: function (t, e, i, s) {
                  t.attr({ fill: e }).animate(s).attr({ fill: i });
                },
              },
            ]),
            t
          );
        })(),
        Lt = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "drawYAxisTexts",
                value: function (t, e, i, s) {
                  var a = this.w,
                    n = a.config.yaxis[0],
                    r = a.globals.yLabelFormatters[0];
                  return new k(this.ctx).drawText({
                    x: t + n.labels.offsetX,
                    y: e + n.labels.offsetY,
                    text: r(s, i),
                    textAnchor: "middle",
                    fontSize: n.labels.style.fontSize,
                    fontFamily: n.labels.style.fontFamily,
                    foreColor: Array.isArray(n.labels.style.colors) ? n.labels.style.colors[i] : n.labels.style.colors,
                  });
                },
              },
            ]),
            t
          );
        })(),
        Pt = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
            var i = this.w;
            (this.chartType = this.w.config.chart.type),
              (this.initialAnim = this.w.config.chart.animations.enabled),
              (this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled),
              (this.animBeginArr = [0]),
              (this.animDur = 0),
              (this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels),
              (this.lineColorArr = void 0 !== i.globals.stroke.colors ? i.globals.stroke.colors : i.globals.colors),
              (this.defaultSize = Math.min(i.globals.gridWidth, i.globals.gridHeight)),
              (this.centerY = this.defaultSize / 2),
              (this.centerX = i.globals.gridWidth / 2),
              "radialBar" === i.config.chart.type
                ? (this.fullAngle = 360)
                : (this.fullAngle = Math.abs(i.config.plotOptions.pie.endAngle - i.config.plotOptions.pie.startAngle)),
              (this.initialAngle = i.config.plotOptions.pie.startAngle % this.fullAngle),
              (i.globals.radialSize =
                this.defaultSize / 2.05 -
                i.config.stroke.width -
                (i.config.chart.sparkline.enabled ? 0 : i.config.chart.dropShadow.blur)),
              (this.donutSize = (i.globals.radialSize * parseInt(i.config.plotOptions.pie.donut.size, 10)) / 100),
              (this.maxY = 0),
              (this.sliceLabels = []),
              (this.sliceSizes = []),
              (this.prevSectorAngleArr = []);
          }
          return (
            c(t, [
              {
                key: "draw",
                value: function (t) {
                  var e = this,
                    i = this.w,
                    s = new k(this.ctx);
                  if (((this.ret = s.group({ class: "apexcharts-pie" })), i.globals.noData)) return this.ret;
                  for (var a = 0, n = 0; n < t.length; n++) a += b.negToZero(t[n]);
                  var r = [],
                    o = s.group();
                  0 === a && (a = 1e-5),
                    t.forEach(function (t) {
                      e.maxY = Math.max(e.maxY, t);
                    }),
                    i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max),
                    "back" === i.config.grid.position &&
                      "polarArea" === this.chartType &&
                      this.drawPolarElements(this.ret);
                  for (var l = 0; l < t.length; l++) {
                    var c = (this.fullAngle * b.negToZero(t[l])) / a;
                    r.push(c),
                      "polarArea" === this.chartType
                        ? ((r[l] = this.fullAngle / t.length),
                          this.sliceSizes.push((i.globals.radialSize * t[l]) / this.maxY))
                        : this.sliceSizes.push(i.globals.radialSize);
                  }
                  if (i.globals.dataChanged) {
                    for (var h, d = 0, u = 0; u < i.globals.previousPaths.length; u++)
                      d += b.negToZero(i.globals.previousPaths[u]);
                    for (var p = 0; p < i.globals.previousPaths.length; p++)
                      (h = (this.fullAngle * b.negToZero(i.globals.previousPaths[p])) / d),
                        this.prevSectorAngleArr.push(h);
                  }
                  this.donutSize < 0 && (this.donutSize = 0);
                  var g = i.config.plotOptions.pie.customScale,
                    f = i.globals.gridWidth / 2,
                    m = i.globals.gridHeight / 2,
                    v = f - (i.globals.gridWidth / 2) * g,
                    x = m - (i.globals.gridHeight / 2) * g;
                  if ("donut" === this.chartType) {
                    var y = s.drawCircle(this.donutSize);
                    y.attr({
                      cx: this.centerX,
                      cy: this.centerY,
                      fill: i.config.plotOptions.pie.donut.background
                        ? i.config.plotOptions.pie.donut.background
                        : "transparent",
                    }),
                      o.add(y);
                  }
                  var w = this.drawArcs(r, t);
                  if (
                    (this.sliceLabels.forEach(function (t) {
                      w.add(t);
                    }),
                    o.attr({ transform: "translate(".concat(v, ", ").concat(x, ") scale(").concat(g, ")") }),
                    o.add(w),
                    this.ret.add(o),
                    this.donutDataLabels.show)
                  ) {
                    var S = this.renderInnerDataLabels(this.donutDataLabels, {
                      hollowSize: this.donutSize,
                      centerX: this.centerX,
                      centerY: this.centerY,
                      opacity: this.donutDataLabels.show,
                      translateX: v,
                      translateY: x,
                    });
                    this.ret.add(S);
                  }
                  return (
                    "front" === i.config.grid.position &&
                      "polarArea" === this.chartType &&
                      this.drawPolarElements(this.ret),
                    this.ret
                  );
                },
              },
              {
                key: "drawArcs",
                value: function (t, e) {
                  var i = this.w,
                    s = new w(this.ctx),
                    a = new k(this.ctx),
                    n = new _(this.ctx),
                    r = a.group({ class: "apexcharts-slices" }),
                    o = this.initialAngle,
                    l = this.initialAngle,
                    c = this.initialAngle,
                    h = this.initialAngle;
                  this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
                  for (var d = 0; d < t.length; d++) {
                    var u = a.group({
                      class: "apexcharts-series apexcharts-pie-series",
                      seriesName: b.escapeString(i.globals.seriesNames[d]),
                      rel: d + 1,
                      "data:realIndex": d,
                    });
                    r.add(u), (l = h), (c = (o = c) + t[d]), (h = l + this.prevSectorAngleArr[d]);
                    var p = c < o ? this.fullAngle + c - o : c - o,
                      g = n.fillPath({ seriesNumber: d, size: this.sliceSizes[d], value: e[d] }),
                      f = this.getChangedPath(l, h),
                      m = a.drawPath({
                        d: f,
                        stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d] : this.lineColorArr,
                        strokeWidth: 0,
                        fill: g,
                        fillOpacity: i.config.fill.opacity,
                        classes: "apexcharts-pie-area apexcharts-"
                          .concat(this.chartType.toLowerCase(), "-slice-")
                          .concat(d),
                      });
                    if (
                      (m.attr({ index: 0, j: d }), s.setSelectionFilter(m, 0, d), i.config.chart.dropShadow.enabled)
                    ) {
                      var v = i.config.chart.dropShadow;
                      s.dropShadow(m, v, d);
                    }
                    this.addListeners(m, this.donutDataLabels),
                      k.setAttrs(m.node, {
                        "data:angle": p,
                        "data:startAngle": o,
                        "data:strokeWidth": this.strokeWidth,
                        "data:value": e[d],
                      });
                    var x = { x: 0, y: 0 };
                    "pie" === this.chartType || "polarArea" === this.chartType
                      ? (x = b.polarToCartesian(
                          this.centerX,
                          this.centerY,
                          i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset,
                          (o + p / 2) % this.fullAngle
                        ))
                      : "donut" === this.chartType &&
                        (x = b.polarToCartesian(
                          this.centerX,
                          this.centerY,
                          (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset,
                          (o + p / 2) % this.fullAngle
                        )),
                      u.add(m);
                    var y = 0;
                    if (
                      (!this.initialAnim || i.globals.resized || i.globals.dataChanged
                        ? this.animBeginArr.push(0)
                        : (0 == (y = (p / this.fullAngle) * i.config.chart.animations.speed) && (y = 1),
                          (this.animDur = y + this.animDur),
                          this.animBeginArr.push(this.animDur)),
                      this.dynamicAnim && i.globals.dataChanged
                        ? this.animatePaths(m, {
                            size: this.sliceSizes[d],
                            endAngle: c,
                            startAngle: o,
                            prevStartAngle: l,
                            prevEndAngle: h,
                            animateStartingPos: !0,
                            i: d,
                            animBeginArr: this.animBeginArr,
                            shouldSetPrevPaths: !0,
                            dur: i.config.chart.animations.dynamicAnimation.speed,
                          })
                        : this.animatePaths(m, {
                            size: this.sliceSizes[d],
                            endAngle: c,
                            startAngle: o,
                            i: d,
                            totalItems: t.length - 1,
                            animBeginArr: this.animBeginArr,
                            dur: y,
                          }),
                      i.config.plotOptions.pie.expandOnClick &&
                        "polarArea" !== this.chartType &&
                        m.click(this.pieClicked.bind(this, d)),
                      void 0 !== i.globals.selectedDataPoints[0] &&
                        i.globals.selectedDataPoints[0].indexOf(d) > -1 &&
                        this.pieClicked(d),
                      i.config.dataLabels.enabled)
                    ) {
                      var S = x.x,
                        C = x.y,
                        A = (100 * p) / this.fullAngle + "%";
                      if (0 !== p && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t[d]) {
                        var E = i.config.dataLabels.formatter;
                        void 0 !== E && (A = E(i.globals.seriesPercent[d][0], { seriesIndex: d, w: i }));
                        var T = i.globals.dataLabels.style.colors[d],
                          L = a.group({ class: "apexcharts-datalabels" }),
                          P = a.drawText({
                            x: S,
                            y: C,
                            text: A,
                            textAnchor: "middle",
                            fontSize: i.config.dataLabels.style.fontSize,
                            fontFamily: i.config.dataLabels.style.fontFamily,
                            fontWeight: i.config.dataLabels.style.fontWeight,
                            foreColor: T,
                          });
                        if ((L.add(P), i.config.dataLabels.dropShadow.enabled)) {
                          var M = i.config.dataLabels.dropShadow;
                          s.dropShadow(P, M);
                        }
                        P.node.classList.add("apexcharts-pie-label"),
                          i.config.chart.animations.animate &&
                            !1 === i.globals.resized &&
                            (P.node.classList.add("apexcharts-pie-label-delay"),
                            (P.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s")),
                          this.sliceLabels.push(L);
                      }
                    }
                  }
                  return r;
                },
              },
              {
                key: "addListeners",
                value: function (t, e) {
                  var i = new k(this.ctx);
                  t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, t)),
                    t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, t)),
                    t.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t.node, e)),
                    t.node.addEventListener("mousedown", i.pathMouseDown.bind(this, t)),
                    this.donutDataLabels.total.showAlways ||
                      (t.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t.node, e)),
                      t.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t.node, e)));
                },
              },
              {
                key: "animatePaths",
                value: function (t, e) {
                  var i = this.w,
                    s =
                      e.endAngle < e.startAngle
                        ? this.fullAngle + e.endAngle - e.startAngle
                        : e.endAngle - e.startAngle,
                    a = s,
                    n = e.startAngle,
                    r = e.startAngle;
                  void 0 !== e.prevStartAngle &&
                    void 0 !== e.prevEndAngle &&
                    ((n = e.prevEndAngle),
                    (a =
                      e.prevEndAngle < e.prevStartAngle
                        ? this.fullAngle + e.prevEndAngle - e.prevStartAngle
                        : e.prevEndAngle - e.prevStartAngle)),
                    e.i === i.config.series.length - 1 &&
                      (s + r > this.fullAngle
                        ? (e.endAngle = e.endAngle - (s + r))
                        : s + r < this.fullAngle && (e.endAngle = e.endAngle + (this.fullAngle - (s + r)))),
                    s === this.fullAngle && (s = this.fullAngle - 0.01),
                    this.animateArc(t, n, r, s, a, e);
                },
              },
              {
                key: "animateArc",
                value: function (t, e, i, s, a, n) {
                  var r,
                    o = this,
                    l = this.w,
                    c = new y(this.ctx),
                    h = n.size;
                  (isNaN(e) || isNaN(a)) && ((e = i), (a = s), (n.dur = 0));
                  var d = s,
                    u = i,
                    p = e < i ? this.fullAngle + e - i : e - i;
                  l.globals.dataChanged &&
                    n.shouldSetPrevPaths &&
                    n.prevEndAngle &&
                    ((r = o.getPiePath({
                      me: o,
                      startAngle: n.prevStartAngle,
                      angle:
                        n.prevEndAngle < n.prevStartAngle
                          ? this.fullAngle + n.prevEndAngle - n.prevStartAngle
                          : n.prevEndAngle - n.prevStartAngle,
                      size: h,
                    })),
                    t.attr({ d: r })),
                    0 !== n.dur
                      ? t
                          .animate(n.dur, l.globals.easing, n.animBeginArr[n.i])
                          .afterAll(function () {
                            ("pie" !== o.chartType && "donut" !== o.chartType && "polarArea" !== o.chartType) ||
                              this.animate(l.config.chart.animations.dynamicAnimation.speed).attr({
                                "stroke-width": o.strokeWidth,
                              }),
                              n.i === l.config.series.length - 1 && c.animationCompleted(t);
                          })
                          .during(function (l) {
                            (d = p + (s - p) * l),
                              n.animateStartingPos && ((d = a + (s - a) * l), (u = e - a + (i - (e - a)) * l)),
                              (r = o.getPiePath({ me: o, startAngle: u, angle: d, size: h })),
                              t.node.setAttribute("data:pathOrig", r),
                              t.attr({ d: r });
                          })
                      : ((r = o.getPiePath({ me: o, startAngle: u, angle: s, size: h })),
                        n.isTrack || (l.globals.animationEnded = !0),
                        t.node.setAttribute("data:pathOrig", r),
                        t.attr({ d: r, "stroke-width": o.strokeWidth }));
                },
              },
              {
                key: "pieClicked",
                value: function (t) {
                  var e,
                    i = this.w,
                    s = this,
                    a = s.sliceSizes[t] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0),
                    n = i.globals.dom.Paper.select(
                      ".apexcharts-".concat(s.chartType.toLowerCase(), "-slice-").concat(t)
                    ).members[0];
                  if ("true" !== n.attr("data:pieClicked")) {
                    var r = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
                    Array.prototype.forEach.call(r, function (t) {
                      t.setAttribute("data:pieClicked", "false");
                      var e = t.getAttribute("data:pathOrig");
                      t.setAttribute("d", e);
                    }),
                      n.attr("data:pieClicked", "true");
                    var o = parseInt(n.attr("data:startAngle"), 10),
                      l = parseInt(n.attr("data:angle"), 10);
                    (e = s.getPiePath({ me: s, startAngle: o, angle: l, size: a })), 360 !== l && n.plot(e);
                  } else {
                    n.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(n.node, this.donutDataLabels);
                    var c = n.attr("data:pathOrig");
                    n.attr({ d: c });
                  }
                },
              },
              {
                key: "getChangedPath",
                value: function (t, e) {
                  var i = "";
                  return (
                    this.dynamicAnim &&
                      this.w.globals.dataChanged &&
                      (i = this.getPiePath({ me: this, startAngle: t, angle: e - t, size: this.size })),
                    i
                  );
                },
              },
              {
                key: "getPiePath",
                value: function (t) {
                  var e = t.me,
                    i = t.startAngle,
                    s = t.angle,
                    a = t.size,
                    n = i,
                    r = (Math.PI * (n - 90)) / 180,
                    o = s + i;
                  Math.ceil(o) >= this.fullAngle + (this.w.config.plotOptions.pie.startAngle % this.fullAngle) &&
                    (o = this.fullAngle + (this.w.config.plotOptions.pie.startAngle % this.fullAngle) - 0.01),
                    Math.ceil(o) > this.fullAngle && (o -= this.fullAngle);
                  var l = (Math.PI * (o - 90)) / 180,
                    c = e.centerX + a * Math.cos(r),
                    h = e.centerY + a * Math.sin(r),
                    d = e.centerX + a * Math.cos(l),
                    u = e.centerY + a * Math.sin(l),
                    p = b.polarToCartesian(e.centerX, e.centerY, e.donutSize, o),
                    g = b.polarToCartesian(e.centerX, e.centerY, e.donutSize, n),
                    f = s > 180 ? 1 : 0,
                    m = ["M", c, h, "A", a, a, 0, f, 1, d, u];
                  return "donut" === e.chartType
                    ? []
                        .concat(m, ["L", p.x, p.y, "A", e.donutSize, e.donutSize, 0, f, 0, g.x, g.y, "L", c, h, "z"])
                        .join(" ")
                    : "pie" === e.chartType || "polarArea" === e.chartType
                    ? [].concat(m, ["L", e.centerX, e.centerY, "L", c, h]).join(" ")
                    : [].concat(m).join(" ");
                },
              },
              {
                key: "drawPolarElements",
                value: function (t) {
                  var e = this.w,
                    i = new q(this.ctx),
                    s = new k(this.ctx),
                    a = new Lt(this.ctx),
                    n = s.group(),
                    r = s.group(),
                    o = i.niceScale(0, Math.ceil(this.maxY), e.config.yaxis[0].tickAmount, 0, !0),
                    l = o.result.reverse(),
                    c = o.result.length;
                  this.maxY = o.niceMax;
                  for (var h = e.globals.radialSize, d = h / (c - 1), u = 0; u < c - 1; u++) {
                    var p = s.drawCircle(h);
                    if (
                      (p.attr({
                        cx: this.centerX,
                        cy: this.centerY,
                        fill: "none",
                        "stroke-width": e.config.plotOptions.polarArea.rings.strokeWidth,
                        stroke: e.config.plotOptions.polarArea.rings.strokeColor,
                      }),
                      e.config.yaxis[0].show)
                    ) {
                      var g = a.drawYAxisTexts(
                        this.centerX,
                        this.centerY - h + parseInt(e.config.yaxis[0].labels.style.fontSize, 10) / 2,
                        u,
                        l[u]
                      );
                      r.add(g);
                    }
                    n.add(p), (h -= d);
                  }
                  this.drawSpokes(t), t.add(n), t.add(r);
                },
              },
              {
                key: "renderInnerDataLabels",
                value: function (t, e) {
                  var i = this.w,
                    s = new k(this.ctx),
                    a = s.group({
                      class: "apexcharts-datalabels-group",
                      transform: "translate("
                        .concat(e.translateX ? e.translateX : 0, ", ")
                        .concat(e.translateY ? e.translateY : 0, ") scale(")
                        .concat(i.config.plotOptions.pie.customScale, ")"),
                    }),
                    n = t.total.show;
                  a.node.style.opacity = e.opacity;
                  var r,
                    o,
                    l = e.centerX,
                    c = e.centerY;
                  r = void 0 === t.name.color ? i.globals.colors[0] : t.name.color;
                  var h = t.name.fontSize,
                    d = t.name.fontFamily,
                    u = t.name.fontWeight;
                  o = void 0 === t.value.color ? i.config.chart.foreColor : t.value.color;
                  var p = t.value.formatter,
                    g = "",
                    f = "";
                  if (
                    (n
                      ? ((r = t.total.color),
                        (h = t.total.fontSize),
                        (d = t.total.fontFamily),
                        (u = t.total.fontWeight),
                        (f = t.total.label),
                        (g = t.total.formatter(i)))
                      : 1 === i.globals.series.length &&
                        ((g = p(i.globals.series[0], i)), (f = i.globals.seriesNames[0])),
                    f && (f = t.name.formatter(f, t.total.show, i)),
                    t.name.show)
                  ) {
                    var m = s.drawText({
                      x: l,
                      y: c + parseFloat(t.name.offsetY),
                      text: f,
                      textAnchor: "middle",
                      foreColor: r,
                      fontSize: h,
                      fontWeight: u,
                      fontFamily: d,
                    });
                    m.node.classList.add("apexcharts-datalabel-label"), a.add(m);
                  }
                  if (t.value.show) {
                    var v = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY,
                      x = s.drawText({
                        x: l,
                        y: c + v,
                        text: g,
                        textAnchor: "middle",
                        foreColor: o,
                        fontWeight: t.value.fontWeight,
                        fontSize: t.value.fontSize,
                        fontFamily: t.value.fontFamily,
                      });
                    x.node.classList.add("apexcharts-datalabel-value"), a.add(x);
                  }
                  return a;
                },
              },
              {
                key: "printInnerLabels",
                value: function (t, e, i, s) {
                  var a,
                    n = this.w;
                  s
                    ? (a =
                        void 0 === t.name.color
                          ? n.globals.colors[parseInt(s.parentNode.getAttribute("rel"), 10) - 1]
                          : t.name.color)
                    : n.globals.series.length > 1 && t.total.show && (a = t.total.color);
                  var r = n.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"),
                    o = n.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
                  (i = (0, t.value.formatter)(i, n)),
                    s || "function" != typeof t.total.formatter || (i = t.total.formatter(n));
                  var l = e === t.total.label;
                  (e = t.name.formatter(e, l, n)),
                    null !== r && (r.textContent = e),
                    null !== o && (o.textContent = i),
                    null !== r && (r.style.fill = a);
                },
              },
              {
                key: "printDataLabelsInner",
                value: function (t, e) {
                  var i = this.w,
                    s = t.getAttribute("data:value"),
                    a = i.globals.seriesNames[parseInt(t.parentNode.getAttribute("rel"), 10) - 1];
                  i.globals.series.length > 1 && this.printInnerLabels(e, a, s, t);
                  var n = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
                  null !== n && (n.style.opacity = 1);
                },
              },
              {
                key: "drawSpokes",
                value: function (t) {
                  var e = this,
                    i = this.w,
                    s = new k(this.ctx),
                    a = i.config.plotOptions.polarArea.spokes;
                  if (0 !== a.strokeWidth) {
                    for (var n = [], r = 360 / i.globals.series.length, o = 0; o < i.globals.series.length; o++)
                      n.push(
                        b.polarToCartesian(
                          this.centerX,
                          this.centerY,
                          i.globals.radialSize,
                          i.config.plotOptions.pie.startAngle + r * o
                        )
                      );
                    n.forEach(function (i, n) {
                      var r = s.drawLine(
                        i.x,
                        i.y,
                        e.centerX,
                        e.centerY,
                        Array.isArray(a.connectorColors) ? a.connectorColors[n] : a.connectorColors
                      );
                      t.add(r);
                    });
                  }
                },
              },
              {
                key: "revertDataLabelsInner",
                value: function (t, e, i) {
                  var s = this,
                    a = this.w,
                    n = a.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"),
                    r = !1,
                    o = a.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"),
                    l = function (t) {
                      var i = t.makeSliceOut,
                        a = t.printLabel;
                      Array.prototype.forEach.call(o, function (t) {
                        "true" === t.getAttribute("data:pieClicked") &&
                          (i && (r = !0), a && s.printDataLabelsInner(t, e));
                      });
                    };
                  if ((l({ makeSliceOut: !0, printLabel: !1 }), e.total.show && a.globals.series.length > 1))
                    r && !e.total.showAlways
                      ? l({ makeSliceOut: !1, printLabel: !0 })
                      : this.printInnerLabels(e, e.total.label, e.total.formatter(a));
                  else if ((l({ makeSliceOut: !1, printLabel: !0 }), !r))
                    if (a.globals.selectedDataPoints.length && a.globals.series.length > 1)
                      if (a.globals.selectedDataPoints[0].length > 0) {
                        var c = a.globals.selectedDataPoints[0],
                          h = a.globals.dom.baseEl.querySelector(
                            ".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(c)
                          );
                        this.printDataLabelsInner(h, e);
                      } else
                        n &&
                          a.globals.selectedDataPoints.length &&
                          0 === a.globals.selectedDataPoints[0].length &&
                          (n.style.opacity = 0);
                    else n && a.globals.series.length > 1 && (n.style.opacity = 0);
                },
              },
            ]),
            t
          );
        })(),
        Mt = (function () {
          function t(e) {
            o(this, t),
              (this.ctx = e),
              (this.w = e.w),
              (this.chartType = this.w.config.chart.type),
              (this.initialAnim = this.w.config.chart.animations.enabled),
              (this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled),
              (this.animDur = 0);
            var i = this.w;
            (this.graphics = new k(this.ctx)),
              (this.lineColorArr = void 0 !== i.globals.stroke.colors ? i.globals.stroke.colors : i.globals.colors),
              (this.defaultSize =
                i.globals.svgHeight < i.globals.svgWidth
                  ? i.globals.gridHeight + 1.5 * i.globals.goldenPadding
                  : i.globals.gridWidth),
              (this.isLog = i.config.yaxis[0].logarithmic),
              (this.coreUtils = new S(this.ctx)),
              (this.maxValue = this.isLog ? this.coreUtils.getLogVal(i.globals.maxY, 0) : i.globals.maxY),
              (this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : i.globals.minY),
              (this.polygons = i.config.plotOptions.radar.polygons),
              (this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0),
              (this.size = this.defaultSize / 2.1 - this.strokeWidth - i.config.chart.dropShadow.blur),
              i.config.xaxis.labels.show && (this.size = this.size - i.globals.xAxisLabelsWidth / 1.75),
              void 0 !== i.config.plotOptions.radar.size && (this.size = i.config.plotOptions.radar.size),
              (this.dataRadiusOfPercent = []),
              (this.dataRadius = []),
              (this.angleArr = []),
              (this.yaxisLabelsTextsPos = []);
          }
          return (
            c(t, [
              {
                key: "draw",
                value: function (t) {
                  var e = this,
                    i = this.w,
                    s = new _(this.ctx),
                    a = [],
                    r = new H(this.ctx);
                  t.length && (this.dataPointsLen = t[i.globals.maxValsInArrayIndex].length),
                    (this.disAngle = (2 * Math.PI) / this.dataPointsLen);
                  var o = i.globals.gridWidth / 2,
                    l = i.globals.gridHeight / 2,
                    c = o + i.config.plotOptions.radar.offsetX,
                    h = l + i.config.plotOptions.radar.offsetY,
                    d = this.graphics.group({
                      class: "apexcharts-radar-series apexcharts-plot-series",
                      transform: "translate(".concat(c || 0, ", ").concat(h || 0, ")"),
                    }),
                    u = [],
                    p = null,
                    g = null;
                  if (
                    ((this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" })),
                    t.forEach(function (t, o) {
                      var l = t.length === i.globals.dataPoints,
                        c = e.graphics.group().attr({
                          class: "apexcharts-series",
                          "data:longestSeries": l,
                          seriesName: b.escapeString(i.globals.seriesNames[o]),
                          rel: o + 1,
                          "data:realIndex": o,
                        });
                      (e.dataRadiusOfPercent[o] = []),
                        (e.dataRadius[o] = []),
                        (e.angleArr[o] = []),
                        t.forEach(function (t, i) {
                          var s = Math.abs(e.maxValue - e.minValue);
                          (t += Math.abs(e.minValue)),
                            e.isLog && (t = e.coreUtils.getLogVal(t, 0)),
                            (e.dataRadiusOfPercent[o][i] = t / s),
                            (e.dataRadius[o][i] = e.dataRadiusOfPercent[o][i] * e.size),
                            (e.angleArr[o][i] = i * e.disAngle);
                        }),
                        (u = e.getDataPointsPos(e.dataRadius[o], e.angleArr[o]));
                      var h = e.createPaths(u, { x: 0, y: 0 });
                      (p = e.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" })),
                        (g = e.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": o })),
                        i.globals.delayedElements.push({ el: p.node, index: o });
                      var d = {
                          i: o,
                          realIndex: o,
                          animationDelay: o,
                          initialSpeed: i.config.chart.animations.speed,
                          dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed,
                          className: "apexcharts-radar",
                          shouldClipToGrid: !1,
                          bindEventsOnPaths: !1,
                          stroke: i.globals.stroke.colors[o],
                          strokeLineCap: i.config.stroke.lineCap,
                        },
                        f = null;
                      i.globals.previousPaths.length > 0 && (f = e.getPreviousPath(o));
                      for (var m = 0; m < h.linePathsTo.length; m++) {
                        var v = e.graphics.renderPaths(
                          n(
                            n({}, d),
                            {},
                            {
                              pathFrom: null === f ? h.linePathsFrom[m] : f,
                              pathTo: h.linePathsTo[m],
                              strokeWidth: Array.isArray(e.strokeWidth) ? e.strokeWidth[o] : e.strokeWidth,
                              fill: "none",
                              drawShadow: !1,
                            }
                          )
                        );
                        c.add(v);
                        var x = s.fillPath({ seriesNumber: o }),
                          y = e.graphics.renderPaths(
                            n(
                              n({}, d),
                              {},
                              {
                                pathFrom: null === f ? h.areaPathsFrom[m] : f,
                                pathTo: h.areaPathsTo[m],
                                strokeWidth: 0,
                                fill: x,
                                drawShadow: !1,
                              }
                            )
                          );
                        if (i.config.chart.dropShadow.enabled) {
                          var k = new w(e.ctx),
                            S = i.config.chart.dropShadow;
                          k.dropShadow(y, Object.assign({}, S, { noUserSpaceOnUse: !0 }), o);
                        }
                        c.add(y);
                      }
                      t.forEach(function (t, s) {
                        var a = new B(e.ctx).getMarkerConfig({
                            cssClass: "apexcharts-marker",
                            seriesIndex: o,
                            dataPointIndex: s,
                          }),
                          l = e.graphics.drawMarker(u[s].x, u[s].y, a);
                        l.attr("rel", s),
                          l.attr("j", s),
                          l.attr("index", o),
                          l.node.setAttribute("default-marker-size", a.pSize);
                        var h = e.graphics.group({ class: "apexcharts-series-markers" });
                        h && h.add(l), p.add(h), c.add(p);
                        var d = i.config.dataLabels;
                        if (d.enabled) {
                          var f = d.formatter(i.globals.series[o][s], { seriesIndex: o, dataPointIndex: s, w: i });
                          r.plotDataLabelsText({
                            x: u[s].x,
                            y: u[s].y,
                            text: f,
                            textAnchor: "middle",
                            i: o,
                            j: o,
                            parent: g,
                            offsetCorrection: !1,
                            dataLabelsConfig: n({}, d),
                          });
                        }
                        c.add(g);
                      }),
                        a.push(c);
                    }),
                    this.drawPolygons({ parent: d }),
                    i.config.xaxis.labels.show)
                  ) {
                    var f = this.drawXAxisTexts();
                    d.add(f);
                  }
                  return (
                    a.forEach(function (t) {
                      d.add(t);
                    }),
                    d.add(this.yaxisLabels),
                    d
                  );
                },
              },
              {
                key: "drawPolygons",
                value: function (t) {
                  for (
                    var e = this,
                      i = this.w,
                      s = t.parent,
                      a = new Lt(this.ctx),
                      n = i.globals.yAxisScale[0].result.reverse(),
                      r = n.length,
                      o = [],
                      l = this.size / (r - 1),
                      c = 0;
                    c < r;
                    c++
                  )
                    o[c] = l * c;
                  o.reverse();
                  var h = [],
                    d = [];
                  o.forEach(function (t, i) {
                    var s = b.getPolygonPos(t, e.dataPointsLen),
                      a = "";
                    s.forEach(function (t, s) {
                      if (0 === i) {
                        var n = e.graphics.drawLine(
                          t.x,
                          t.y,
                          0,
                          0,
                          Array.isArray(e.polygons.connectorColors)
                            ? e.polygons.connectorColors[s]
                            : e.polygons.connectorColors
                        );
                        d.push(n);
                      }
                      0 === s && e.yaxisLabelsTextsPos.push({ x: t.x, y: t.y }), (a += t.x + "," + t.y + " ");
                    }),
                      h.push(a);
                  }),
                    h.forEach(function (t, a) {
                      var n = e.polygons.strokeColors,
                        r = e.polygons.strokeWidth,
                        o = e.graphics.drawPolygon(
                          t,
                          Array.isArray(n) ? n[a] : n,
                          Array.isArray(r) ? r[a] : r,
                          i.globals.radarPolygons.fill.colors[a]
                        );
                      s.add(o);
                    }),
                    d.forEach(function (t) {
                      s.add(t);
                    }),
                    i.config.yaxis[0].show &&
                      this.yaxisLabelsTextsPos.forEach(function (t, i) {
                        var s = a.drawYAxisTexts(t.x, t.y, i, n[i]);
                        e.yaxisLabels.add(s);
                      });
                },
              },
              {
                key: "drawXAxisTexts",
                value: function () {
                  var t = this,
                    e = this.w,
                    i = e.config.xaxis.labels,
                    s = this.graphics.group({ class: "apexcharts-xaxis" }),
                    a = b.getPolygonPos(this.size, this.dataPointsLen);
                  return (
                    e.globals.labels.forEach(function (r, o) {
                      var l = e.config.xaxis.labels.formatter,
                        c = new H(t.ctx);
                      if (a[o]) {
                        var h = t.getTextPos(a[o], t.size),
                          d = l(r, { seriesIndex: -1, dataPointIndex: o, w: e });
                        c.plotDataLabelsText({
                          x: h.newX,
                          y: h.newY,
                          text: d,
                          textAnchor: h.textAnchor,
                          i: o,
                          j: o,
                          parent: s,
                          color: Array.isArray(i.style.colors) && i.style.colors[o] ? i.style.colors[o] : "#a8a8a8",
                          dataLabelsConfig: n({ textAnchor: h.textAnchor, dropShadow: { enabled: !1 } }, i),
                          offsetCorrection: !1,
                        });
                      }
                    }),
                    s
                  );
                },
              },
              {
                key: "createPaths",
                value: function (t, e) {
                  var i = this,
                    s = [],
                    a = [],
                    n = [],
                    r = [];
                  if (t.length) {
                    (a = [this.graphics.move(e.x, e.y)]), (r = [this.graphics.move(e.x, e.y)]);
                    var o = this.graphics.move(t[0].x, t[0].y),
                      l = this.graphics.move(t[0].x, t[0].y);
                    t.forEach(function (e, s) {
                      (o += i.graphics.line(e.x, e.y)),
                        (l += i.graphics.line(e.x, e.y)),
                        s === t.length - 1 && ((o += "Z"), (l += "Z"));
                    }),
                      s.push(o),
                      n.push(l);
                  }
                  return { linePathsFrom: a, linePathsTo: s, areaPathsFrom: r, areaPathsTo: n };
                },
              },
              {
                key: "getTextPos",
                value: function (t, e) {
                  var i = "middle",
                    s = t.x,
                    a = t.y;
                  return (
                    Math.abs(t.x) >= 10
                      ? t.x > 0
                        ? ((i = "start"), (s += 10))
                        : t.x < 0 && ((i = "end"), (s -= 10))
                      : (i = "middle"),
                    Math.abs(t.y) >= e - 10 && (t.y < 0 ? (a -= 10) : t.y > 0 && (a += 10)),
                    { textAnchor: i, newX: s, newY: a }
                  );
                },
              },
              {
                key: "getPreviousPath",
                value: function (t) {
                  for (var e = this.w, i = null, s = 0; s < e.globals.previousPaths.length; s++) {
                    var a = e.globals.previousPaths[s];
                    a.paths.length > 0 &&
                      parseInt(a.realIndex, 10) === parseInt(t, 10) &&
                      void 0 !== e.globals.previousPaths[s].paths[0] &&
                      (i = e.globals.previousPaths[s].paths[0].d);
                  }
                  return i;
                },
              },
              {
                key: "getDataPointsPos",
                value: function (t, e) {
                  var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
                  (t = t || []), (e = e || []);
                  for (var s = [], a = 0; a < i; a++) {
                    var n = {};
                    (n.x = t[a] * Math.sin(e[a])), (n.y = -t[a] * Math.cos(e[a])), s.push(n);
                  }
                  return s;
                },
              },
            ]),
            t
          );
        })(),
        Ot = (function (t) {
          d(i, Pt);
          var e = f(i);
          function i(t) {
            var s;
            o(this, i), ((s = e.call(this, t)).ctx = t), (s.w = t.w), (s.animBeginArr = [0]), (s.animDur = 0);
            var a = s.w;
            return (
              (s.startAngle = a.config.plotOptions.radialBar.startAngle),
              (s.endAngle = a.config.plotOptions.radialBar.endAngle),
              (s.totalAngle = Math.abs(
                a.config.plotOptions.radialBar.endAngle - a.config.plotOptions.radialBar.startAngle
              )),
              (s.trackStartAngle = a.config.plotOptions.radialBar.track.startAngle),
              (s.trackEndAngle = a.config.plotOptions.radialBar.track.endAngle),
              (s.donutDataLabels = s.w.config.plotOptions.radialBar.dataLabels),
              (s.radialDataLabels = s.donutDataLabels),
              s.trackStartAngle || (s.trackStartAngle = s.startAngle),
              s.trackEndAngle || (s.trackEndAngle = s.endAngle),
              360 === s.endAngle && (s.endAngle = 359.99),
              (s.margin = parseInt(a.config.plotOptions.radialBar.track.margin, 10)),
              s
            );
          }
          return (
            c(i, [
              {
                key: "draw",
                value: function (t) {
                  var e = this.w,
                    i = new k(this.ctx),
                    s = i.group({ class: "apexcharts-radialbar" });
                  if (e.globals.noData) return s;
                  var a = i.group(),
                    n = this.defaultSize / 2,
                    r = e.globals.gridWidth / 2,
                    o = this.defaultSize / 2.05;
                  e.config.chart.sparkline.enabled || (o = o - e.config.stroke.width - e.config.chart.dropShadow.blur);
                  var l = e.globals.fill.colors;
                  if (e.config.plotOptions.radialBar.track.show) {
                    var c = this.drawTracks({ size: o, centerX: r, centerY: n, colorArr: l, series: t });
                    a.add(c);
                  }
                  var h = this.drawArcs({ size: o, centerX: r, centerY: n, colorArr: l, series: t }),
                    d = 360;
                  e.config.plotOptions.radialBar.startAngle < 0 && (d = this.totalAngle);
                  var u = (360 - d) / 360;
                  if (((e.globals.radialSize = o - o * u), this.radialDataLabels.value.show)) {
                    var p = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
                    e.globals.radialSize += p * u;
                  }
                  return (
                    a.add(h.g),
                    "front" === e.config.plotOptions.radialBar.hollow.position &&
                      (h.g.add(h.elHollow), h.dataLabels && h.g.add(h.dataLabels)),
                    s.add(a),
                    s
                  );
                },
              },
              {
                key: "drawTracks",
                value: function (t) {
                  var e = this.w,
                    i = new k(this.ctx),
                    s = i.group({ class: "apexcharts-tracks" }),
                    a = new w(this.ctx),
                    n = new _(this.ctx),
                    r = this.getStrokeWidth(t);
                  t.size = t.size - r / 2;
                  for (var o = 0; o < t.series.length; o++) {
                    var l = i.group({ class: "apexcharts-radialbar-track apexcharts-track" });
                    s.add(l), l.attr({ rel: o + 1 }), (t.size = t.size - r - this.margin);
                    var c = e.config.plotOptions.radialBar.track,
                      h = n.fillPath({
                        seriesNumber: 0,
                        size: t.size,
                        fillColors: Array.isArray(c.background) ? c.background[o] : c.background,
                        solid: !0,
                      }),
                      d = this.trackStartAngle,
                      u = this.trackEndAngle;
                    Math.abs(u) + Math.abs(d) >= 360 && (u = 360 - Math.abs(this.startAngle) - 0.1);
                    var p = i.drawPath({
                      d: "",
                      stroke: h,
                      strokeWidth: (r * parseInt(c.strokeWidth, 10)) / 100,
                      fill: "none",
                      strokeOpacity: c.opacity,
                      classes: "apexcharts-radialbar-area",
                    });
                    if (c.dropShadow.enabled) {
                      var g = c.dropShadow;
                      a.dropShadow(p, g);
                    }
                    l.add(p),
                      p.attr("id", "apexcharts-radialbarTrack-" + o),
                      this.animatePaths(p, {
                        centerX: t.centerX,
                        centerY: t.centerY,
                        endAngle: u,
                        startAngle: d,
                        size: t.size,
                        i: o,
                        totalItems: 2,
                        animBeginArr: 0,
                        dur: 0,
                        isTrack: !0,
                        easing: e.globals.easing,
                      });
                  }
                  return s;
                },
              },
              {
                key: "drawArcs",
                value: function (t) {
                  var e = this.w,
                    i = new k(this.ctx),
                    s = new _(this.ctx),
                    a = new w(this.ctx),
                    n = i.group(),
                    r = this.getStrokeWidth(t);
                  t.size = t.size - r / 2;
                  var o = e.config.plotOptions.radialBar.hollow.background,
                    l =
                      t.size -
                      r * t.series.length -
                      this.margin * t.series.length -
                      (r * parseInt(e.config.plotOptions.radialBar.track.strokeWidth, 10)) / 100 / 2,
                    c = l - e.config.plotOptions.radialBar.hollow.margin;
                  void 0 !== e.config.plotOptions.radialBar.hollow.image && (o = this.drawHollowImage(t, n, l, o));
                  var h = this.drawHollow({
                    size: c,
                    centerX: t.centerX,
                    centerY: t.centerY,
                    fill: o || "transparent",
                  });
                  if (e.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
                    var d = e.config.plotOptions.radialBar.hollow.dropShadow;
                    a.dropShadow(h, d);
                  }
                  var u = 1;
                  !this.radialDataLabels.total.show && e.globals.series.length > 1 && (u = 0);
                  var p = null;
                  this.radialDataLabels.show &&
                    (p = this.renderInnerDataLabels(this.radialDataLabels, {
                      hollowSize: l,
                      centerX: t.centerX,
                      centerY: t.centerY,
                      opacity: u,
                    })),
                    "back" === e.config.plotOptions.radialBar.hollow.position && (n.add(h), p && n.add(p));
                  var g = !1;
                  e.config.plotOptions.radialBar.inverseOrder && (g = !0);
                  for (var f = g ? t.series.length - 1 : 0; g ? f >= 0 : f < t.series.length; g ? f-- : f++) {
                    var m = i.group({
                      class: "apexcharts-series apexcharts-radial-series",
                      seriesName: b.escapeString(e.globals.seriesNames[f]),
                    });
                    n.add(m),
                      m.attr({ rel: f + 1, "data:realIndex": f }),
                      this.ctx.series.addCollapsedClassToSeries(m, f),
                      (t.size = t.size - r - this.margin);
                    var v = s.fillPath({ seriesNumber: f, size: t.size, value: t.series[f] }),
                      x = this.startAngle,
                      y = void 0,
                      S = b.negToZero(t.series[f] > 100 ? 100 : t.series[f]) / 100,
                      C = Math.round(this.totalAngle * S) + this.startAngle,
                      A = void 0;
                    e.globals.dataChanged &&
                      ((y = this.startAngle),
                      (A = Math.round((this.totalAngle * b.negToZero(e.globals.previousPaths[f])) / 100) + y)),
                      Math.abs(C) + Math.abs(x) >= 360 && (C -= 0.01),
                      Math.abs(A) + Math.abs(y) >= 360 && (A -= 0.01);
                    var E = C - x,
                      T = Array.isArray(e.config.stroke.dashArray)
                        ? e.config.stroke.dashArray[f]
                        : e.config.stroke.dashArray,
                      L = i.drawPath({
                        d: "",
                        stroke: v,
                        strokeWidth: r,
                        fill: "none",
                        fillOpacity: e.config.fill.opacity,
                        classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + f,
                        strokeDashArray: T,
                      });
                    if (
                      (k.setAttrs(L.node, { "data:angle": E, "data:value": t.series[f] }),
                      e.config.chart.dropShadow.enabled)
                    ) {
                      var P = e.config.chart.dropShadow;
                      a.dropShadow(L, P, f);
                    }
                    a.setSelectionFilter(L, 0, f),
                      this.addListeners(L, this.radialDataLabels),
                      m.add(L),
                      L.attr({ index: 0, j: f });
                    var M = 0;
                    !this.initialAnim ||
                      e.globals.resized ||
                      e.globals.dataChanged ||
                      (M = e.config.chart.animations.speed),
                      e.globals.dataChanged && (M = e.config.chart.animations.dynamicAnimation.speed),
                      (this.animDur = M / (1.2 * t.series.length) + this.animDur),
                      this.animBeginArr.push(this.animDur),
                      this.animatePaths(L, {
                        centerX: t.centerX,
                        centerY: t.centerY,
                        endAngle: C,
                        startAngle: x,
                        prevEndAngle: A,
                        prevStartAngle: y,
                        size: t.size,
                        i: f,
                        totalItems: 2,
                        animBeginArr: this.animBeginArr,
                        dur: M,
                        shouldSetPrevPaths: !0,
                        easing: e.globals.easing,
                      });
                  }
                  return { g: n, elHollow: h, dataLabels: p };
                },
              },
              {
                key: "drawHollow",
                value: function (t) {
                  var e = new k(this.ctx).drawCircle(2 * t.size);
                  return (
                    e.attr({
                      class: "apexcharts-radialbar-hollow",
                      cx: t.centerX,
                      cy: t.centerY,
                      r: t.size,
                      fill: t.fill,
                    }),
                    e
                  );
                },
              },
              {
                key: "drawHollowImage",
                value: function (t, e, i, s) {
                  var a = this.w,
                    n = new _(this.ctx),
                    r = b.randomId(),
                    o = a.config.plotOptions.radialBar.hollow.image;
                  if (a.config.plotOptions.radialBar.hollow.imageClipped)
                    n.clippedImgArea({
                      width: i,
                      height: i,
                      image: o,
                      patternID: "pattern".concat(a.globals.cuid).concat(r),
                    }),
                      (s = "url(#pattern".concat(a.globals.cuid).concat(r, ")"));
                  else {
                    var l = a.config.plotOptions.radialBar.hollow.imageWidth,
                      c = a.config.plotOptions.radialBar.hollow.imageHeight;
                    if (void 0 === l && void 0 === c) {
                      var h = a.globals.dom.Paper.image(o).loaded(function (e) {
                        this.move(
                          t.centerX - e.width / 2 + a.config.plotOptions.radialBar.hollow.imageOffsetX,
                          t.centerY - e.height / 2 + a.config.plotOptions.radialBar.hollow.imageOffsetY
                        );
                      });
                      e.add(h);
                    } else {
                      var d = a.globals.dom.Paper.image(o).loaded(function (e) {
                        this.move(
                          t.centerX - l / 2 + a.config.plotOptions.radialBar.hollow.imageOffsetX,
                          t.centerY - c / 2 + a.config.plotOptions.radialBar.hollow.imageOffsetY
                        ),
                          this.size(l, c);
                      });
                      e.add(d);
                    }
                  }
                  return s;
                },
              },
              {
                key: "getStrokeWidth",
                value: function (t) {
                  var e = this.w;
                  return (
                    (t.size * (100 - parseInt(e.config.plotOptions.radialBar.hollow.size, 10))) /
                      100 /
                      (t.series.length + 1) -
                    this.margin
                  );
                },
              },
            ]),
            i
          );
        })(),
        It = (function (t) {
          d(i, St);
          var e = f(i);
          function i() {
            return o(this, i), e.apply(this, arguments);
          }
          return (
            c(i, [
              {
                key: "draw",
                value: function (t, e) {
                  var i = this.w,
                    s = new k(this.ctx);
                  (this.rangeBarOptions = this.w.config.plotOptions.rangeBar),
                    (this.series = t),
                    (this.seriesRangeStart = i.globals.seriesRangeStart),
                    (this.seriesRangeEnd = i.globals.seriesRangeEnd),
                    this.barHelpers.initVariables(t);
                  for (
                    var a = s.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), r = 0;
                    r < t.length;
                    r++
                  ) {
                    var o,
                      l,
                      c,
                      h = void 0,
                      d = void 0,
                      u = void 0,
                      p = i.globals.comboCharts ? e[r] : r,
                      g = s.group({
                        class: "apexcharts-series",
                        seriesName: b.escapeString(i.globals.seriesNames[p]),
                        rel: r + 1,
                        "data:realIndex": p,
                      });
                    this.ctx.series.addCollapsedClassToSeries(g, p),
                      t[r].length > 0 && (this.visibleI = this.visibleI + 1);
                    var f = 0,
                      m = 0;
                    this.yRatio.length > 1 && (this.yaxisIndex = p);
                    var v = this.barHelpers.initialPositions();
                    (d = v.y), (c = v.zeroW), (h = v.x), (m = v.barWidth), (o = v.xDivision), (l = v.zeroH);
                    for (
                      var x = s.group({ class: "apexcharts-datalabels", "data:realIndex": p }),
                        y = s.group({ class: "apexcharts-rangebar-goals-markers", style: "pointer-events: none" }),
                        w = 0;
                      w < i.globals.dataPoints;
                      w++
                    ) {
                      var S = this.barHelpers.getStrokeWidth(r, w, p),
                        C = this.seriesRangeStart[r][w],
                        A = this.seriesRangeEnd[r][w],
                        E = null,
                        T = null,
                        L = { x: h, y: d, strokeWidth: S, elSeries: g };
                      if (((u = v.yDivision), (f = v.barHeight), this.isHorizontal)) {
                        T = d + f * this.visibleI;
                        var P = this.seriesLen;
                        i.config.plotOptions.bar.rangeBarGroupRows && (P = 1);
                        var M = (u - f * P) / 2;
                        if (void 0 === i.config.series[r].data[w]) break;
                        if (i.config.series[r].data[w].x) {
                          var O = this.detectOverlappingBars({
                            i: r,
                            j: w,
                            barYPosition: T,
                            srty: M,
                            barHeight: f,
                            yDivision: u,
                            initPositions: v,
                          });
                          (f = O.barHeight), (T = O.barYPosition);
                        }
                        m = (E = this.drawRangeBarPaths(
                          n(
                            {
                              indexes: { i: r, j: w, realIndex: p },
                              barHeight: f,
                              barYPosition: T,
                              zeroW: c,
                              yDivision: u,
                              y1: C,
                              y2: A,
                            },
                            L
                          )
                        )).barWidth;
                      } else
                        f = (E = this.drawRangeColumnPaths(
                          n({ indexes: { i: r, j: w, realIndex: p }, zeroH: l, barWidth: m, xDivision: o }, L)
                        )).barHeight;
                      var I = this.barHelpers.drawGoalLine({
                        barXPosition: E.barXPosition,
                        barYPosition: T,
                        goalX: E.goalX,
                        goalY: E.goalY,
                        barHeight: f,
                        barWidth: m,
                      });
                      I && y.add(I), (d = E.y), (h = E.x);
                      var F = this.barHelpers.getPathFillColor(t, r, w, p),
                        D = i.globals.stroke.colors[p];
                      this.renderSeries({
                        realIndex: p,
                        pathFill: F,
                        lineFill: D,
                        j: w,
                        i: r,
                        x: h,
                        y: d,
                        y1: C,
                        y2: A,
                        pathFrom: E.pathFrom,
                        pathTo: E.pathTo,
                        strokeWidth: S,
                        elSeries: g,
                        series: t,
                        barHeight: f,
                        barYPosition: T,
                        barWidth: m,
                        elDataLabelsWrap: x,
                        elGoalsMarkers: y,
                        visibleSeries: this.visibleI,
                        type: "rangebar",
                      });
                    }
                    a.add(g);
                  }
                  return a;
                },
              },
              {
                key: "detectOverlappingBars",
                value: function (t) {
                  var e = t.i,
                    i = t.j,
                    s = t.barYPosition,
                    a = t.srty,
                    n = t.barHeight,
                    r = t.yDivision,
                    o = t.initPositions,
                    l = this.w,
                    c = [],
                    h = l.config.series[e].data[i].rangeName,
                    d = l.config.series[e].data[i].x,
                    u = l.globals.labels.indexOf(d),
                    p = l.globals.seriesRange[e].findIndex(function (t) {
                      return t.x === d && t.overlaps.length > 0;
                    });
                  return (
                    (s = l.config.plotOptions.bar.rangeBarGroupRows ? a + r * u : a + n * this.visibleI + r * u),
                    p > -1 &&
                      !l.config.plotOptions.bar.rangeBarOverlap &&
                      (c = l.globals.seriesRange[e][p].overlaps).indexOf(h) > -1 &&
                      (s =
                        (n = o.barHeight / c.length) * this.visibleI +
                        (r * (100 - parseInt(this.barOptions.barHeight, 10))) / 100 / 2 +
                        n * (this.visibleI + c.indexOf(h)) +
                        r * u),
                    { barYPosition: s, barHeight: n }
                  );
                },
              },
              {
                key: "drawRangeColumnPaths",
                value: function (t) {
                  var e = t.indexes,
                    i = t.x;
                  t.strokeWidth;
                  var s = t.xDivision,
                    a = t.barWidth,
                    n = t.zeroH,
                    r = this.w,
                    o = e.i,
                    l = e.j,
                    c = this.yRatio[this.yaxisIndex],
                    h = e.realIndex,
                    d = this.getRangeValue(h, l),
                    u = Math.min(d.start, d.end),
                    p = Math.max(d.start, d.end);
                  r.globals.isXNumeric && (i = (r.globals.seriesX[o][l] - r.globals.minX) / this.xRatio - a / 2);
                  var g = i + a * this.visibleI;
                  void 0 === this.series[o][l] || null === this.series[o][l]
                    ? (u = n)
                    : ((u = n - u / c), (p = n - p / c));
                  var f = Math.abs(p - u),
                    m = this.barHelpers.getColumnPaths({
                      barXPosition: g,
                      barWidth: a,
                      y1: u,
                      y2: p,
                      strokeWidth: this.strokeWidth,
                      series: this.seriesRangeEnd,
                      realIndex: e.realIndex,
                      i: h,
                      j: l,
                      w: r,
                    });
                  return (
                    r.globals.isXNumeric || (i += s),
                    {
                      pathTo: m.pathTo,
                      pathFrom: m.pathFrom,
                      barHeight: f,
                      x: i,
                      y: p,
                      goalY: this.barHelpers.getGoalValues("y", null, n, o, l),
                      barXPosition: g,
                    }
                  );
                },
              },
              {
                key: "drawRangeBarPaths",
                value: function (t) {
                  var e = t.indexes,
                    i = t.y,
                    s = t.y1,
                    a = t.y2,
                    n = t.yDivision,
                    r = t.barHeight,
                    o = t.barYPosition,
                    l = t.zeroW,
                    c = this.w,
                    h = l + s / this.invertedYRatio,
                    d = l + a / this.invertedYRatio,
                    u = Math.abs(d - h),
                    p = this.barHelpers.getBarpaths({
                      barYPosition: o,
                      barHeight: r,
                      x1: h,
                      x2: d,
                      strokeWidth: this.strokeWidth,
                      series: this.seriesRangeEnd,
                      i: e.realIndex,
                      realIndex: e.realIndex,
                      j: e.j,
                      w: c,
                    });
                  return (
                    c.globals.isXNumeric || (i += n),
                    {
                      pathTo: p.pathTo,
                      pathFrom: p.pathFrom,
                      barWidth: u,
                      x: d,
                      goalX: this.barHelpers.getGoalValues("x", l, null, e.realIndex, e.j),
                      y: i,
                    }
                  );
                },
              },
              {
                key: "getRangeValue",
                value: function (t, e) {
                  var i = this.w;
                  return { start: i.globals.seriesRangeStart[t][e], end: i.globals.seriesRangeEnd[t][e] };
                },
              },
            ]),
            i
          );
        })(),
        Ft = (function () {
          function t(e) {
            o(this, t), (this.w = e.w), (this.lineCtx = e);
          }
          return (
            c(t, [
              {
                key: "sameValueSeriesFix",
                value: function (t, e) {
                  var i = this.w;
                  if (
                    ("gradient" === i.config.fill.type || "gradient" === i.config.fill.type[t]) &&
                    new S(this.lineCtx.ctx, i).seriesHaveSameValues(t)
                  ) {
                    var s = e[t].slice();
                    (s[s.length - 1] = s[s.length - 1] + 1e-6), (e[t] = s);
                  }
                  return e;
                },
              },
              {
                key: "calculatePoints",
                value: function (t) {
                  var e = t.series,
                    i = t.realIndex,
                    s = t.x,
                    a = t.y,
                    n = t.i,
                    r = t.j,
                    o = t.prevY,
                    l = this.w,
                    c = [],
                    h = [];
                  if (0 === r) {
                    var d = this.lineCtx.categoryAxisCorrection + l.config.markers.offsetX;
                    l.globals.isXNumeric &&
                      (d = (l.globals.seriesX[i][0] - l.globals.minX) / this.lineCtx.xRatio + l.config.markers.offsetX),
                      c.push(d),
                      h.push(b.isNumber(e[n][0]) ? o + l.config.markers.offsetY : null),
                      c.push(s + l.config.markers.offsetX),
                      h.push(b.isNumber(e[n][r + 1]) ? a + l.config.markers.offsetY : null);
                  } else
                    c.push(s + l.config.markers.offsetX),
                      h.push(b.isNumber(e[n][r + 1]) ? a + l.config.markers.offsetY : null);
                  return { x: c, y: h };
                },
              },
              {
                key: "checkPreviousPaths",
                value: function (t) {
                  for (
                    var e = t.pathFromLine, i = t.pathFromArea, s = t.realIndex, a = this.w, n = 0;
                    n < a.globals.previousPaths.length;
                    n++
                  ) {
                    var r = a.globals.previousPaths[n];
                    ("line" === r.type || "area" === r.type) &&
                      r.paths.length > 0 &&
                      parseInt(r.realIndex, 10) === parseInt(s, 10) &&
                      ("line" === r.type
                        ? ((this.lineCtx.appendPathFrom = !1), (e = a.globals.previousPaths[n].paths[0].d))
                        : "area" === r.type &&
                          ((this.lineCtx.appendPathFrom = !1),
                          (i = a.globals.previousPaths[n].paths[0].d),
                          a.config.stroke.show &&
                            a.globals.previousPaths[n].paths[1] &&
                            (e = a.globals.previousPaths[n].paths[1].d)));
                  }
                  return { pathFromLine: e, pathFromArea: i };
                },
              },
              {
                key: "determineFirstPrevY",
                value: function (t) {
                  var e,
                    i = t.i,
                    s = t.series,
                    a = t.prevY,
                    n = t.lineYPosition,
                    r = this.w;
                  if (void 0 !== (null === (e = s[i]) || void 0 === e ? void 0 : e[0]))
                    a =
                      (n = r.config.chart.stacked && i > 0 ? this.lineCtx.prevSeriesY[i - 1][0] : this.lineCtx.zeroY) -
                      s[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] +
                      2 * (this.lineCtx.isReversed ? s[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
                  else if (r.config.chart.stacked && i > 0 && void 0 === s[i][0])
                    for (var o = i - 1; o >= 0; o--)
                      if (null !== s[o][0] && void 0 !== s[o][0]) {
                        a = n = this.lineCtx.prevSeriesY[o][0];
                        break;
                      }
                  return { prevY: a, lineYPosition: n };
                },
              },
            ]),
            t
          );
        })(),
        Dt = (function () {
          function t(e, i, s) {
            o(this, t),
              (this.ctx = e),
              (this.w = e.w),
              (this.xyRatios = i),
              (this.pointsChart =
                !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || s),
              (this.scatter = new X(this.ctx)),
              (this.noNegatives = this.w.globals.minX === Number.MAX_VALUE),
              (this.lineHelpers = new Ft(this)),
              (this.markers = new B(this.ctx)),
              (this.prevSeriesY = []),
              (this.categoryAxisCorrection = 0),
              (this.yaxisIndex = 0);
          }
          return (
            c(t, [
              {
                key: "draw",
                value: function (t, e, i, s) {
                  var a = this.w,
                    r = new k(this.ctx),
                    o = a.globals.comboCharts ? e : a.config.chart.type,
                    l = r.group({ class: "apexcharts-".concat(o, "-series apexcharts-plot-series") }),
                    c = new S(this.ctx, a);
                  (this.yRatio = this.xyRatios.yRatio),
                    (this.zRatio = this.xyRatios.zRatio),
                    (this.xRatio = this.xyRatios.xRatio),
                    (this.baseLineY = this.xyRatios.baseLineY),
                    (t = c.getLogSeries(t)),
                    (this.yRatio = c.getLogYRatios(this.yRatio));
                  for (var h = [], d = 0; d < t.length; d++) {
                    t = this.lineHelpers.sameValueSeriesFix(d, t);
                    var u = a.globals.comboCharts ? i[d] : d;
                    this._initSerieVariables(t, d, u);
                    var p = [],
                      g = [],
                      f = a.globals.padHorizontal + this.categoryAxisCorrection;
                    this.ctx.series.addCollapsedClassToSeries(this.elSeries, u),
                      a.globals.isXNumeric &&
                        a.globals.seriesX.length > 0 &&
                        (f = (a.globals.seriesX[u][0] - a.globals.minX) / this.xRatio),
                      g.push(f);
                    var m,
                      v = f,
                      x = void 0,
                      b = v,
                      y = this.zeroY,
                      w = this.zeroY;
                    (y = this.lineHelpers.determineFirstPrevY({ i: d, series: t, prevY: y, lineYPosition: 0 }).prevY),
                      p.push(y),
                      (m = y),
                      "rangeArea" === o &&
                        (x = w =
                          this.lineHelpers.determineFirstPrevY({ i: d, series: s, prevY: w, lineYPosition: 0 }).prevY);
                    var C = {
                        type: o,
                        series: t,
                        realIndex: u,
                        i: d,
                        x: f,
                        y: 1,
                        pX: v,
                        pY: m,
                        pathsFrom: this._calculatePathsFrom({
                          type: o,
                          series: t,
                          i: d,
                          realIndex: u,
                          prevX: b,
                          prevY: y,
                          prevY2: w,
                        }),
                        linePaths: [],
                        areaPaths: [],
                        seriesIndex: i,
                        lineYPosition: 0,
                        xArrj: g,
                        yArrj: p,
                        seriesRangeEnd: s,
                      },
                      A = this._iterateOverDataPoints(
                        n(n({}, C), {}, { iterations: "rangeArea" === o ? t[d].length - 1 : void 0, isRangeStart: !0 })
                      );
                    if ("rangeArea" === o) {
                      var E = this._calculatePathsFrom({ series: s, i: d, realIndex: u, prevX: b, prevY: w }),
                        T = this._iterateOverDataPoints(
                          n(
                            n({}, C),
                            {},
                            { series: s, pY: x, pathsFrom: E, iterations: s[d].length - 1, isRangeStart: !1 }
                          )
                        );
                      (A.linePaths[0] = T.linePath + A.linePath), (A.pathFromLine = T.pathFromLine + A.pathFromLine);
                    }
                    this._handlePaths({ type: o, realIndex: u, i: d, paths: A }),
                      this.elSeries.add(this.elPointsMain),
                      this.elSeries.add(this.elDataLabelsWrap),
                      h.push(this.elSeries);
                  }
                  if (a.config.chart.stacked) for (var L = h.length; L > 0; L--) l.add(h[L - 1]);
                  else for (var P = 0; P < h.length; P++) l.add(h[P]);
                  return l;
                },
              },
              {
                key: "_initSerieVariables",
                value: function (t, e, i) {
                  var s = this.w,
                    a = new k(this.ctx);
                  (this.xDivision =
                    s.globals.gridWidth / (s.globals.dataPoints - ("on" === s.config.xaxis.tickPlacement ? 1 : 0))),
                    (this.strokeWidth = Array.isArray(s.config.stroke.width)
                      ? s.config.stroke.width[i]
                      : s.config.stroke.width),
                    this.yRatio.length > 1 && (this.yaxisIndex = i),
                    (this.isReversed = s.config.yaxis[this.yaxisIndex] && s.config.yaxis[this.yaxisIndex].reversed),
                    (this.zeroY =
                      s.globals.gridHeight -
                      this.baseLineY[this.yaxisIndex] -
                      (this.isReversed ? s.globals.gridHeight : 0) +
                      (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0)),
                    (this.areaBottomY = this.zeroY),
                    (this.zeroY > s.globals.gridHeight || "end" === s.config.plotOptions.area.fillTo) &&
                      (this.areaBottomY = s.globals.gridHeight),
                    (this.categoryAxisCorrection = this.xDivision / 2),
                    (this.elSeries = a.group({
                      class: "apexcharts-series",
                      seriesName: b.escapeString(s.globals.seriesNames[i]),
                    })),
                    (this.elPointsMain = a.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i })),
                    (this.elDataLabelsWrap = a.group({ class: "apexcharts-datalabels", "data:realIndex": i }));
                  var n = t[e].length === s.globals.dataPoints;
                  this.elSeries.attr({ "data:longestSeries": n, rel: e + 1, "data:realIndex": i }),
                    (this.appendPathFrom = !0);
                },
              },
              {
                key: "_calculatePathsFrom",
                value: function (t) {
                  var e,
                    i,
                    s,
                    a,
                    n = t.type,
                    r = t.series,
                    o = t.i,
                    l = t.realIndex,
                    c = t.prevX,
                    h = t.prevY,
                    d = t.prevY2,
                    u = this.w,
                    p = new k(this.ctx);
                  if (null === r[o][0]) {
                    for (var g = 0; g < r[o].length; g++)
                      if (null !== r[o][g]) {
                        (c = this.xDivision * g),
                          (h = this.zeroY - r[o][g] / this.yRatio[this.yaxisIndex]),
                          (e = p.move(c, h)),
                          (i = p.move(c, this.areaBottomY));
                        break;
                      }
                  } else
                    (e = p.move(c, h)),
                      "rangeArea" === n && (e = p.move(c, d) + p.line(c, h)),
                      (i = p.move(c, this.areaBottomY) + p.line(c, h));
                  if (
                    ((s = p.move(-1, this.zeroY) + p.line(-1, this.zeroY)),
                    (a = p.move(-1, this.zeroY) + p.line(-1, this.zeroY)),
                    u.globals.previousPaths.length > 0)
                  ) {
                    var f = this.lineHelpers.checkPreviousPaths({ pathFromLine: s, pathFromArea: a, realIndex: l });
                    (s = f.pathFromLine), (a = f.pathFromArea);
                  }
                  return { prevX: c, prevY: h, linePath: e, areaPath: i, pathFromLine: s, pathFromArea: a };
                },
              },
              {
                key: "_handlePaths",
                value: function (t) {
                  var e = t.type,
                    i = t.realIndex,
                    s = t.i,
                    a = t.paths,
                    r = this.w,
                    o = new k(this.ctx),
                    l = new _(this.ctx);
                  this.prevSeriesY.push(a.yArrj),
                    (r.globals.seriesXvalues[i] = a.xArrj),
                    (r.globals.seriesYvalues[i] = a.yArrj);
                  var c = r.config.forecastDataPoints;
                  if (c.count > 0 && "rangeArea" !== e) {
                    var h = r.globals.seriesXvalues[i][r.globals.seriesXvalues[i].length - c.count - 1],
                      d = o.drawRect(h, 0, r.globals.gridWidth, r.globals.gridHeight, 0);
                    r.globals.dom.elForecastMask.appendChild(d.node);
                    var u = o.drawRect(0, 0, h, r.globals.gridHeight, 0);
                    r.globals.dom.elNonForecastMask.appendChild(u.node);
                  }
                  this.pointsChart || r.globals.delayedElements.push({ el: this.elPointsMain.node, index: i });
                  var p = {
                    i: s,
                    realIndex: i,
                    animationDelay: s,
                    initialSpeed: r.config.chart.animations.speed,
                    dataChangeSpeed: r.config.chart.animations.dynamicAnimation.speed,
                    className: "apexcharts-".concat(e),
                  };
                  if ("area" === e)
                    for (var g = l.fillPath({ seriesNumber: i }), f = 0; f < a.areaPaths.length; f++) {
                      var m = o.renderPaths(
                        n(
                          n({}, p),
                          {},
                          {
                            pathFrom: a.pathFromArea,
                            pathTo: a.areaPaths[f],
                            stroke: "none",
                            strokeWidth: 0,
                            strokeLineCap: null,
                            fill: g,
                          }
                        )
                      );
                      this.elSeries.add(m);
                    }
                  if (r.config.stroke.show && !this.pointsChart) {
                    var v = null;
                    if ("line" === e) v = l.fillPath({ seriesNumber: i, i: s });
                    else if ("solid" === r.config.stroke.fill.type) v = r.globals.stroke.colors[i];
                    else {
                      var x = r.config.fill;
                      (r.config.fill = r.config.stroke.fill),
                        (v = l.fillPath({ seriesNumber: i, i: s })),
                        (r.config.fill = x);
                    }
                    for (var b = 0; b < a.linePaths.length; b++) {
                      var y = v;
                      "rangeArea" === e && (y = l.fillPath({ seriesNumber: i }));
                      var w = n(
                          n({}, p),
                          {},
                          {
                            pathFrom: a.pathFromLine,
                            pathTo: a.linePaths[b],
                            stroke: v,
                            strokeWidth: this.strokeWidth,
                            strokeLineCap: r.config.stroke.lineCap,
                            fill: "rangeArea" === e ? y : "none",
                          }
                        ),
                        S = o.renderPaths(w);
                      if ((this.elSeries.add(S), S.attr("fill-rule", "evenodd"), c.count > 0 && "rangeArea" !== e)) {
                        var C = o.renderPaths(w);
                        C.node.setAttribute("stroke-dasharray", c.dashArray),
                          c.strokeWidth && C.node.setAttribute("stroke-width", c.strokeWidth),
                          this.elSeries.add(C),
                          C.attr("clip-path", "url(#forecastMask".concat(r.globals.cuid, ")")),
                          S.attr("clip-path", "url(#nonForecastMask".concat(r.globals.cuid, ")"));
                      }
                    }
                  }
                },
              },
              {
                key: "_iterateOverDataPoints",
                value: function (t) {
                  var e = t.type,
                    i = t.series,
                    s = t.iterations,
                    a = t.realIndex,
                    n = t.i,
                    r = t.x,
                    o = t.y,
                    l = t.pX,
                    c = t.pY,
                    h = t.pathsFrom,
                    d = t.linePaths,
                    u = t.areaPaths,
                    p = t.seriesIndex,
                    g = t.lineYPosition,
                    f = t.xArrj,
                    m = t.yArrj,
                    v = t.isRangeStart,
                    x = t.seriesRangeEnd,
                    y = this.w,
                    w = new k(this.ctx),
                    S = this.yRatio,
                    C = h.prevY,
                    A = h.linePath,
                    E = h.areaPath,
                    T = h.pathFromLine,
                    L = h.pathFromArea,
                    P = b.isNumber(y.globals.minYArr[a]) ? y.globals.minYArr[a] : y.globals.minY;
                  s || (s = y.globals.dataPoints > 1 ? y.globals.dataPoints - 1 : y.globals.dataPoints);
                  for (var M = o, O = 0; O < s; O++) {
                    var I = void 0 === i[n][O + 1] || null === i[n][O + 1];
                    if (y.globals.isXNumeric) {
                      var F = y.globals.seriesX[a][O + 1];
                      void 0 === y.globals.seriesX[a][O + 1] && (F = y.globals.seriesX[a][s - 1]),
                        (r = (F - y.globals.minX) / this.xRatio);
                    } else r += this.xDivision;
                    (g =
                      y.config.chart.stacked && n > 0 && y.globals.collapsedSeries.length < y.config.series.length - 1
                        ? this.prevSeriesY[
                            (function (t) {
                              for (var e = t, i = 0; i < y.globals.series.length; i++)
                                if (y.globals.collapsedSeriesIndices.indexOf(t) > -1) {
                                  e--;
                                  break;
                                }
                              return e >= 0 ? e : 0;
                            })(n - 1)
                          ][O + 1]
                        : this.zeroY),
                      I
                        ? (o = g - P / S[this.yaxisIndex] + 2 * (this.isReversed ? P / S[this.yaxisIndex] : 0))
                        : ((o =
                            g -
                            i[n][O + 1] / S[this.yaxisIndex] +
                            2 * (this.isReversed ? i[n][O + 1] / S[this.yaxisIndex] : 0)),
                          "rangeArea" === e &&
                            (M =
                              g -
                              x[n][O + 1] / S[this.yaxisIndex] +
                              2 * (this.isReversed ? x[n][O + 1] / S[this.yaxisIndex] : 0))),
                      f.push(r),
                      m.push(o);
                    var D = this.lineHelpers.calculatePoints({
                        series: i,
                        x: r,
                        y: o,
                        realIndex: a,
                        i: n,
                        j: O,
                        prevY: C,
                      }),
                      z = this._createPaths({
                        type: e,
                        series: i,
                        i: n,
                        realIndex: a,
                        j: O,
                        x: r,
                        y: o,
                        y2: M,
                        pX: l,
                        pY: c,
                        linePath: A,
                        areaPath: E,
                        linePaths: d,
                        areaPaths: u,
                        seriesIndex: p,
                        isRangeStart: v,
                      });
                    (u = z.areaPaths),
                      (d = z.linePaths),
                      (l = z.pX),
                      (c = z.pY),
                      (E = z.areaPath),
                      (A = z.linePath),
                      this.appendPathFrom && ((T += w.line(r, this.zeroY)), (L += w.line(r, this.zeroY))),
                      this.handleNullDataPoints(i, D, n, O, a),
                      this._handleMarkersAndLabels({
                        type: e,
                        pointsPos: D,
                        i: n,
                        j: O,
                        realIndex: a,
                        isRangeStart: v,
                      });
                  }
                  return {
                    yArrj: m,
                    xArrj: f,
                    pathFromArea: L,
                    areaPaths: u,
                    pathFromLine: T,
                    linePaths: d,
                    linePath: A,
                    areaPath: E,
                  };
                },
              },
              {
                key: "_handleMarkersAndLabels",
                value: function (t) {
                  var e = t.type,
                    i = t.pointsPos,
                    s = t.isRangeStart,
                    a = t.i,
                    n = t.j,
                    r = t.realIndex,
                    o = this.w,
                    l = new H(this.ctx);
                  if (this.pointsChart)
                    this.scatter.draw(this.elSeries, n, {
                      realIndex: r,
                      pointsPos: i,
                      zRatio: this.zRatio,
                      elParent: this.elPointsMain,
                    });
                  else {
                    o.globals.series[a].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
                    var c = this.markers.plotChartMarkers(i, r, n + 1);
                    null !== c && this.elPointsMain.add(c);
                  }
                  var h = l.drawDataLabel({ type: e, isRangeStart: s, pos: i, i: r, j: n + 1 });
                  null !== h && this.elDataLabelsWrap.add(h);
                },
              },
              {
                key: "_createPaths",
                value: function (t) {
                  var e = t.type,
                    i = t.series,
                    s = t.i,
                    a = t.realIndex,
                    n = t.j,
                    r = t.x,
                    o = t.y,
                    l = t.y2,
                    c = t.pX,
                    h = t.pY,
                    d = t.linePath,
                    u = t.areaPath,
                    p = t.linePaths,
                    g = t.areaPaths,
                    f = t.seriesIndex,
                    m = t.isRangeStart,
                    v = this.w,
                    x = new k(this.ctx),
                    b = v.config.stroke.curve,
                    y = this.areaBottomY;
                  if (
                    (Array.isArray(v.config.stroke.curve) &&
                      (b = Array.isArray(f) ? v.config.stroke.curve[f[s]] : v.config.stroke.curve[s]),
                    "smooth" === b)
                  ) {
                    var w = 0.35 * (r - c);
                    v.globals.hasNullValues
                      ? (null !== i[s][n] &&
                          (null !== i[s][n + 1]
                            ? ((d = x.move(c, h) + x.curve(c + w, h, r - w, o, r + 1, o)),
                              (u =
                                x.move(c + 1, h) +
                                x.curve(c + w, h, r - w, o, r + 1, o) +
                                x.line(r, y) +
                                x.line(c, y) +
                                "z"))
                            : ((d = x.move(c, h)), (u = x.move(c, h) + "z"))),
                        p.push(d),
                        g.push(u))
                      : ((d += x.curve(c + w, h, r - w, o, r, o)), (u += x.curve(c + w, h, r - w, o, r, o))),
                      (c = r),
                      (h = o),
                      n === i[s].length - 2 &&
                        ((u = u + x.curve(c, h, r, o, r, y) + x.move(r, o) + "z"),
                        "rangeArea" === e && m
                          ? (d = d + x.curve(c, h, r, o, r, l) + x.move(r, l) + "z")
                          : v.globals.hasNullValues || (p.push(d), g.push(u)));
                  } else {
                    if (null === i[s][n + 1]) {
                      d += x.move(r, o);
                      var S = v.globals.isXNumeric
                        ? (v.globals.seriesX[a][n] - v.globals.minX) / this.xRatio
                        : r - this.xDivision;
                      u = u + x.line(S, y) + x.move(r, o) + "z";
                    }
                    null === i[s][n] && ((d += x.move(r, o)), (u += x.move(r, y))),
                      "stepline" === b
                        ? ((d = d + x.line(r, null, "H") + x.line(null, o, "V")),
                          (u = u + x.line(r, null, "H") + x.line(null, o, "V")))
                        : "straight" === b && ((d += x.line(r, o)), (u += x.line(r, o))),
                      n === i[s].length - 2 &&
                        ((u = u + x.line(r, y) + x.move(r, o) + "z"),
                        "rangeArea" === e && m ? (d = d + x.line(r, l) + x.move(r, l) + "z") : (p.push(d), g.push(u)));
                  }
                  return { linePaths: p, areaPaths: g, pX: c, pY: h, linePath: d, areaPath: u };
                },
              },
              {
                key: "handleNullDataPoints",
                value: function (t, e, i, s, a) {
                  var n = this.w;
                  if ((null === t[i][s] && n.config.markers.showNullDataPoints) || 1 === t[i].length) {
                    var r = this.markers.plotChartMarkers(
                      e,
                      a,
                      s + 1,
                      this.strokeWidth - n.config.markers.strokeWidth / 2,
                      !0
                    );
                    null !== r && this.elPointsMain.add(r);
                  }
                },
              },
            ]),
            t
          );
        })();
      (window.TreemapSquared = {}),
        (window.TreemapSquared.generate = (function () {
          function t(e, i, s, a) {
            (this.xoffset = e),
              (this.yoffset = i),
              (this.height = a),
              (this.width = s),
              (this.shortestEdge = function () {
                return Math.min(this.height, this.width);
              }),
              (this.getCoordinates = function (t) {
                var e,
                  i = [],
                  s = this.xoffset,
                  a = this.yoffset,
                  r = n(t) / this.height,
                  o = n(t) / this.width;
                if (this.width >= this.height)
                  for (e = 0; e < t.length; e++) i.push([s, a, s + r, a + t[e] / r]), (a += t[e] / r);
                else for (e = 0; e < t.length; e++) i.push([s, a, s + t[e] / o, a + o]), (s += t[e] / o);
                return i;
              }),
              (this.cutArea = function (e) {
                var i;
                if (this.width >= this.height) {
                  var s = e / this.height,
                    a = this.width - s;
                  i = new t(this.xoffset + s, this.yoffset, a, this.height);
                } else {
                  var n = e / this.width,
                    r = this.height - n;
                  i = new t(this.xoffset, this.yoffset + n, this.width, r);
                }
                return i;
              });
          }
          function e(e, s, a, r, o) {
            (r = void 0 === r ? 0 : r), (o = void 0 === o ? 0 : o);
            var l = i(
              (function (t, e) {
                var i,
                  s = [],
                  a = e / n(t);
                for (i = 0; i < t.length; i++) s[i] = t[i] * a;
                return s;
              })(e, s * a),
              [],
              new t(r, o, s, a),
              []
            );
            return (function (t) {
              var e,
                i,
                s = [];
              for (e = 0; e < t.length; e++) for (i = 0; i < t[e].length; i++) s.push(t[e][i]);
              return s;
            })(l);
          }
          function i(t, e, a, r) {
            var o, l, c;
            if (0 !== t.length)
              return (
                (o = a.shortestEdge()),
                (function (t, e, i) {
                  var a;
                  return 0 === t.length || ((a = t.slice()).push(e), s(t, i) >= s(a, i));
                })(e, (l = t[0]), o)
                  ? (e.push(l), i(t.slice(1), e, a, r))
                  : ((c = a.cutArea(n(e), r)), r.push(a.getCoordinates(e)), i(t, [], c, r)),
                r
              );
            r.push(a.getCoordinates(e));
          }
          function s(t, e) {
            var i = Math.min.apply(Math, t),
              s = Math.max.apply(Math, t),
              a = n(t);
            return Math.max((Math.pow(e, 2) * s) / Math.pow(a, 2), Math.pow(a, 2) / (Math.pow(e, 2) * i));
          }
          function a(t) {
            return t && t.constructor === Array;
          }
          function n(t) {
            var e,
              i = 0;
            for (e = 0; e < t.length; e++) i += t[e];
            return i;
          }
          function r(t) {
            var e,
              i = 0;
            if (a(t[0])) for (e = 0; e < t.length; e++) i += r(t[e]);
            else i = n(t);
            return i;
          }
          return function t(i, s, n, o, l) {
            (o = void 0 === o ? 0 : o), (l = void 0 === l ? 0 : l);
            var c,
              h,
              d = [],
              u = [];
            if (a(i[0])) {
              for (h = 0; h < i.length; h++) d[h] = r(i[h]);
              for (c = e(d, s, n, o, l), h = 0; h < i.length; h++)
                u.push(t(i[h], c[h][2] - c[h][0], c[h][3] - c[h][1], c[h][0], c[h][1]));
            } else u = e(i, s, n, o, l);
            return u;
          };
        })());
      var zt,
        Nt,
        Rt = (function () {
          function t(e, i) {
            o(this, t),
              (this.ctx = e),
              (this.w = e.w),
              (this.strokeWidth = this.w.config.stroke.width),
              (this.helpers = new Et(e)),
              (this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation),
              (this.labels = []);
          }
          return (
            c(t, [
              {
                key: "draw",
                value: function (t) {
                  var e = this,
                    i = this.w,
                    s = new k(this.ctx),
                    a = new _(this.ctx),
                    n = s.group({ class: "apexcharts-treemap" });
                  if (i.globals.noData) return n;
                  var r = [];
                  return (
                    t.forEach(function (t) {
                      var e = t.map(function (t) {
                        return Math.abs(t);
                      });
                      r.push(e);
                    }),
                    (this.negRange = this.helpers.checkColorRange()),
                    i.config.series.forEach(function (t, i) {
                      t.data.forEach(function (t) {
                        Array.isArray(e.labels[i]) || (e.labels[i] = []), e.labels[i].push(t.x);
                      });
                    }),
                    window.TreemapSquared.generate(r, i.globals.gridWidth, i.globals.gridHeight).forEach(function (
                      r,
                      o
                    ) {
                      var l = s.group({
                        class: "apexcharts-series apexcharts-treemap-series",
                        seriesName: b.escapeString(i.globals.seriesNames[o]),
                        rel: o + 1,
                        "data:realIndex": o,
                      });
                      if (i.config.chart.dropShadow.enabled) {
                        var c = i.config.chart.dropShadow;
                        new w(e.ctx).dropShadow(n, c, o);
                      }
                      var h = s.group({ class: "apexcharts-data-labels" });
                      r.forEach(function (n, r) {
                        var c = n[0],
                          h = n[1],
                          d = n[2],
                          u = n[3],
                          p = s.drawRect(
                            c,
                            h,
                            d - c,
                            u - h,
                            0,
                            "#fff",
                            1,
                            e.strokeWidth,
                            i.config.plotOptions.treemap.useFillColorAsStroke ? f : i.globals.stroke.colors[o]
                          );
                        p.attr({ cx: c, cy: h, index: o, i: o, j: r, width: d - c, height: u - h });
                        var g = e.helpers.getShadeColor(i.config.chart.type, o, r, e.negRange),
                          f = g.color;
                        void 0 !== i.config.series[o].data[r] &&
                          i.config.series[o].data[r].fillColor &&
                          (f = i.config.series[o].data[r].fillColor);
                        var m = a.fillPath({ color: f, seriesNumber: o, dataPointIndex: r });
                        p.node.classList.add("apexcharts-treemap-rect"), p.attr({ fill: m }), e.helpers.addListeners(p);
                        var v = { x: c + (d - c) / 2, y: h + (u - h) / 2, width: 0, height: 0 },
                          x = { x: c, y: h, width: d - c, height: u - h };
                        if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
                          var b = 1;
                          i.globals.resized || (b = i.config.chart.animations.speed), e.animateTreemap(p, v, x, b);
                        }
                        if (i.globals.dataChanged) {
                          var y = 1;
                          e.dynamicAnim.enabled &&
                            i.globals.shouldAnimate &&
                            ((y = e.dynamicAnim.speed),
                            i.globals.previousPaths[o] &&
                              i.globals.previousPaths[o][r] &&
                              i.globals.previousPaths[o][r].rect &&
                              (v = i.globals.previousPaths[o][r].rect),
                            e.animateTreemap(p, v, x, y));
                        }
                        var w = e.getFontSize(n),
                          k = i.config.dataLabels.formatter(e.labels[o][r], {
                            value: i.globals.series[o][r],
                            seriesIndex: o,
                            dataPointIndex: r,
                            w: i,
                          }),
                          S = e.helpers.calculateDataLabels({
                            text: k,
                            x: (c + d) / 2,
                            y: (h + u) / 2 + e.strokeWidth / 2 + w / 3,
                            i: o,
                            j: r,
                            colorProps: g,
                            fontSize: w,
                            series: t,
                          });
                        i.config.dataLabels.enabled && S && e.rotateToFitLabel(S, w, k, c, h, d, u),
                          l.add(p),
                          null !== S && l.add(S);
                      }),
                        l.add(h),
                        n.add(l);
                    }),
                    n
                  );
                },
              },
              {
                key: "getFontSize",
                value: function (t) {
                  var e,
                    i,
                    s = this.w,
                    a =
                      (function t(e) {
                        var i,
                          s = 0;
                        if (Array.isArray(e[0])) for (i = 0; i < e.length; i++) s += t(e[i]);
                        else for (i = 0; i < e.length; i++) s += e[i].length;
                        return s;
                      })(this.labels) /
                      (function t(e) {
                        var i,
                          s = 0;
                        if (Array.isArray(e[0])) for (i = 0; i < e.length; i++) s += t(e[i]);
                        else for (i = 0; i < e.length; i++) s += 1;
                        return s;
                      })(this.labels);
                  return (
                    (e = (t[2] - t[0]) * (t[3] - t[1])),
                    (i = Math.pow(e, 0.5)),
                    Math.min(i / a, parseInt(s.config.dataLabels.style.fontSize, 10))
                  );
                },
              },
              {
                key: "rotateToFitLabel",
                value: function (t, e, i, s, a, n, r) {
                  var o = new k(this.ctx),
                    l = o.getTextRects(i, e);
                  if (l.width + this.w.config.stroke.width + 5 > n - s && l.width <= r - a) {
                    var c = o.rotateAroundCenter(t.node);
                    t.node.setAttribute("transform", "rotate(-90 ".concat(c.x, " ").concat(c.y, ")"));
                  }
                },
              },
              {
                key: "animateTreemap",
                value: function (t, e, i, s) {
                  var a = new y(this.ctx);
                  a.animateRect(
                    t,
                    { x: e.x, y: e.y, width: e.width, height: e.height },
                    { x: i.x, y: i.y, width: i.width, height: i.height },
                    s,
                    function () {
                      a.animationCompleted(t);
                    }
                  );
                },
              },
            ]),
            t
          );
        })(),
        _t = (function () {
          function t(e) {
            o(this, t),
              (this.ctx = e),
              (this.w = e.w),
              (this.timeScaleArray = []),
              (this.utc = this.w.config.xaxis.labels.datetimeUTC);
          }
          return (
            c(t, [
              {
                key: "calculateTimeScaleTicks",
                value: function (t, e) {
                  var i = this,
                    s = this.w;
                  if (s.globals.allSeriesCollapsed)
                    return (s.globals.labels = []), (s.globals.timescaleLabels = []), [];
                  var a = new O(this.ctx),
                    r = (e - t) / 864e5;
                  this.determineInterval(r),
                    (s.globals.disableZoomIn = !1),
                    (s.globals.disableZoomOut = !1),
                    r < 0.00011574074074074075
                      ? (s.globals.disableZoomIn = !0)
                      : r > 5e4 && (s.globals.disableZoomOut = !0);
                  var o = a.getTimeUnitsfromTimestamp(t, e, this.utc),
                    l = s.globals.gridWidth / r,
                    c = l / 24,
                    h = c / 60,
                    d = h / 60,
                    u = Math.floor(24 * r),
                    p = Math.floor(1440 * r),
                    g = Math.floor(86400 * r),
                    f = Math.floor(r),
                    m = Math.floor(r / 30),
                    v = Math.floor(r / 365),
                    x = {
                      minMillisecond: o.minMillisecond,
                      minSecond: o.minSecond,
                      minMinute: o.minMinute,
                      minHour: o.minHour,
                      minDate: o.minDate,
                      minMonth: o.minMonth,
                      minYear: o.minYear,
                    },
                    b = {
                      firstVal: x,
                      currentMillisecond: x.minMillisecond,
                      currentSecond: x.minSecond,
                      currentMinute: x.minMinute,
                      currentHour: x.minHour,
                      currentMonthDate: x.minDate,
                      currentDate: x.minDate,
                      currentMonth: x.minMonth,
                      currentYear: x.minYear,
                      daysWidthOnXAxis: l,
                      hoursWidthOnXAxis: c,
                      minutesWidthOnXAxis: h,
                      secondsWidthOnXAxis: d,
                      numberOfSeconds: g,
                      numberOfMinutes: p,
                      numberOfHours: u,
                      numberOfDays: f,
                      numberOfMonths: m,
                      numberOfYears: v,
                    };
                  switch (this.tickInterval) {
                    case "years":
                      this.generateYearScale(b);
                      break;
                    case "months":
                    case "half_year":
                      this.generateMonthScale(b);
                      break;
                    case "months_days":
                    case "months_fortnight":
                    case "days":
                    case "week_days":
                      this.generateDayScale(b);
                      break;
                    case "hours":
                      this.generateHourScale(b);
                      break;
                    case "minutes_fives":
                    case "minutes":
                      this.generateMinuteScale(b);
                      break;
                    case "seconds_tens":
                    case "seconds_fives":
                    case "seconds":
                      this.generateSecondScale(b);
                  }
                  var y = this.timeScaleArray.map(function (t) {
                    var e = {
                      position: t.position,
                      unit: t.unit,
                      year: t.year,
                      day: t.day ? t.day : 1,
                      hour: t.hour ? t.hour : 0,
                      month: t.month + 1,
                    };
                    return "month" === t.unit
                      ? n(n({}, e), {}, { day: 1, value: t.value + 1 })
                      : "day" === t.unit || "hour" === t.unit
                      ? n(n({}, e), {}, { value: t.value })
                      : "minute" === t.unit
                      ? n(n({}, e), {}, { value: t.value, minute: t.value })
                      : "second" === t.unit
                      ? n(n({}, e), {}, { value: t.value, minute: t.minute, second: t.second })
                      : t;
                  });
                  return y.filter(function (t) {
                    var e = 1,
                      a = Math.ceil(s.globals.gridWidth / 120),
                      n = t.value;
                    void 0 !== s.config.xaxis.tickAmount && (a = s.config.xaxis.tickAmount),
                      y.length > a && (e = Math.floor(y.length / a));
                    var r = !1,
                      o = !1;
                    switch (i.tickInterval) {
                      case "years":
                        "year" === t.unit && (r = !0);
                        break;
                      case "half_year":
                        (e = 7), "year" === t.unit && (r = !0);
                        break;
                      case "months":
                        (e = 1), "year" === t.unit && (r = !0);
                        break;
                      case "months_fortnight":
                        (e = 15), ("year" !== t.unit && "month" !== t.unit) || (r = !0), 30 === n && (o = !0);
                        break;
                      case "months_days":
                        (e = 10), "month" === t.unit && (r = !0), 30 === n && (o = !0);
                        break;
                      case "week_days":
                        (e = 8), "month" === t.unit && (r = !0);
                        break;
                      case "days":
                        (e = 1), "month" === t.unit && (r = !0);
                        break;
                      case "hours":
                        "day" === t.unit && (r = !0);
                        break;
                      case "minutes_fives":
                      case "seconds_fives":
                        n % 5 != 0 && (o = !0);
                        break;
                      case "seconds_tens":
                        n % 10 != 0 && (o = !0);
                    }
                    if (
                      "hours" === i.tickInterval ||
                      "minutes_fives" === i.tickInterval ||
                      "seconds_tens" === i.tickInterval ||
                      "seconds_fives" === i.tickInterval
                    ) {
                      if (!o) return !0;
                    } else if ((n % e == 0 || r) && !o) return !0;
                  });
                },
              },
              {
                key: "recalcDimensionsBasedOnFormat",
                value: function (t, e) {
                  var i = this.w,
                    s = this.formatDates(t),
                    a = this.removeOverlappingTS(s);
                  (i.globals.timescaleLabels = a.slice()), new ct(this.ctx).plotCoords();
                },
              },
              {
                key: "determineInterval",
                value: function (t) {
                  var e = 24 * t,
                    i = 60 * e;
                  switch (!0) {
                    case t / 365 > 5:
                      this.tickInterval = "years";
                      break;
                    case t > 800:
                      this.tickInterval = "half_year";
                      break;
                    case t > 180:
                      this.tickInterval = "months";
                      break;
                    case t > 90:
                      this.tickInterval = "months_fortnight";
                      break;
                    case t > 60:
                      this.tickInterval = "months_days";
                      break;
                    case t > 30:
                      this.tickInterval = "week_days";
                      break;
                    case t > 2:
                      this.tickInterval = "days";
                      break;
                    case e > 2.4:
                      this.tickInterval = "hours";
                      break;
                    case i > 15:
                      this.tickInterval = "minutes_fives";
                      break;
                    case i > 5:
                      this.tickInterval = "minutes";
                      break;
                    case i > 1:
                      this.tickInterval = "seconds_tens";
                      break;
                    case 60 * i > 20:
                      this.tickInterval = "seconds_fives";
                      break;
                    default:
                      this.tickInterval = "seconds";
                  }
                },
              },
              {
                key: "generateYearScale",
                value: function (t) {
                  var e = t.firstVal,
                    i = t.currentMonth,
                    s = t.currentYear,
                    a = t.daysWidthOnXAxis,
                    n = t.numberOfYears,
                    r = e.minYear,
                    o = 0,
                    l = new O(this.ctx),
                    c = "year";
                  if (e.minDate > 1 || e.minMonth > 0) {
                    var h = l.determineRemainingDaysOfYear(e.minYear, e.minMonth, e.minDate);
                    (o = (l.determineDaysOfYear(e.minYear) - h + 1) * a),
                      (r = e.minYear + 1),
                      this.timeScaleArray.push({ position: o, value: r, unit: c, year: r, month: b.monthMod(i + 1) });
                  } else
                    1 === e.minDate &&
                      0 === e.minMonth &&
                      this.timeScaleArray.push({ position: o, value: r, unit: c, year: s, month: b.monthMod(i + 1) });
                  for (var d = r, u = o, p = 0; p < n; p++)
                    d++,
                      (u = l.determineDaysOfYear(d - 1) * a + u),
                      this.timeScaleArray.push({ position: u, value: d, unit: c, year: d, month: 1 });
                },
              },
              {
                key: "generateMonthScale",
                value: function (t) {
                  var e = t.firstVal,
                    i = t.currentMonthDate,
                    s = t.currentMonth,
                    a = t.currentYear,
                    n = t.daysWidthOnXAxis,
                    r = t.numberOfMonths,
                    o = s,
                    l = 0,
                    c = new O(this.ctx),
                    h = "month",
                    d = 0;
                  if (e.minDate > 1) {
                    (l = (c.determineDaysOfMonths(s + 1, e.minYear) - i + 1) * n), (o = b.monthMod(s + 1));
                    var u = a + d,
                      p = b.monthMod(o),
                      g = o;
                    0 === o && ((h = "year"), (g = u), (p = 1), (u += d += 1)),
                      this.timeScaleArray.push({ position: l, value: g, unit: h, year: u, month: p });
                  } else this.timeScaleArray.push({ position: l, value: o, unit: h, year: a, month: b.monthMod(s) });
                  for (var f = o + 1, m = l, v = 0, x = 1; v < r; v++, x++) {
                    0 === (f = b.monthMod(f)) ? ((h = "year"), (d += 1)) : (h = "month");
                    var y = this._getYear(a, f, d);
                    m = c.determineDaysOfMonths(f, y) * n + m;
                    var w = 0 === f ? y : f;
                    this.timeScaleArray.push({ position: m, value: w, unit: h, year: y, month: 0 === f ? 1 : f }), f++;
                  }
                },
              },
              {
                key: "generateDayScale",
                value: function (t) {
                  var e = t.firstVal,
                    i = t.currentMonth,
                    s = t.currentYear,
                    a = t.hoursWidthOnXAxis,
                    n = t.numberOfDays,
                    r = new O(this.ctx),
                    o = "day",
                    l = e.minDate + 1,
                    c = l,
                    h = function (t, e, i) {
                      return t > r.determineDaysOfMonths(e + 1, i) ? ((c = 1), (o = "month"), (u = e += 1), e) : e;
                    },
                    d = (24 - e.minHour) * a,
                    u = l,
                    p = h(c, i, s);
                  0 === e.minHour && 1 === e.minDate
                    ? ((d = 0), (u = b.monthMod(e.minMonth)), (o = "month"), (c = e.minDate), n++)
                    : 1 !== e.minDate &&
                      0 === e.minHour &&
                      0 === e.minMinute &&
                      ((d = 0), (l = e.minDate), (u = l), (p = h((c = l), i, s))),
                    this.timeScaleArray.push({
                      position: d,
                      value: u,
                      unit: o,
                      year: this._getYear(s, p, 0),
                      month: b.monthMod(p),
                      day: c,
                    });
                  for (var g = d, f = 0; f < n; f++) {
                    (o = "day"), (p = h((c += 1), p, this._getYear(s, p, 0)));
                    var m = this._getYear(s, p, 0);
                    g = 24 * a + g;
                    var v = 1 === c ? b.monthMod(p) : c;
                    this.timeScaleArray.push({ position: g, value: v, unit: o, year: m, month: b.monthMod(p), day: v });
                  }
                },
              },
              {
                key: "generateHourScale",
                value: function (t) {
                  var e = t.firstVal,
                    i = t.currentDate,
                    s = t.currentMonth,
                    a = t.currentYear,
                    n = t.minutesWidthOnXAxis,
                    r = t.numberOfHours,
                    o = new O(this.ctx),
                    l = "hour",
                    c = function (t, e) {
                      return t > o.determineDaysOfMonths(e + 1, a) && ((f = 1), (e += 1)), { month: e, date: f };
                    },
                    h = function (t, e) {
                      return t > o.determineDaysOfMonths(e + 1, a) ? (e += 1) : e;
                    },
                    d = 60 - (e.minMinute + e.minSecond / 60),
                    u = d * n,
                    p = e.minHour + 1,
                    g = p + 1;
                  60 === d && ((u = 0), (g = (p = e.minHour) + 1));
                  var f = i,
                    m = h(f, s);
                  this.timeScaleArray.push({
                    position: u,
                    value: p,
                    unit: l,
                    day: f,
                    hour: g,
                    year: a,
                    month: b.monthMod(m),
                  });
                  for (var v = u, x = 0; x < r; x++) {
                    (l = "hour"), g >= 24 && ((g = 0), (l = "day"), (m = c((f += 1), m).month), (m = h(f, m)));
                    var y = this._getYear(a, m, 0);
                    v = 0 === g && 0 === x ? d * n : 60 * n + v;
                    var w = 0 === g ? f : g;
                    this.timeScaleArray.push({
                      position: v,
                      value: w,
                      unit: l,
                      hour: g,
                      day: f,
                      year: y,
                      month: b.monthMod(m),
                    }),
                      g++;
                  }
                },
              },
              {
                key: "generateMinuteScale",
                value: function (t) {
                  for (
                    var e = t.currentMillisecond,
                      i = t.currentSecond,
                      s = t.currentMinute,
                      a = t.currentHour,
                      n = t.currentDate,
                      r = t.currentMonth,
                      o = t.currentYear,
                      l = t.minutesWidthOnXAxis,
                      c = t.secondsWidthOnXAxis,
                      h = t.numberOfMinutes,
                      d = s + 1,
                      u = n,
                      p = r,
                      g = o,
                      f = a,
                      m = (60 - i - e / 1e3) * c,
                      v = 0;
                    v < h;
                    v++
                  )
                    d >= 60 && ((d = 0), 24 === (f += 1) && (f = 0)),
                      this.timeScaleArray.push({
                        position: m,
                        value: d,
                        unit: "minute",
                        hour: f,
                        minute: d,
                        day: u,
                        year: this._getYear(g, p, 0),
                        month: b.monthMod(p),
                      }),
                      (m += l),
                      d++;
                },
              },
              {
                key: "generateSecondScale",
                value: function (t) {
                  for (
                    var e = t.currentMillisecond,
                      i = t.currentSecond,
                      s = t.currentMinute,
                      a = t.currentHour,
                      n = t.currentDate,
                      r = t.currentMonth,
                      o = t.currentYear,
                      l = t.secondsWidthOnXAxis,
                      c = t.numberOfSeconds,
                      h = i + 1,
                      d = s,
                      u = n,
                      p = r,
                      g = o,
                      f = a,
                      m = ((1e3 - e) / 1e3) * l,
                      v = 0;
                    v < c;
                    v++
                  )
                    h >= 60 && ((h = 0), ++d >= 60 && ((d = 0), 24 == ++f && (f = 0))),
                      this.timeScaleArray.push({
                        position: m,
                        value: h,
                        unit: "second",
                        hour: f,
                        minute: d,
                        second: h,
                        day: u,
                        year: this._getYear(g, p, 0),
                        month: b.monthMod(p),
                      }),
                      (m += l),
                      h++;
                },
              },
              {
                key: "createRawDateString",
                value: function (t, e) {
                  var i = t.year;
                  return (
                    0 === t.month && (t.month = 1),
                    (i += "-" + ("0" + t.month.toString()).slice(-2)),
                    "day" === t.unit
                      ? (i += "day" === t.unit ? "-" + ("0" + e).slice(-2) : "-01")
                      : (i += "-" + ("0" + (t.day ? t.day : "1")).slice(-2)),
                    "hour" === t.unit
                      ? (i += "hour" === t.unit ? "T" + ("0" + e).slice(-2) : "T00")
                      : (i += "T" + ("0" + (t.hour ? t.hour : "0")).slice(-2)),
                    "minute" === t.unit
                      ? (i += ":" + ("0" + e).slice(-2))
                      : (i += ":" + (t.minute ? ("0" + t.minute).slice(-2) : "00")),
                    "second" === t.unit ? (i += ":" + ("0" + e).slice(-2)) : (i += ":00"),
                    this.utc && (i += ".000Z"),
                    i
                  );
                },
              },
              {
                key: "formatDates",
                value: function (t) {
                  var e = this,
                    i = this.w;
                  return t.map(function (t) {
                    var s = t.value.toString(),
                      a = new O(e.ctx),
                      n = e.createRawDateString(t, s),
                      r = a.getDate(a.parseDate(n));
                    if (
                      (e.utc || (r = a.getDate(a.parseDateWithTimezone(n))), void 0 === i.config.xaxis.labels.format)
                    ) {
                      var o = "dd MMM",
                        l = i.config.xaxis.labels.datetimeFormatter;
                      "year" === t.unit && (o = l.year),
                        "month" === t.unit && (o = l.month),
                        "day" === t.unit && (o = l.day),
                        "hour" === t.unit && (o = l.hour),
                        "minute" === t.unit && (o = l.minute),
                        "second" === t.unit && (o = l.second),
                        (s = a.formatDate(r, o));
                    } else s = a.formatDate(r, i.config.xaxis.labels.format);
                    return {
                      dateString: n,
                      position: t.position,
                      value: s,
                      unit: t.unit,
                      year: t.year,
                      month: t.month,
                    };
                  });
                },
              },
              {
                key: "removeOverlappingTS",
                value: function (t) {
                  var e,
                    i = this,
                    s = new k(this.ctx),
                    a = !1;
                  t.length > 0 &&
                    t[0].value &&
                    t.every(function (e) {
                      return e.value.length === t[0].value.length;
                    }) &&
                    ((a = !0), (e = s.getTextRects(t[0].value).width));
                  var n = 0,
                    r = t.map(function (r, o) {
                      if (o > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
                        var l = a ? e : s.getTextRects(t[n].value).width,
                          c = t[n].position;
                        return r.position > c + l + 10 ? ((n = o), r) : null;
                      }
                      return r;
                    });
                  return r.filter(function (t) {
                    return null !== t;
                  });
                },
              },
              {
                key: "_getYear",
                value: function (t, e, i) {
                  return t + Math.floor(e / 12) + i;
                },
              },
            ]),
            t
          );
        })(),
        Bt = (function () {
          function t(e, i) {
            o(this, t), (this.ctx = i), (this.w = i.w), (this.el = e);
          }
          return (
            c(t, [
              {
                key: "setupElements",
                value: function () {
                  var t = this.w.globals,
                    e = this.w.config,
                    i = e.chart.type;
                  (t.axisCharts =
                    [
                      "line",
                      "area",
                      "bar",
                      "rangeBar",
                      "rangeArea",
                      "candlestick",
                      "boxPlot",
                      "scatter",
                      "bubble",
                      "radar",
                      "heatmap",
                      "treemap",
                    ].indexOf(i) > -1),
                    (t.xyCharts =
                      [
                        "line",
                        "area",
                        "bar",
                        "rangeBar",
                        "rangeArea",
                        "candlestick",
                        "boxPlot",
                        "scatter",
                        "bubble",
                      ].indexOf(i) > -1),
                    (t.isBarHorizontal =
                      ("bar" === e.chart.type || "rangeBar" === e.chart.type || "boxPlot" === e.chart.type) &&
                      e.plotOptions.bar.horizontal),
                    (t.chartClass = ".apexcharts" + t.chartID),
                    (t.dom.baseEl = this.el),
                    (t.dom.elWrap = document.createElement("div")),
                    k.setAttrs(t.dom.elWrap, {
                      id: t.chartClass.substring(1),
                      class: "apexcharts-canvas " + t.chartClass.substring(1),
                    }),
                    this.el.appendChild(t.dom.elWrap),
                    (t.dom.Paper = new window.SVG.Doc(t.dom.elWrap)),
                    t.dom.Paper.attr({
                      class: "apexcharts-svg",
                      "xmlns:data": "ApexChartsNS",
                      transform: "translate(".concat(e.chart.offsetX, ", ").concat(e.chart.offsetY, ")"),
                    }),
                    (t.dom.Paper.node.style.background = e.chart.background),
                    this.setSVGDimensions(),
                    (t.dom.elGraphical = t.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" })),
                    (t.dom.elAnnotations = t.dom.Paper.group().attr({ class: "apexcharts-annotations" })),
                    (t.dom.elDefs = t.dom.Paper.defs()),
                    (t.dom.elLegendWrap = document.createElement("div")),
                    t.dom.elLegendWrap.classList.add("apexcharts-legend"),
                    t.dom.elWrap.appendChild(t.dom.elLegendWrap),
                    t.dom.Paper.add(t.dom.elGraphical),
                    t.dom.elGraphical.add(t.dom.elDefs);
                },
              },
              {
                key: "plotChartType",
                value: function (t, e) {
                  var i = this.w,
                    s = i.config,
                    a = i.globals,
                    n = { series: [], i: [] },
                    r = { series: [], i: [] },
                    o = { series: [], i: [] },
                    l = { series: [], i: [] },
                    c = { series: [], i: [] },
                    h = { series: [], i: [] },
                    d = { series: [], i: [] },
                    u = { series: [], i: [] },
                    p = { series: [], seriesRangeEnd: [], i: [] };
                  a.series.map(function (e, g) {
                    var f = 0;
                    void 0 !== t[g].type
                      ? ("column" === t[g].type || "bar" === t[g].type
                          ? (a.series.length > 1 &&
                              s.plotOptions.bar.horizontal &&
                              console.warn(
                                "Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"
                              ),
                            c.series.push(e),
                            c.i.push(g),
                            f++,
                            (i.globals.columnSeries = c.series))
                          : "area" === t[g].type
                          ? (r.series.push(e), r.i.push(g), f++)
                          : "line" === t[g].type
                          ? (n.series.push(e), n.i.push(g), f++)
                          : "scatter" === t[g].type
                          ? (o.series.push(e), o.i.push(g))
                          : "bubble" === t[g].type
                          ? (l.series.push(e), l.i.push(g), f++)
                          : "candlestick" === t[g].type
                          ? (h.series.push(e), h.i.push(g), f++)
                          : "boxPlot" === t[g].type
                          ? (d.series.push(e), d.i.push(g), f++)
                          : "rangeBar" === t[g].type
                          ? (u.series.push(e), u.i.push(g), f++)
                          : "rangeArea" === t[g].type
                          ? (p.series.push(a.seriesRangeStart[g]),
                            p.seriesRangeEnd.push(a.seriesRangeEnd[g]),
                            p.i.push(g),
                            f++)
                          : console.warn(
                              "You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble"
                            ),
                        f > 1 && (a.comboCharts = !0))
                      : (n.series.push(e), n.i.push(g));
                  });
                  var g = new Dt(this.ctx, e),
                    f = new At(this.ctx, e);
                  this.ctx.pie = new Pt(this.ctx);
                  var m = new Ot(this.ctx);
                  this.ctx.rangeBar = new It(this.ctx, e);
                  var v = new Mt(this.ctx),
                    x = [];
                  if (a.comboCharts) {
                    if ((r.series.length > 0 && x.push(g.draw(r.series, "area", r.i)), c.series.length > 0))
                      if (i.config.chart.stacked) {
                        var b = new Ct(this.ctx, e);
                        x.push(b.draw(c.series, c.i));
                      } else (this.ctx.bar = new St(this.ctx, e)), x.push(this.ctx.bar.draw(c.series, c.i));
                    if (
                      (p.series.length > 0 && x.push(g.draw(p.series, "rangeArea", p.i, p.seriesRangeEnd)),
                      n.series.length > 0 && x.push(g.draw(n.series, "line", n.i)),
                      h.series.length > 0 && x.push(f.draw(h.series, h.i)),
                      d.series.length > 0 && x.push(f.draw(d.series, d.i)),
                      u.series.length > 0 && x.push(this.ctx.rangeBar.draw(u.series, u.i)),
                      o.series.length > 0)
                    ) {
                      var y = new Dt(this.ctx, e, !0);
                      x.push(y.draw(o.series, "scatter", o.i));
                    }
                    if (l.series.length > 0) {
                      var w = new Dt(this.ctx, e, !0);
                      x.push(w.draw(l.series, "bubble", l.i));
                    }
                  } else
                    switch (s.chart.type) {
                      case "line":
                        x = g.draw(a.series, "line");
                        break;
                      case "area":
                        x = g.draw(a.series, "area");
                        break;
                      case "bar":
                        s.chart.stacked
                          ? (x = new Ct(this.ctx, e).draw(a.series))
                          : ((this.ctx.bar = new St(this.ctx, e)), (x = this.ctx.bar.draw(a.series)));
                        break;
                      case "candlestick":
                      case "boxPlot":
                        x = new At(this.ctx, e).draw(a.series);
                        break;
                      case "rangeBar":
                        x = this.ctx.rangeBar.draw(a.series);
                        break;
                      case "rangeArea":
                        x = g.draw(a.seriesRangeStart, "rangeArea", void 0, a.seriesRangeEnd);
                        break;
                      case "heatmap":
                        x = new Tt(this.ctx, e).draw(a.series);
                        break;
                      case "treemap":
                        x = new Rt(this.ctx, e).draw(a.series);
                        break;
                      case "pie":
                      case "donut":
                      case "polarArea":
                        x = this.ctx.pie.draw(a.series);
                        break;
                      case "radialBar":
                        x = m.draw(a.series);
                        break;
                      case "radar":
                        x = v.draw(a.series);
                        break;
                      default:
                        x = g.draw(a.series);
                    }
                  return x;
                },
              },
              {
                key: "setSVGDimensions",
                value: function () {
                  var t = this.w.globals,
                    e = this.w.config;
                  (t.svgWidth = e.chart.width), (t.svgHeight = e.chart.height);
                  var i = b.getDimensions(this.el),
                    s = e.chart.width
                      .toString()
                      .split(/[0-9]+/g)
                      .pop();
                  "%" === s
                    ? b.isNumber(i[0]) &&
                      (0 === i[0].width && (i = b.getDimensions(this.el.parentNode)),
                      (t.svgWidth = (i[0] * parseInt(e.chart.width, 10)) / 100))
                    : ("px" !== s && "" !== s) || (t.svgWidth = parseInt(e.chart.width, 10));
                  var a = e.chart.height
                    .toString()
                    .split(/[0-9]+/g)
                    .pop();
                  if ("auto" !== t.svgHeight && "" !== t.svgHeight)
                    if ("%" === a) {
                      var n = b.getDimensions(this.el.parentNode);
                      t.svgHeight = (n[1] * parseInt(e.chart.height, 10)) / 100;
                    } else t.svgHeight = parseInt(e.chart.height, 10);
                  else t.axisCharts ? (t.svgHeight = t.svgWidth / 1.61) : (t.svgHeight = t.svgWidth / 1.2);
                  if (
                    (t.svgWidth < 0 && (t.svgWidth = 0),
                    t.svgHeight < 0 && (t.svgHeight = 0),
                    k.setAttrs(t.dom.Paper.node, { width: t.svgWidth, height: t.svgHeight }),
                    "%" !== a)
                  ) {
                    var r = e.chart.sparkline.enabled ? 0 : t.axisCharts ? e.chart.parentHeightOffset : 0;
                    t.dom.Paper.node.parentNode.parentNode.style.minHeight = t.svgHeight + r + "px";
                  }
                  (t.dom.elWrap.style.width = t.svgWidth + "px"), (t.dom.elWrap.style.height = t.svgHeight + "px");
                },
              },
              {
                key: "shiftGraphPosition",
                value: function () {
                  var t = this.w.globals,
                    e = t.translateY,
                    i = { transform: "translate(" + t.translateX + ", " + e + ")" };
                  k.setAttrs(t.dom.elGraphical.node, i);
                },
              },
              {
                key: "resizeNonAxisCharts",
                value: function () {
                  var t = this.w,
                    e = t.globals,
                    i = 0,
                    s = t.config.chart.sparkline.enabled ? 1 : 15;
                  (s += t.config.grid.padding.bottom),
                    ("top" !== t.config.legend.position && "bottom" !== t.config.legend.position) ||
                      !t.config.legend.show ||
                      t.config.legend.floating ||
                      (i = new dt(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
                  var a = t.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"),
                    n = 2.05 * t.globals.radialSize;
                  if (a && !t.config.chart.sparkline.enabled && 0 !== t.config.plotOptions.radialBar.startAngle) {
                    var r = b.getBoundingClientRect(a);
                    n = r.bottom;
                    var o = r.bottom - r.top;
                    n = Math.max(2.05 * t.globals.radialSize, o);
                  }
                  var l = n + e.translateY + i + s;
                  e.dom.elLegendForeign && e.dom.elLegendForeign.setAttribute("height", l),
                    (t.config.chart.height && String(t.config.chart.height).indexOf("%") > 0) ||
                      ((e.dom.elWrap.style.height = l + "px"),
                      k.setAttrs(e.dom.Paper.node, { height: l }),
                      (e.dom.Paper.node.parentNode.parentNode.style.minHeight = l + "px"));
                },
              },
              {
                key: "coreCalculations",
                value: function () {
                  new Z(this.ctx).init();
                },
              },
              {
                key: "resetGlobals",
                value: function () {
                  var t = this,
                    e = function () {
                      return t.w.config.series.map(function (t) {
                        return [];
                      });
                    },
                    i = new N(),
                    s = this.w.globals;
                  i.initGlobalVars(s), (s.seriesXvalues = e()), (s.seriesYvalues = e());
                },
              },
              {
                key: "isMultipleY",
                value: function () {
                  if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1)
                    return (this.w.globals.isMultipleYAxis = !0), !0;
                },
              },
              {
                key: "xySettings",
                value: function () {
                  var t = null,
                    e = this.w;
                  if (e.globals.axisCharts) {
                    if (
                      ("back" === e.config.xaxis.crosshairs.position && new et(this.ctx).drawXCrosshairs(),
                      "back" === e.config.yaxis[0].crosshairs.position && new et(this.ctx).drawYCrosshairs(),
                      "datetime" === e.config.xaxis.type && void 0 === e.config.xaxis.labels.formatter)
                    ) {
                      this.ctx.timeScale = new _t(this.ctx);
                      var i = [];
                      isFinite(e.globals.minX) && isFinite(e.globals.maxX) && !e.globals.isBarHorizontal
                        ? (i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minX, e.globals.maxX))
                        : e.globals.isBarHorizontal &&
                          (i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minY, e.globals.maxY)),
                        this.ctx.timeScale.recalcDimensionsBasedOnFormat(i);
                    }
                    t = new S(this.ctx).getCalculatedRatios();
                  }
                  return t;
                },
              },
              {
                key: "updateSourceChart",
                value: function (t) {
                  (this.ctx.w.globals.selection = void 0),
                    this.ctx.updateHelpers._updateOptions(
                      { chart: { selection: { xaxis: { min: t.w.globals.minX, max: t.w.globals.maxX } } } },
                      !1,
                      !1
                    );
                },
              },
              {
                key: "setupBrushHandler",
                value: function () {
                  var t = this,
                    e = this.w;
                  if (e.config.chart.brush.enabled && "function" != typeof e.config.chart.events.selection) {
                    var i = e.config.chart.brush.targets || [e.config.chart.brush.target];
                    i.forEach(function (e) {
                      var i = ApexCharts.getChartByID(e);
                      (i.w.globals.brushSource = t.ctx),
                        "function" != typeof i.w.config.chart.events.zoomed &&
                          (i.w.config.chart.events.zoomed = function () {
                            t.updateSourceChart(i);
                          }),
                        "function" != typeof i.w.config.chart.events.scrolled &&
                          (i.w.config.chart.events.scrolled = function () {
                            t.updateSourceChart(i);
                          });
                    }),
                      (e.config.chart.events.selection = function (t, s) {
                        i.forEach(function (t) {
                          var i = ApexCharts.getChartByID(t),
                            a = b.clone(e.config.yaxis);
                          if (e.config.chart.brush.autoScaleYaxis && 1 === i.w.globals.series.length) {
                            var r = new q(i);
                            a = r.autoScaleY(i, a, s);
                          }
                          var o = i.w.config.yaxis.reduce(function (t, e, s) {
                            return [].concat(m(t), [
                              n(n({}, i.w.config.yaxis[s]), {}, { min: a[0].min, max: a[0].max }),
                            ]);
                          }, []);
                          i.ctx.updateHelpers._updateOptions(
                            { xaxis: { min: s.xaxis.min, max: s.xaxis.max }, yaxis: o },
                            !1,
                            !1,
                            !1,
                            !1
                          );
                        });
                      });
                  }
                },
              },
            ]),
            t
          );
        })(),
        Xt = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "_updateOptions",
                value: function (t) {
                  var e = this,
                    i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                    a = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                    n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                  return new Promise(function (o) {
                    var l = [e.ctx];
                    a && (l = e.ctx.getSyncedCharts()),
                      e.ctx.w.globals.isExecCalled && ((l = [e.ctx]), (e.ctx.w.globals.isExecCalled = !1)),
                      l.forEach(function (a, c) {
                        var h = a.w;
                        if (
                          ((h.globals.shouldAnimate = s),
                          i ||
                            ((h.globals.resized = !0), (h.globals.dataChanged = !0), s && a.series.getPreviousPaths()),
                          t &&
                            "object" === r(t) &&
                            ((a.config = new z(t)),
                            (t = S.extendArrayProps(a.config, t, h)),
                            a.w.globals.chartID !== e.ctx.w.globals.chartID && delete t.series,
                            (h.config = b.extend(h.config, t)),
                            n &&
                              ((h.globals.lastXAxis = t.xaxis ? b.clone(t.xaxis) : []),
                              (h.globals.lastYAxis = t.yaxis ? b.clone(t.yaxis) : []),
                              (h.globals.initialConfig = b.extend({}, h.config)),
                              (h.globals.initialSeries = b.clone(h.config.series)),
                              t.series)))
                        ) {
                          for (var d = 0; d < h.globals.collapsedSeriesIndices.length; d++) {
                            var u = h.config.series[h.globals.collapsedSeriesIndices[d]];
                            h.globals.collapsedSeries[d].data = h.globals.axisCharts ? u.data.slice() : u;
                          }
                          for (var p = 0; p < h.globals.ancillaryCollapsedSeriesIndices.length; p++) {
                            var g = h.config.series[h.globals.ancillaryCollapsedSeriesIndices[p]];
                            h.globals.ancillaryCollapsedSeries[p].data = h.globals.axisCharts ? g.data.slice() : g;
                          }
                          a.series.emptyCollapsedSeries(h.config.series);
                        }
                        return a.update(t).then(function () {
                          c === l.length - 1 && o(a);
                        });
                      });
                  });
                },
              },
              {
                key: "_updateSeries",
                value: function (t, e) {
                  var i = this,
                    s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                  return new Promise(function (a) {
                    var n,
                      r = i.w;
                    return (
                      (r.globals.shouldAnimate = e),
                      (r.globals.dataChanged = !0),
                      e && i.ctx.series.getPreviousPaths(),
                      r.globals.axisCharts
                        ? (0 ===
                            (n = t.map(function (t, e) {
                              return i._extendSeries(t, e);
                            })).length && (n = [{ data: [] }]),
                          (r.config.series = n))
                        : (r.config.series = t.slice()),
                      s &&
                        ((r.globals.initialConfig.series = b.clone(r.config.series)),
                        (r.globals.initialSeries = b.clone(r.config.series))),
                      i.ctx.update().then(function () {
                        a(i.ctx);
                      })
                    );
                  });
                },
              },
              {
                key: "_extendSeries",
                value: function (t, e) {
                  var i = this.w,
                    s = i.config.series[e];
                  return n(
                    n({}, i.config.series[e]),
                    {},
                    {
                      name: t.name ? t.name : s && s.name,
                      color: t.color ? t.color : s && s.color,
                      type: t.type ? t.type : s && s.type,
                      data: t.data ? t.data : s && s.data,
                    }
                  );
                },
              },
              {
                key: "toggleDataPointSelection",
                value: function (t, e) {
                  var i = this.w,
                    s = null,
                    a = ".apexcharts-series[data\\:realIndex='".concat(t, "']");
                  return (
                    i.globals.axisCharts
                      ? (s = i.globals.dom.Paper.select(
                          ""
                            .concat(a, " path[j='")
                            .concat(e, "'], ")
                            .concat(a, " circle[j='")
                            .concat(e, "'], ")
                            .concat(a, " rect[j='")
                            .concat(e, "']")
                        ).members[0])
                      : void 0 === e &&
                        ((s = i.globals.dom.Paper.select("".concat(a, " path[j='").concat(t, "']")).members[0]),
                        ("pie" !== i.config.chart.type &&
                          "polarArea" !== i.config.chart.type &&
                          "donut" !== i.config.chart.type) ||
                          this.ctx.pie.pieClicked(t)),
                    s
                      ? (new k(this.ctx).pathMouseDown(s, null), s.node ? s.node : null)
                      : (console.warn("toggleDataPointSelection: Element not found"), null)
                  );
                },
              },
              {
                key: "forceXAxisUpdate",
                value: function (t) {
                  var e = this.w;
                  if (
                    (["min", "max"].forEach(function (i) {
                      void 0 !== t.xaxis[i] &&
                        ((e.config.xaxis[i] = t.xaxis[i]), (e.globals.lastXAxis[i] = t.xaxis[i]));
                    }),
                    t.xaxis.categories && t.xaxis.categories.length && (e.config.xaxis.categories = t.xaxis.categories),
                    e.config.xaxis.convertedCatToNumeric)
                  ) {
                    var i = new D(t);
                    t = i.convertCatToNumericXaxis(t, this.ctx);
                  }
                  return t;
                },
              },
              {
                key: "forceYAxisUpdate",
                value: function (t) {
                  return (
                    t.chart &&
                      t.chart.stacked &&
                      "100%" === t.chart.stackType &&
                      (Array.isArray(t.yaxis)
                        ? t.yaxis.forEach(function (e, i) {
                            (t.yaxis[i].min = 0), (t.yaxis[i].max = 100);
                          })
                        : ((t.yaxis.min = 0), (t.yaxis.max = 100))),
                    t
                  );
                },
              },
              {
                key: "revertDefaultAxisMinMax",
                value: function (t) {
                  var e = this,
                    i = this.w,
                    s = i.globals.lastXAxis,
                    a = i.globals.lastYAxis;
                  t && t.xaxis && (s = t.xaxis),
                    t && t.yaxis && (a = t.yaxis),
                    (i.config.xaxis.min = s.min),
                    (i.config.xaxis.max = s.max),
                    i.config.yaxis.map(function (t, s) {
                      i.globals.zoomed || void 0 !== a[s]
                        ? (function (t) {
                            void 0 !== a[t] && ((i.config.yaxis[t].min = a[t].min), (i.config.yaxis[t].max = a[t].max));
                          })(s)
                        : void 0 !== e.ctx.opts.yaxis[s] &&
                          ((t.min = e.ctx.opts.yaxis[s].min), (t.max = e.ctx.opts.yaxis[s].max));
                    });
                },
              },
            ]),
            t
          );
        })();
      (zt = "undefined" != typeof window ? window : void 0),
        (Nt = function (t, e) {
          var i = ((void 0 !== this ? this : t).SVG = function (t) {
            if (i.supported) return (t = new i.Doc(t)), i.parser.draw || i.prepare(), t;
          });
          if (
            ((i.ns = "http://www.w3.org/2000/svg"),
            (i.xmlns = "http://www.w3.org/2000/xmlns/"),
            (i.xlink = "http://www.w3.org/1999/xlink"),
            (i.svgjs = "http://svgjs.dev"),
            (i.supported = !0),
            !i.supported)
          )
            return !1;
          (i.did = 1e3),
            (i.eid = function (t) {
              return "Svgjs" + d(t) + i.did++;
            }),
            (i.create = function (t) {
              var i = e.createElementNS(this.ns, t);
              return i.setAttribute("id", this.eid(t)), i;
            }),
            (i.extend = function () {
              var t, e;
              e = (t = [].slice.call(arguments)).pop();
              for (var s = t.length - 1; s >= 0; s--) if (t[s]) for (var a in e) t[s].prototype[a] = e[a];
              i.Set && i.Set.inherit && i.Set.inherit();
            }),
            (i.invent = function (t) {
              var e =
                "function" == typeof t.create
                  ? t.create
                  : function () {
                      this.constructor.call(this, i.create(t.create));
                    };
              return (
                t.inherit && (e.prototype = new t.inherit()),
                t.extend && i.extend(e, t.extend),
                t.construct && i.extend(t.parent || i.Container, t.construct),
                e
              );
            }),
            (i.adopt = function (e) {
              return e
                ? e.instance
                  ? e.instance
                  : (((s =
                      "svg" == e.nodeName
                        ? e.parentNode instanceof t.SVGElement
                          ? new i.Nested()
                          : new i.Doc()
                        : "linearGradient" == e.nodeName
                        ? new i.Gradient("linear")
                        : "radialGradient" == e.nodeName
                        ? new i.Gradient("radial")
                        : i[d(e.nodeName)]
                        ? new i[d(e.nodeName)]()
                        : new i.Element(e)).type = e.nodeName),
                    (s.node = e),
                    (e.instance = s),
                    s instanceof i.Doc && s.namespace().defs(),
                    s.setData(JSON.parse(e.getAttribute("svgjs:data")) || {}),
                    s)
                : null;
              var s;
            }),
            (i.prepare = function () {
              var t = e.getElementsByTagName("body")[0],
                s = (t ? new i.Doc(t) : i.adopt(e.documentElement).nested()).size(2, 0);
              i.parser = {
                body: t || e.documentElement,
                draw: s.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
                poly: s.polyline().node,
                path: s.path().node,
                native: i.create("svg"),
              };
            }),
            (i.parser = { native: i.create("svg") }),
            e.addEventListener(
              "DOMContentLoaded",
              function () {
                i.parser.draw || i.prepare();
              },
              !1
            ),
            (i.regex = {
              numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
              hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
              rgb: /rgb\((\d+),(\d+),(\d+)\)/,
              reference: /#([a-z0-9\-_]+)/i,
              transforms: /\)\s*,?\s*/,
              whitespace: /\s/g,
              isHex: /^#[a-f0-9]{3,6}$/i,
              isRgb: /^rgb\(/,
              isCss: /[^:]+:[^;]+;?/,
              isBlank: /^(\s+)?$/,
              isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
              isPercent: /^-?[\d\.]+%$/,
              isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
              delimiter: /[\s,]+/,
              hyphen: /([^e])\-/gi,
              pathLetters: /[MLHVCSQTAZ]/gi,
              isPathLetter: /[MLHVCSQTAZ]/i,
              numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
              dots: /\./g,
            }),
            (i.utils = {
              map: function (t, e) {
                for (var i = t.length, s = [], a = 0; a < i; a++) s.push(e(t[a]));
                return s;
              },
              filter: function (t, e) {
                for (var i = t.length, s = [], a = 0; a < i; a++) e(t[a]) && s.push(t[a]);
                return s;
              },
              filterSVGElements: function (e) {
                return this.filter(e, function (e) {
                  return e instanceof t.SVGElement;
                });
              },
            }),
            (i.defaults = {
              attrs: {
                "fill-opacity": 1,
                "stroke-opacity": 1,
                "stroke-width": 0,
                "stroke-linejoin": "miter",
                "stroke-linecap": "butt",
                fill: "#000000",
                stroke: "#000000",
                opacity: 1,
                x: 0,
                y: 0,
                cx: 0,
                cy: 0,
                width: 0,
                height: 0,
                r: 0,
                rx: 0,
                ry: 0,
                offset: 0,
                "stop-opacity": 1,
                "stop-color": "#000000",
                "font-size": 16,
                "font-family": "Helvetica, Arial, sans-serif",
                "text-anchor": "start",
              },
            }),
            (i.Color = function (t) {
              var e, s;
              (this.r = 0),
                (this.g = 0),
                (this.b = 0),
                t &&
                  ("string" == typeof t
                    ? i.regex.isRgb.test(t)
                      ? ((e = i.regex.rgb.exec(t.replace(i.regex.whitespace, ""))),
                        (this.r = parseInt(e[1])),
                        (this.g = parseInt(e[2])),
                        (this.b = parseInt(e[3])))
                      : i.regex.isHex.test(t) &&
                        ((e = i.regex.hex.exec(
                          4 == (s = t).length
                            ? [
                                "#",
                                s.substring(1, 2),
                                s.substring(1, 2),
                                s.substring(2, 3),
                                s.substring(2, 3),
                                s.substring(3, 4),
                                s.substring(3, 4),
                              ].join("")
                            : s
                        )),
                        (this.r = parseInt(e[1], 16)),
                        (this.g = parseInt(e[2], 16)),
                        (this.b = parseInt(e[3], 16)))
                    : "object" === r(t) && ((this.r = t.r), (this.g = t.g), (this.b = t.b)));
            }),
            i.extend(i.Color, {
              toString: function () {
                return this.toHex();
              },
              toHex: function () {
                return "#" + u(this.r) + u(this.g) + u(this.b);
              },
              toRgb: function () {
                return "rgb(" + [this.r, this.g, this.b].join() + ")";
              },
              brightness: function () {
                return (this.r / 255) * 0.3 + (this.g / 255) * 0.59 + (this.b / 255) * 0.11;
              },
              morph: function (t) {
                return (this.destination = new i.Color(t)), this;
              },
              at: function (t) {
                return this.destination
                  ? ((t = t < 0 ? 0 : t > 1 ? 1 : t),
                    new i.Color({
                      r: ~~(this.r + (this.destination.r - this.r) * t),
                      g: ~~(this.g + (this.destination.g - this.g) * t),
                      b: ~~(this.b + (this.destination.b - this.b) * t),
                    }))
                  : this;
              },
            }),
            (i.Color.test = function (t) {
              return (t += ""), i.regex.isHex.test(t) || i.regex.isRgb.test(t);
            }),
            (i.Color.isRgb = function (t) {
              return t && "number" == typeof t.r && "number" == typeof t.g && "number" == typeof t.b;
            }),
            (i.Color.isColor = function (t) {
              return i.Color.isRgb(t) || i.Color.test(t);
            }),
            (i.Array = function (t, e) {
              0 == (t = (t || []).valueOf()).length && e && (t = e.valueOf()), (this.value = this.parse(t));
            }),
            i.extend(i.Array, {
              toString: function () {
                return this.value.join(" ");
              },
              valueOf: function () {
                return this.value;
              },
              parse: function (t) {
                return (t = t.valueOf()), Array.isArray(t) ? t : this.split(t);
              },
            }),
            (i.PointArray = function (t, e) {
              i.Array.call(this, t, e || [[0, 0]]);
            }),
            (i.PointArray.prototype = new i.Array()),
            (i.PointArray.prototype.constructor = i.PointArray);
          for (
            var s = {
                M: function (t, e, i) {
                  return (e.x = i.x = t[0]), (e.y = i.y = t[1]), ["M", e.x, e.y];
                },
                L: function (t, e) {
                  return (e.x = t[0]), (e.y = t[1]), ["L", t[0], t[1]];
                },
                H: function (t, e) {
                  return (e.x = t[0]), ["H", t[0]];
                },
                V: function (t, e) {
                  return (e.y = t[0]), ["V", t[0]];
                },
                C: function (t, e) {
                  return (e.x = t[4]), (e.y = t[5]), ["C", t[0], t[1], t[2], t[3], t[4], t[5]];
                },
                Q: function (t, e) {
                  return (e.x = t[2]), (e.y = t[3]), ["Q", t[0], t[1], t[2], t[3]];
                },
                Z: function (t, e, i) {
                  return (e.x = i.x), (e.y = i.y), ["Z"];
                },
              },
              a = "mlhvqtcsaz".split(""),
              n = 0,
              o = a.length;
            n < o;
            ++n
          )
            s[a[n]] = (function (t) {
              return function (e, i, a) {
                if ("H" == t) e[0] = e[0] + i.x;
                else if ("V" == t) e[0] = e[0] + i.y;
                else if ("A" == t) (e[5] = e[5] + i.x), (e[6] = e[6] + i.y);
                else for (var n = 0, r = e.length; n < r; ++n) e[n] = e[n] + (n % 2 ? i.y : i.x);
                if (s && "function" == typeof s[t]) return s[t](e, i, a);
              };
            })(a[n].toUpperCase());
          (i.PathArray = function (t, e) {
            i.Array.call(this, t, e || [["M", 0, 0]]);
          }),
            (i.PathArray.prototype = new i.Array()),
            (i.PathArray.prototype.constructor = i.PathArray),
            i.extend(i.PathArray, {
              toString: function () {
                return (function (t) {
                  for (var e = 0, i = t.length, s = ""; e < i; e++)
                    (s += t[e][0]),
                      null != t[e][1] &&
                        ((s += t[e][1]),
                        null != t[e][2] &&
                          ((s += " "),
                          (s += t[e][2]),
                          null != t[e][3] &&
                            ((s += " "),
                            (s += t[e][3]),
                            (s += " "),
                            (s += t[e][4]),
                            null != t[e][5] &&
                              ((s += " "),
                              (s += t[e][5]),
                              (s += " "),
                              (s += t[e][6]),
                              null != t[e][7] && ((s += " "), (s += t[e][7]))))));
                  return s + " ";
                })(this.value);
              },
              move: function (t, e) {
                var i = this.bbox();
                return i.x, i.y, this;
              },
              at: function (t) {
                if (!this.destination) return this;
                for (
                  var e = this.value, s = this.destination.value, a = [], n = new i.PathArray(), r = 0, o = e.length;
                  r < o;
                  r++
                ) {
                  a[r] = [e[r][0]];
                  for (var l = 1, c = e[r].length; l < c; l++) a[r][l] = e[r][l] + (s[r][l] - e[r][l]) * t;
                  "A" === a[r][0] && ((a[r][4] = +(0 != a[r][4])), (a[r][5] = +(0 != a[r][5])));
                }
                return (n.value = a), n;
              },
              parse: function (t) {
                if (t instanceof i.PathArray) return t.valueOf();
                var e,
                  a = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
                t =
                  "string" == typeof t
                    ? t
                        .replace(i.regex.numbersWithDots, c)
                        .replace(i.regex.pathLetters, " $& ")
                        .replace(i.regex.hyphen, "$1 -")
                        .trim()
                        .split(i.regex.delimiter)
                    : t.reduce(function (t, e) {
                        return [].concat.call(t, e);
                      }, []);
                var n = [],
                  r = new i.Point(),
                  o = new i.Point(),
                  l = 0,
                  h = t.length;
                do {
                  i.regex.isPathLetter.test(t[l]) ? ((e = t[l]), ++l) : "M" == e ? (e = "L") : "m" == e && (e = "l"),
                    n.push(s[e].call(null, t.slice(l, (l += a[e.toUpperCase()])).map(parseFloat), r, o));
                } while (h > l);
                return n;
              },
              bbox: function () {
                return (
                  i.parser.draw || i.prepare(),
                  i.parser.path.setAttribute("d", this.toString()),
                  i.parser.path.getBBox()
                );
              },
            }),
            (i.Number = i.invent({
              create: function (t, e) {
                (this.value = 0),
                  (this.unit = e || ""),
                  "number" == typeof t
                    ? (this.value = isNaN(t) ? 0 : isFinite(t) ? t : t < 0 ? -34e37 : 34e37)
                    : "string" == typeof t
                    ? (e = t.match(i.regex.numberAndUnit)) &&
                      ((this.value = parseFloat(e[1])),
                      "%" == e[5] ? (this.value /= 100) : "s" == e[5] && (this.value *= 1e3),
                      (this.unit = e[5]))
                    : t instanceof i.Number && ((this.value = t.valueOf()), (this.unit = t.unit));
              },
              extend: {
                toString: function () {
                  return (
                    ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) +
                    this.unit
                  );
                },
                toJSON: function () {
                  return this.toString();
                },
                valueOf: function () {
                  return this.value;
                },
                plus: function (t) {
                  return (t = new i.Number(t)), new i.Number(this + t, this.unit || t.unit);
                },
                minus: function (t) {
                  return (t = new i.Number(t)), new i.Number(this - t, this.unit || t.unit);
                },
                times: function (t) {
                  return (t = new i.Number(t)), new i.Number(this * t, this.unit || t.unit);
                },
                divide: function (t) {
                  return (t = new i.Number(t)), new i.Number(this / t, this.unit || t.unit);
                },
                to: function (t) {
                  var e = new i.Number(this);
                  return "string" == typeof t && (e.unit = t), e;
                },
                morph: function (t) {
                  return (
                    (this.destination = new i.Number(t)), t.relative && (this.destination.value += this.value), this
                  );
                },
                at: function (t) {
                  return this.destination ? new i.Number(this.destination).minus(this).times(t).plus(this) : this;
                },
              },
            })),
            (i.Element = i.invent({
              create: function (t) {
                (this._stroke = i.defaults.attrs.stroke),
                  (this._event = null),
                  (this.dom = {}),
                  (this.node = t) &&
                    ((this.type = t.nodeName),
                    (this.node.instance = this),
                    (this._stroke = t.getAttribute("stroke") || this._stroke));
              },
              extend: {
                x: function (t) {
                  return this.attr("x", t);
                },
                y: function (t) {
                  return this.attr("y", t);
                },
                cx: function (t) {
                  return null == t ? this.x() + this.width() / 2 : this.x(t - this.width() / 2);
                },
                cy: function (t) {
                  return null == t ? this.y() + this.height() / 2 : this.y(t - this.height() / 2);
                },
                move: function (t, e) {
                  return this.x(t).y(e);
                },
                center: function (t, e) {
                  return this.cx(t).cy(e);
                },
                width: function (t) {
                  return this.attr("width", t);
                },
                height: function (t) {
                  return this.attr("height", t);
                },
                size: function (t, e) {
                  var s = p(this, t, e);
                  return this.width(new i.Number(s.width)).height(new i.Number(s.height));
                },
                clone: function (t) {
                  this.writeDataToDom();
                  var e = m(this.node.cloneNode(!0));
                  return t ? t.add(e) : this.after(e), e;
                },
                remove: function () {
                  return this.parent() && this.parent().removeElement(this), this;
                },
                replace: function (t) {
                  return this.after(t).remove(), t;
                },
                addTo: function (t) {
                  return t.put(this);
                },
                putIn: function (t) {
                  return t.add(this);
                },
                id: function (t) {
                  return this.attr("id", t);
                },
                show: function () {
                  return this.style("display", "");
                },
                hide: function () {
                  return this.style("display", "none");
                },
                visible: function () {
                  return "none" != this.style("display");
                },
                toString: function () {
                  return this.attr("id");
                },
                classes: function () {
                  var t = this.attr("class");
                  return null == t ? [] : t.trim().split(i.regex.delimiter);
                },
                hasClass: function (t) {
                  return -1 != this.classes().indexOf(t);
                },
                addClass: function (t) {
                  if (!this.hasClass(t)) {
                    var e = this.classes();
                    e.push(t), this.attr("class", e.join(" "));
                  }
                  return this;
                },
                removeClass: function (t) {
                  return (
                    this.hasClass(t) &&
                      this.attr(
                        "class",
                        this.classes()
                          .filter(function (e) {
                            return e != t;
                          })
                          .join(" ")
                      ),
                    this
                  );
                },
                toggleClass: function (t) {
                  return this.hasClass(t) ? this.removeClass(t) : this.addClass(t);
                },
                reference: function (t) {
                  return i.get(this.attr(t));
                },
                parent: function (e) {
                  var s = this;
                  if (!s.node.parentNode) return null;
                  if (((s = i.adopt(s.node.parentNode)), !e)) return s;
                  for (; s && s.node instanceof t.SVGElement; ) {
                    if ("string" == typeof e ? s.matches(e) : s instanceof e) return s;
                    if (!s.node.parentNode || "#document" == s.node.parentNode.nodeName) return null;
                    s = i.adopt(s.node.parentNode);
                  }
                },
                doc: function () {
                  return this instanceof i.Doc ? this : this.parent(i.Doc);
                },
                parents: function (t) {
                  var e = [],
                    i = this;
                  do {
                    if (!(i = i.parent(t)) || !i.node) break;
                    e.push(i);
                  } while (i.parent);
                  return e;
                },
                matches: function (t) {
                  return (function (t, e) {
                    return (
                      t.matches ||
                      t.matchesSelector ||
                      t.msMatchesSelector ||
                      t.mozMatchesSelector ||
                      t.webkitMatchesSelector ||
                      t.oMatchesSelector
                    ).call(t, e);
                  })(this.node, t);
                },
                native: function () {
                  return this.node;
                },
                svg: function (t) {
                  var s = e.createElement("svg");
                  if (!(t && this instanceof i.Parent))
                    return (
                      s.appendChild((t = e.createElement("svg"))),
                      this.writeDataToDom(),
                      t.appendChild(this.node.cloneNode(!0)),
                      s.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "")
                    );
                  s.innerHTML =
                    "<svg>" + t.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
                  for (var a = 0, n = s.firstChild.childNodes.length; a < n; a++)
                    this.node.appendChild(s.firstChild.firstChild);
                  return this;
                },
                writeDataToDom: function () {
                  return (
                    (this.each || this.lines) &&
                      (this.each ? this : this.lines()).each(function () {
                        this.writeDataToDom();
                      }),
                    this.node.removeAttribute("svgjs:data"),
                    Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)),
                    this
                  );
                },
                setData: function (t) {
                  return (this.dom = t), this;
                },
                is: function (t) {
                  return (function (t, e) {
                    return t instanceof e;
                  })(this, t);
                },
              },
            })),
            (i.easing = {
              "-": function (t) {
                return t;
              },
              "<>": function (t) {
                return -Math.cos(t * Math.PI) / 2 + 0.5;
              },
              ">": function (t) {
                return Math.sin((t * Math.PI) / 2);
              },
              "<": function (t) {
                return 1 - Math.cos((t * Math.PI) / 2);
              },
            }),
            (i.morph = function (t) {
              return function (e, s) {
                return new i.MorphObj(e, s).at(t);
              };
            }),
            (i.Situation = i.invent({
              create: function (t) {
                (this.init = !1),
                  (this.reversed = !1),
                  (this.reversing = !1),
                  (this.duration = new i.Number(t.duration).valueOf()),
                  (this.delay = new i.Number(t.delay).valueOf()),
                  (this.start = +new Date() + this.delay),
                  (this.finish = this.start + this.duration),
                  (this.ease = t.ease),
                  (this.loop = 0),
                  (this.loops = !1),
                  (this.animations = {}),
                  (this.attrs = {}),
                  (this.styles = {}),
                  (this.transforms = []),
                  (this.once = {});
              },
            })),
            (i.FX = i.invent({
              create: function (t) {
                (this._target = t),
                  (this.situations = []),
                  (this.active = !1),
                  (this.situation = null),
                  (this.paused = !1),
                  (this.lastPos = 0),
                  (this.pos = 0),
                  (this.absPos = 0),
                  (this._speed = 1);
              },
              extend: {
                animate: function (t, e, s) {
                  "object" === r(t) && ((e = t.ease), (s = t.delay), (t = t.duration));
                  var a = new i.Situation({ duration: t || 1e3, delay: s || 0, ease: i.easing[e || "-"] || e });
                  return this.queue(a), this;
                },
                target: function (t) {
                  return t && t instanceof i.Element ? ((this._target = t), this) : this._target;
                },
                timeToAbsPos: function (t) {
                  return (t - this.situation.start) / (this.situation.duration / this._speed);
                },
                absPosToTime: function (t) {
                  return (this.situation.duration / this._speed) * t + this.situation.start;
                },
                startAnimFrame: function () {
                  this.stopAnimFrame(),
                    (this.animationFrame = t.requestAnimationFrame(
                      function () {
                        this.step();
                      }.bind(this)
                    ));
                },
                stopAnimFrame: function () {
                  t.cancelAnimationFrame(this.animationFrame);
                },
                start: function () {
                  return !this.active && this.situation && ((this.active = !0), this.startCurrent()), this;
                },
                startCurrent: function () {
                  return (
                    (this.situation.start = +new Date() + this.situation.delay / this._speed),
                    (this.situation.finish = this.situation.start + this.situation.duration / this._speed),
                    this.initAnimations().step()
                  );
                },
                queue: function (t) {
                  return (
                    ("function" == typeof t || t instanceof i.Situation) && this.situations.push(t),
                    this.situation || (this.situation = this.situations.shift()),
                    this
                  );
                },
                dequeue: function () {
                  return (
                    this.stop(),
                    (this.situation = this.situations.shift()),
                    this.situation &&
                      (this.situation instanceof i.Situation ? this.start() : this.situation.call(this)),
                    this
                  );
                },
                initAnimations: function () {
                  var t,
                    e = this.situation;
                  if (e.init) return this;
                  for (var s in e.animations) {
                    (t = this.target()[s]()),
                      Array.isArray(t) || (t = [t]),
                      Array.isArray(e.animations[s]) || (e.animations[s] = [e.animations[s]]);
                    for (var a = t.length; a--; )
                      e.animations[s][a] instanceof i.Number && (t[a] = new i.Number(t[a])),
                        (e.animations[s][a] = t[a].morph(e.animations[s][a]));
                  }
                  for (var s in e.attrs) e.attrs[s] = new i.MorphObj(this.target().attr(s), e.attrs[s]);
                  for (var s in e.styles) e.styles[s] = new i.MorphObj(this.target().style(s), e.styles[s]);
                  return (e.initialTransformation = this.target().matrixify()), (e.init = !0), this;
                },
                clearQueue: function () {
                  return (this.situations = []), this;
                },
                clearCurrent: function () {
                  return (this.situation = null), this;
                },
                stop: function (t, e) {
                  var i = this.active;
                  return (
                    (this.active = !1),
                    e && this.clearQueue(),
                    t && this.situation && (!i && this.startCurrent(), this.atEnd()),
                    this.stopAnimFrame(),
                    this.clearCurrent()
                  );
                },
                after: function (t) {
                  var e = this.last();
                  return (
                    this.target().on("finished.fx", function i(s) {
                      s.detail.situation == e && (t.call(this, e), this.off("finished.fx", i));
                    }),
                    this._callStart()
                  );
                },
                during: function (t) {
                  var e = this.last(),
                    s = function (s) {
                      s.detail.situation == e && t.call(this, s.detail.pos, i.morph(s.detail.pos), s.detail.eased, e);
                    };
                  return (
                    this.target().off("during.fx", s).on("during.fx", s),
                    this.after(function () {
                      this.off("during.fx", s);
                    }),
                    this._callStart()
                  );
                },
                afterAll: function (t) {
                  var e = function e(i) {
                    t.call(this), this.off("allfinished.fx", e);
                  };
                  return this.target().off("allfinished.fx", e).on("allfinished.fx", e), this._callStart();
                },
                last: function () {
                  return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
                },
                add: function (t, e, i) {
                  return (this.last()[i || "animations"][t] = e), this._callStart();
                },
                step: function (t) {
                  var e, i, s;
                  t || (this.absPos = this.timeToAbsPos(+new Date())),
                    !1 !== this.situation.loops
                      ? ((e = Math.max(this.absPos, 0)),
                        (i = Math.floor(e)),
                        !0 === this.situation.loops || i < this.situation.loops
                          ? ((this.pos = e - i), (s = this.situation.loop), (this.situation.loop = i))
                          : ((this.absPos = this.situation.loops),
                            (this.pos = 1),
                            (s = this.situation.loop - 1),
                            (this.situation.loop = this.situation.loops)),
                        this.situation.reversing &&
                          (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - s) % 2)))
                      : ((this.absPos = Math.min(this.absPos, 1)), (this.pos = this.absPos)),
                    this.pos < 0 && (this.pos = 0),
                    this.situation.reversed && (this.pos = 1 - this.pos);
                  var a = this.situation.ease(this.pos);
                  for (var n in this.situation.once)
                    n > this.lastPos &&
                      n <= a &&
                      (this.situation.once[n].call(this.target(), this.pos, a), delete this.situation.once[n]);
                  return (
                    this.active &&
                      this.target().fire("during", { pos: this.pos, eased: a, fx: this, situation: this.situation }),
                    this.situation
                      ? (this.eachAt(),
                        (1 == this.pos && !this.situation.reversed) || (this.situation.reversed && 0 == this.pos)
                          ? (this.stopAnimFrame(),
                            this.target().fire("finished", { fx: this, situation: this.situation }),
                            this.situations.length ||
                              (this.target().fire("allfinished"),
                              this.situations.length || (this.target().off(".fx"), (this.active = !1))),
                            this.active ? this.dequeue() : this.clearCurrent())
                          : !this.paused && this.active && this.startAnimFrame(),
                        (this.lastPos = a),
                        this)
                      : this
                  );
                },
                eachAt: function () {
                  var t,
                    e = this,
                    s = this.target(),
                    a = this.situation;
                  for (var n in a.animations)
                    (t = [].concat(a.animations[n]).map(function (t) {
                      return "string" != typeof t && t.at ? t.at(a.ease(e.pos), e.pos) : t;
                    })),
                      s[n].apply(s, t);
                  for (var n in a.attrs)
                    (t = [n].concat(a.attrs[n]).map(function (t) {
                      return "string" != typeof t && t.at ? t.at(a.ease(e.pos), e.pos) : t;
                    })),
                      s.attr.apply(s, t);
                  for (var n in a.styles)
                    (t = [n].concat(a.styles[n]).map(function (t) {
                      return "string" != typeof t && t.at ? t.at(a.ease(e.pos), e.pos) : t;
                    })),
                      s.style.apply(s, t);
                  if (a.transforms.length) {
                    (t = a.initialTransformation), (n = 0);
                    for (var r = a.transforms.length; n < r; n++) {
                      var o = a.transforms[n];
                      o instanceof i.Matrix
                        ? (t = o.relative
                            ? t.multiply(new i.Matrix().morph(o).at(a.ease(this.pos)))
                            : t.morph(o).at(a.ease(this.pos)))
                        : (o.relative || o.undo(t.extract()), (t = t.multiply(o.at(a.ease(this.pos)))));
                    }
                    s.matrix(t);
                  }
                  return this;
                },
                once: function (t, e, i) {
                  var s = this.last();
                  return i || (t = s.ease(t)), (s.once[t] = e), this;
                },
                _callStart: function () {
                  return (
                    setTimeout(
                      function () {
                        this.start();
                      }.bind(this),
                      0
                    ),
                    this
                  );
                },
              },
              parent: i.Element,
              construct: {
                animate: function (t, e, s) {
                  return (this.fx || (this.fx = new i.FX(this))).animate(t, e, s);
                },
                delay: function (t) {
                  return (this.fx || (this.fx = new i.FX(this))).delay(t);
                },
                stop: function (t, e) {
                  return this.fx && this.fx.stop(t, e), this;
                },
                finish: function () {
                  return this.fx && this.fx.finish(), this;
                },
              },
            })),
            (i.MorphObj = i.invent({
              create: function (t, e) {
                return i.Color.isColor(e)
                  ? new i.Color(t).morph(e)
                  : i.regex.delimiter.test(t)
                  ? i.regex.pathLetters.test(t)
                    ? new i.PathArray(t).morph(e)
                    : new i.Array(t).morph(e)
                  : i.regex.numberAndUnit.test(e)
                  ? new i.Number(t).morph(e)
                  : ((this.value = t), void (this.destination = e));
              },
              extend: {
                at: function (t, e) {
                  return e < 1 ? this.value : this.destination;
                },
                valueOf: function () {
                  return this.value;
                },
              },
            })),
            i.extend(i.FX, {
              attr: function (t, e, i) {
                if ("object" === r(t)) for (var s in t) this.attr(s, t[s]);
                else this.add(t, e, "attrs");
                return this;
              },
              plot: function (t, e, i, s) {
                return 4 == arguments.length
                  ? this.plot([t, e, i, s])
                  : this.add("plot", new (this.target().morphArray)(t));
              },
            }),
            (i.Box = i.invent({
              create: function (t, e, s, a) {
                if (!("object" !== r(t) || t instanceof i.Element))
                  return i.Box.call(
                    this,
                    null != t.left ? t.left : t.x,
                    null != t.top ? t.top : t.y,
                    t.width,
                    t.height
                  );
                4 == arguments.length && ((this.x = t), (this.y = e), (this.width = s), (this.height = a)), v(this);
              },
            })),
            (i.BBox = i.invent({
              create: function (t) {
                if ((i.Box.apply(this, [].slice.call(arguments)), t instanceof i.Element)) {
                  var s;
                  try {
                    if (!e.documentElement.contains) {
                      for (var a = t.node; a.parentNode; ) a = a.parentNode;
                      if (a != e) throw new Error("Element not in the dom");
                    }
                    s = t.node.getBBox();
                  } catch (e) {
                    if (t instanceof i.Shape) {
                      i.parser.draw || i.prepare();
                      var n = t.clone(i.parser.draw.instance).show();
                      n && n.node && "function" == typeof n.node.getBBox && (s = n.node.getBBox()),
                        n && "function" == typeof n.remove && n.remove();
                    } else
                      s = {
                        x: t.node.clientLeft,
                        y: t.node.clientTop,
                        width: t.node.clientWidth,
                        height: t.node.clientHeight,
                      };
                  }
                  i.Box.call(this, s);
                }
              },
              inherit: i.Box,
              parent: i.Element,
              construct: {
                bbox: function () {
                  return new i.BBox(this);
                },
              },
            })),
            (i.BBox.prototype.constructor = i.BBox),
            (i.Matrix = i.invent({
              create: function (t) {
                var e = f([1, 0, 0, 1, 0, 0]);
                t =
                  null === t
                    ? e
                    : t instanceof i.Element
                    ? t.matrixify()
                    : "string" == typeof t
                    ? f(t.split(i.regex.delimiter).map(parseFloat))
                    : 6 == arguments.length
                    ? f([].slice.call(arguments))
                    : Array.isArray(t)
                    ? f(t)
                    : t && "object" === r(t)
                    ? t
                    : e;
                for (var s = b.length - 1; s >= 0; --s) this[b[s]] = null != t[b[s]] ? t[b[s]] : e[b[s]];
              },
              extend: {
                extract: function () {
                  var t = g(this, 0, 1);
                  g(this, 1, 0);
                  var e = (180 / Math.PI) * Math.atan2(t.y, t.x) - 90;
                  return {
                    x: this.e,
                    y: this.f,
                    transformedX:
                      (this.e * Math.cos((e * Math.PI) / 180) + this.f * Math.sin((e * Math.PI) / 180)) /
                      Math.sqrt(this.a * this.a + this.b * this.b),
                    transformedY:
                      (this.f * Math.cos((e * Math.PI) / 180) + this.e * Math.sin((-e * Math.PI) / 180)) /
                      Math.sqrt(this.c * this.c + this.d * this.d),
                    rotation: e,
                    a: this.a,
                    b: this.b,
                    c: this.c,
                    d: this.d,
                    e: this.e,
                    f: this.f,
                    matrix: new i.Matrix(this),
                  };
                },
                clone: function () {
                  return new i.Matrix(this);
                },
                morph: function (t) {
                  return (this.destination = new i.Matrix(t)), this;
                },
                multiply: function (t) {
                  return new i.Matrix(
                    this.native().multiply(
                      (function (t) {
                        return t instanceof i.Matrix || (t = new i.Matrix(t)), t;
                      })(t).native()
                    )
                  );
                },
                inverse: function () {
                  return new i.Matrix(this.native().inverse());
                },
                translate: function (t, e) {
                  return new i.Matrix(this.native().translate(t || 0, e || 0));
                },
                native: function () {
                  for (var t = i.parser.native.createSVGMatrix(), e = b.length - 1; e >= 0; e--) t[b[e]] = this[b[e]];
                  return t;
                },
                toString: function () {
                  return (
                    "matrix(" +
                    x(this.a) +
                    "," +
                    x(this.b) +
                    "," +
                    x(this.c) +
                    "," +
                    x(this.d) +
                    "," +
                    x(this.e) +
                    "," +
                    x(this.f) +
                    ")"
                  );
                },
              },
              parent: i.Element,
              construct: {
                ctm: function () {
                  return new i.Matrix(this.node.getCTM());
                },
                screenCTM: function () {
                  if (this instanceof i.Nested) {
                    var t = this.rect(1, 1),
                      e = t.node.getScreenCTM();
                    return t.remove(), new i.Matrix(e);
                  }
                  return new i.Matrix(this.node.getScreenCTM());
                },
              },
            })),
            (i.Point = i.invent({
              create: function (t, e) {
                var i;
                (i = Array.isArray(t)
                  ? { x: t[0], y: t[1] }
                  : "object" === r(t)
                  ? { x: t.x, y: t.y }
                  : null != t
                  ? { x: t, y: null != e ? e : t }
                  : { x: 0, y: 0 }),
                  (this.x = i.x),
                  (this.y = i.y);
              },
              extend: {
                clone: function () {
                  return new i.Point(this);
                },
                morph: function (t, e) {
                  return (this.destination = new i.Point(t, e)), this;
                },
              },
            })),
            i.extend(i.Element, {
              point: function (t, e) {
                return new i.Point(t, e).transform(this.screenCTM().inverse());
              },
            }),
            i.extend(i.Element, {
              attr: function (t, e, s) {
                if (null == t) {
                  for (t = {}, s = (e = this.node.attributes).length - 1; s >= 0; s--)
                    t[e[s].nodeName] = i.regex.isNumber.test(e[s].nodeValue)
                      ? parseFloat(e[s].nodeValue)
                      : e[s].nodeValue;
                  return t;
                }
                if ("object" === r(t)) for (var a in t) this.attr(a, t[a]);
                else if (null === e) this.node.removeAttribute(t);
                else {
                  if (null == e)
                    return null == (e = this.node.getAttribute(t))
                      ? i.defaults.attrs[t]
                      : i.regex.isNumber.test(e)
                      ? parseFloat(e)
                      : e;
                  "stroke-width" == t
                    ? this.attr("stroke", parseFloat(e) > 0 ? this._stroke : null)
                    : "stroke" == t && (this._stroke = e),
                    ("fill" != t && "stroke" != t) ||
                      (i.regex.isImage.test(e) && (e = this.doc().defs().image(e, 0, 0)),
                      e instanceof i.Image &&
                        (e = this.doc()
                          .defs()
                          .pattern(0, 0, function () {
                            this.add(e);
                          }))),
                    "number" == typeof e
                      ? (e = new i.Number(e))
                      : i.Color.isColor(e)
                      ? (e = new i.Color(e))
                      : Array.isArray(e) && (e = new i.Array(e)),
                    "leading" == t
                      ? this.leading && this.leading(e)
                      : "string" == typeof s
                      ? this.node.setAttributeNS(s, t, e.toString())
                      : this.node.setAttribute(t, e.toString()),
                    !this.rebuild || ("font-size" != t && "x" != t) || this.rebuild(t, e);
                }
                return this;
              },
            }),
            i.extend(i.Element, {
              transform: function (t, e) {
                var s;
                return "object" !== r(t)
                  ? ((s = new i.Matrix(this).extract()), "string" == typeof t ? s[t] : s)
                  : ((s = new i.Matrix(this)),
                    (e = !!e || !!t.relative),
                    null != t.a && (s = e ? s.multiply(new i.Matrix(t)) : new i.Matrix(t)),
                    this.attr("transform", s));
              },
            }),
            i.extend(i.Element, {
              untransform: function () {
                return this.attr("transform", null);
              },
              matrixify: function () {
                return (this.attr("transform") || "")
                  .split(i.regex.transforms)
                  .slice(0, -1)
                  .map(function (t) {
                    var e = t.trim().split("(");
                    return [
                      e[0],
                      e[1].split(i.regex.delimiter).map(function (t) {
                        return parseFloat(t);
                      }),
                    ];
                  })
                  .reduce(function (t, e) {
                    return "matrix" == e[0] ? t.multiply(f(e[1])) : t[e[0]].apply(t, e[1]);
                  }, new i.Matrix());
              },
              toParent: function (t) {
                if (this == t) return this;
                var e = this.screenCTM(),
                  i = t.screenCTM().inverse();
                return this.addTo(t).untransform().transform(i.multiply(e)), this;
              },
              toDoc: function () {
                return this.toParent(this.doc());
              },
            }),
            (i.Transformation = i.invent({
              create: function (t, e) {
                if (arguments.length > 1 && "boolean" != typeof e)
                  return this.constructor.call(this, [].slice.call(arguments));
                if (Array.isArray(t))
                  for (var i = 0, s = this.arguments.length; i < s; ++i) this[this.arguments[i]] = t[i];
                else if (t && "object" === r(t))
                  for (i = 0, s = this.arguments.length; i < s; ++i) this[this.arguments[i]] = t[this.arguments[i]];
                (this.inversed = !1), !0 === e && (this.inversed = !0);
              },
            })),
            (i.Translate = i.invent({
              parent: i.Matrix,
              inherit: i.Transformation,
              create: function (t, e) {
                this.constructor.apply(this, [].slice.call(arguments));
              },
              extend: { arguments: ["transformedX", "transformedY"], method: "translate" },
            })),
            i.extend(i.Element, {
              style: function (t, e) {
                if (0 == arguments.length) return this.node.style.cssText || "";
                if (arguments.length < 2)
                  if ("object" === r(t)) for (var s in t) this.style(s, t[s]);
                  else {
                    if (!i.regex.isCss.test(t)) return this.node.style[h(t)];
                    for (
                      t = t
                        .split(/\s*;\s*/)
                        .filter(function (t) {
                          return !!t;
                        })
                        .map(function (t) {
                          return t.split(/\s*:\s*/);
                        });
                      (e = t.pop());

                    )
                      this.style(e[0], e[1]);
                  }
                else this.node.style[h(t)] = null === e || i.regex.isBlank.test(e) ? "" : e;
                return this;
              },
            }),
            (i.Parent = i.invent({
              create: function (t) {
                this.constructor.call(this, t);
              },
              inherit: i.Element,
              extend: {
                children: function () {
                  return i.utils.map(i.utils.filterSVGElements(this.node.childNodes), function (t) {
                    return i.adopt(t);
                  });
                },
                add: function (t, e) {
                  return (
                    null == e
                      ? this.node.appendChild(t.node)
                      : t.node != this.node.childNodes[e] && this.node.insertBefore(t.node, this.node.childNodes[e]),
                    this
                  );
                },
                put: function (t, e) {
                  return this.add(t, e), t;
                },
                has: function (t) {
                  return this.index(t) >= 0;
                },
                index: function (t) {
                  return [].slice.call(this.node.childNodes).indexOf(t.node);
                },
                get: function (t) {
                  return i.adopt(this.node.childNodes[t]);
                },
                first: function () {
                  return this.get(0);
                },
                last: function () {
                  return this.get(this.node.childNodes.length - 1);
                },
                each: function (t, e) {
                  for (var s = this.children(), a = 0, n = s.length; a < n; a++)
                    s[a] instanceof i.Element && t.apply(s[a], [a, s]),
                      e && s[a] instanceof i.Container && s[a].each(t, e);
                  return this;
                },
                removeElement: function (t) {
                  return this.node.removeChild(t.node), this;
                },
                clear: function () {
                  for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
                  return delete this._defs, this;
                },
                defs: function () {
                  return this.doc().defs();
                },
              },
            })),
            i.extend(i.Parent, {
              ungroup: function (t, e) {
                return (
                  0 === e ||
                    this instanceof i.Defs ||
                    this.node == i.parser.draw ||
                    ((t = t || (this instanceof i.Doc ? this : this.parent(i.Parent))),
                    (e = e || 1 / 0),
                    this.each(function () {
                      return this instanceof i.Defs
                        ? this
                        : this instanceof i.Parent
                        ? this.ungroup(t, e - 1)
                        : this.toParent(t);
                    }),
                    this.node.firstChild || this.remove()),
                  this
                );
              },
              flatten: function (t, e) {
                return this.ungroup(t, e);
              },
            }),
            (i.Container = i.invent({
              create: function (t) {
                this.constructor.call(this, t);
              },
              inherit: i.Parent,
            })),
            (i.ViewBox = i.invent({ parent: i.Container, construct: {} })),
            [
              "click",
              "dblclick",
              "mousedown",
              "mouseup",
              "mouseover",
              "mouseout",
              "mousemove",
              "touchstart",
              "touchmove",
              "touchleave",
              "touchend",
              "touchcancel",
            ].forEach(function (t) {
              i.Element.prototype[t] = function (e) {
                return i.on(this.node, t, e), this;
              };
            }),
            (i.listeners = []),
            (i.handlerMap = []),
            (i.listenerId = 0),
            (i.on = function (t, e, s, a, n) {
              var r = s.bind(a || t.instance || t),
                o = (i.handlerMap.indexOf(t) + 1 || i.handlerMap.push(t)) - 1,
                l = e.split(".")[0],
                c = e.split(".")[1] || "*";
              (i.listeners[o] = i.listeners[o] || {}),
                (i.listeners[o][l] = i.listeners[o][l] || {}),
                (i.listeners[o][l][c] = i.listeners[o][l][c] || {}),
                s._svgjsListenerId || (s._svgjsListenerId = ++i.listenerId),
                (i.listeners[o][l][c][s._svgjsListenerId] = r),
                t.addEventListener(l, r, n || { passive: !0 });
            }),
            (i.off = function (t, e, s) {
              var a = i.handlerMap.indexOf(t),
                n = e && e.split(".")[0],
                r = e && e.split(".")[1],
                o = "";
              if (-1 != a)
                if (s) {
                  if (("function" == typeof s && (s = s._svgjsListenerId), !s)) return;
                  i.listeners[a][n] &&
                    i.listeners[a][n][r || "*"] &&
                    (t.removeEventListener(n, i.listeners[a][n][r || "*"][s], !1),
                    delete i.listeners[a][n][r || "*"][s]);
                } else if (r && n) {
                  if (i.listeners[a][n] && i.listeners[a][n][r]) {
                    for (var l in i.listeners[a][n][r]) i.off(t, [n, r].join("."), l);
                    delete i.listeners[a][n][r];
                  }
                } else if (r)
                  for (var c in i.listeners[a]) for (var o in i.listeners[a][c]) r === o && i.off(t, [c, r].join("."));
                else if (n) {
                  if (i.listeners[a][n]) {
                    for (var o in i.listeners[a][n]) i.off(t, [n, o].join("."));
                    delete i.listeners[a][n];
                  }
                } else {
                  for (var c in i.listeners[a]) i.off(t, c);
                  delete i.listeners[a], delete i.handlerMap[a];
                }
            }),
            i.extend(i.Element, {
              on: function (t, e, s, a) {
                return i.on(this.node, t, e, s, a), this;
              },
              off: function (t, e) {
                return i.off(this.node, t, e), this;
              },
              fire: function (e, s) {
                return (
                  e instanceof t.Event
                    ? this.node.dispatchEvent(e)
                    : this.node.dispatchEvent((e = new i.CustomEvent(e, { detail: s, cancelable: !0 }))),
                  (this._event = e),
                  this
                );
              },
              event: function () {
                return this._event;
              },
            }),
            (i.Defs = i.invent({ create: "defs", inherit: i.Container })),
            (i.G = i.invent({
              create: "g",
              inherit: i.Container,
              extend: {
                x: function (t) {
                  return null == t ? this.transform("x") : this.transform({ x: t - this.x() }, !0);
                },
              },
              construct: {
                group: function () {
                  return this.put(new i.G());
                },
              },
            })),
            (i.Doc = i.invent({
              create: function (t) {
                t &&
                  ("svg" == (t = "string" == typeof t ? e.getElementById(t) : t).nodeName
                    ? this.constructor.call(this, t)
                    : (this.constructor.call(this, i.create("svg")),
                      t.appendChild(this.node),
                      this.size("100%", "100%")),
                  this.namespace().defs());
              },
              inherit: i.Container,
              extend: {
                namespace: function () {
                  return this.attr({ xmlns: i.ns, version: "1.1" })
                    .attr("xmlns:xlink", i.xlink, i.xmlns)
                    .attr("xmlns:svgjs", i.svgjs, i.xmlns);
                },
                defs: function () {
                  var t;
                  return (
                    this._defs ||
                      ((t = this.node.getElementsByTagName("defs")[0])
                        ? (this._defs = i.adopt(t))
                        : (this._defs = new i.Defs()),
                      this.node.appendChild(this._defs.node)),
                    this._defs
                  );
                },
                parent: function () {
                  return this.node.parentNode && "#document" != this.node.parentNode.nodeName
                    ? this.node.parentNode
                    : null;
                },
                remove: function () {
                  return this.parent() && this.parent().removeChild(this.node), this;
                },
                clear: function () {
                  for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
                  return (
                    delete this._defs,
                    i.parser.draw && !i.parser.draw.parentNode && this.node.appendChild(i.parser.draw),
                    this
                  );
                },
                clone: function (t) {
                  this.writeDataToDom();
                  var e = this.node,
                    i = m(e.cloneNode(!0));
                  return t ? (t.node || t).appendChild(i.node) : e.parentNode.insertBefore(i.node, e.nextSibling), i;
                },
              },
            })),
            i.extend(i.Element, {}),
            (i.Gradient = i.invent({
              create: function (t) {
                this.constructor.call(this, i.create(t + "Gradient")), (this.type = t);
              },
              inherit: i.Container,
              extend: {
                at: function (t, e, s) {
                  return this.put(new i.Stop()).update(t, e, s);
                },
                update: function (t) {
                  return this.clear(), "function" == typeof t && t.call(this, this), this;
                },
                fill: function () {
                  return "url(#" + this.id() + ")";
                },
                toString: function () {
                  return this.fill();
                },
                attr: function (t, e, s) {
                  return "transform" == t && (t = "gradientTransform"), i.Container.prototype.attr.call(this, t, e, s);
                },
              },
              construct: {
                gradient: function (t, e) {
                  return this.defs().gradient(t, e);
                },
              },
            })),
            i.extend(i.Gradient, i.FX, {
              from: function (t, e) {
                return "radial" == (this._target || this).type
                  ? this.attr({ fx: new i.Number(t), fy: new i.Number(e) })
                  : this.attr({ x1: new i.Number(t), y1: new i.Number(e) });
              },
              to: function (t, e) {
                return "radial" == (this._target || this).type
                  ? this.attr({ cx: new i.Number(t), cy: new i.Number(e) })
                  : this.attr({ x2: new i.Number(t), y2: new i.Number(e) });
              },
            }),
            i.extend(i.Defs, {
              gradient: function (t, e) {
                return this.put(new i.Gradient(t)).update(e);
              },
            }),
            (i.Stop = i.invent({
              create: "stop",
              inherit: i.Element,
              extend: {
                update: function (t) {
                  return (
                    ("number" == typeof t || t instanceof i.Number) &&
                      (t = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }),
                    null != t.opacity && this.attr("stop-opacity", t.opacity),
                    null != t.color && this.attr("stop-color", t.color),
                    null != t.offset && this.attr("offset", new i.Number(t.offset)),
                    this
                  );
                },
              },
            })),
            (i.Pattern = i.invent({
              create: "pattern",
              inherit: i.Container,
              extend: {
                fill: function () {
                  return "url(#" + this.id() + ")";
                },
                update: function (t) {
                  return this.clear(), "function" == typeof t && t.call(this, this), this;
                },
                toString: function () {
                  return this.fill();
                },
                attr: function (t, e, s) {
                  return "transform" == t && (t = "patternTransform"), i.Container.prototype.attr.call(this, t, e, s);
                },
              },
              construct: {
                pattern: function (t, e, i) {
                  return this.defs().pattern(t, e, i);
                },
              },
            })),
            i.extend(i.Defs, {
              pattern: function (t, e, s) {
                return this.put(new i.Pattern())
                  .update(s)
                  .attr({ x: 0, y: 0, width: t, height: e, patternUnits: "userSpaceOnUse" });
              },
            }),
            (i.Shape = i.invent({
              create: function (t) {
                this.constructor.call(this, t);
              },
              inherit: i.Element,
            })),
            (i.Symbol = i.invent({
              create: "symbol",
              inherit: i.Container,
              construct: {
                symbol: function () {
                  return this.put(new i.Symbol());
                },
              },
            })),
            (i.Use = i.invent({
              create: "use",
              inherit: i.Shape,
              extend: {
                element: function (t, e) {
                  return this.attr("href", (e || "") + "#" + t, i.xlink);
                },
              },
              construct: {
                use: function (t, e) {
                  return this.put(new i.Use()).element(t, e);
                },
              },
            })),
            (i.Rect = i.invent({
              create: "rect",
              inherit: i.Shape,
              construct: {
                rect: function (t, e) {
                  return this.put(new i.Rect()).size(t, e);
                },
              },
            })),
            (i.Circle = i.invent({
              create: "circle",
              inherit: i.Shape,
              construct: {
                circle: function (t) {
                  return this.put(new i.Circle()).rx(new i.Number(t).divide(2)).move(0, 0);
                },
              },
            })),
            i.extend(i.Circle, i.FX, {
              rx: function (t) {
                return this.attr("r", t);
              },
              ry: function (t) {
                return this.rx(t);
              },
            }),
            (i.Ellipse = i.invent({
              create: "ellipse",
              inherit: i.Shape,
              construct: {
                ellipse: function (t, e) {
                  return this.put(new i.Ellipse()).size(t, e).move(0, 0);
                },
              },
            })),
            i.extend(i.Ellipse, i.Rect, i.FX, {
              rx: function (t) {
                return this.attr("rx", t);
              },
              ry: function (t) {
                return this.attr("ry", t);
              },
            }),
            i.extend(i.Circle, i.Ellipse, {
              x: function (t) {
                return null == t ? this.cx() - this.rx() : this.cx(t + this.rx());
              },
              y: function (t) {
                return null == t ? this.cy() - this.ry() : this.cy(t + this.ry());
              },
              cx: function (t) {
                return null == t ? this.attr("cx") : this.attr("cx", t);
              },
              cy: function (t) {
                return null == t ? this.attr("cy") : this.attr("cy", t);
              },
              width: function (t) {
                return null == t ? 2 * this.rx() : this.rx(new i.Number(t).divide(2));
              },
              height: function (t) {
                return null == t ? 2 * this.ry() : this.ry(new i.Number(t).divide(2));
              },
              size: function (t, e) {
                var s = p(this, t, e);
                return this.rx(new i.Number(s.width).divide(2)).ry(new i.Number(s.height).divide(2));
              },
            }),
            (i.Line = i.invent({
              create: "line",
              inherit: i.Shape,
              extend: {
                array: function () {
                  return new i.PointArray([
                    [this.attr("x1"), this.attr("y1")],
                    [this.attr("x2"), this.attr("y2")],
                  ]);
                },
                plot: function (t, e, s, a) {
                  return null == t
                    ? this.array()
                    : ((t = void 0 !== e ? { x1: t, y1: e, x2: s, y2: a } : new i.PointArray(t).toLine()),
                      this.attr(t));
                },
                move: function (t, e) {
                  return this.attr(this.array().move(t, e).toLine());
                },
                size: function (t, e) {
                  var i = p(this, t, e);
                  return this.attr(this.array().size(i.width, i.height).toLine());
                },
              },
              construct: {
                line: function (t, e, s, a) {
                  return i.Line.prototype.plot.apply(this.put(new i.Line()), null != t ? [t, e, s, a] : [0, 0, 0, 0]);
                },
              },
            })),
            (i.Polyline = i.invent({
              create: "polyline",
              inherit: i.Shape,
              construct: {
                polyline: function (t) {
                  return this.put(new i.Polyline()).plot(t || new i.PointArray());
                },
              },
            })),
            (i.Polygon = i.invent({
              create: "polygon",
              inherit: i.Shape,
              construct: {
                polygon: function (t) {
                  return this.put(new i.Polygon()).plot(t || new i.PointArray());
                },
              },
            })),
            i.extend(i.Polyline, i.Polygon, {
              array: function () {
                return this._array || (this._array = new i.PointArray(this.attr("points")));
              },
              plot: function (t) {
                return null == t
                  ? this.array()
                  : this.clear().attr("points", "string" == typeof t ? t : (this._array = new i.PointArray(t)));
              },
              clear: function () {
                return delete this._array, this;
              },
              move: function (t, e) {
                return this.attr("points", this.array().move(t, e));
              },
              size: function (t, e) {
                var i = p(this, t, e);
                return this.attr("points", this.array().size(i.width, i.height));
              },
            }),
            i.extend(i.Line, i.Polyline, i.Polygon, {
              morphArray: i.PointArray,
              x: function (t) {
                return null == t ? this.bbox().x : this.move(t, this.bbox().y);
              },
              y: function (t) {
                return null == t ? this.bbox().y : this.move(this.bbox().x, t);
              },
              width: function (t) {
                var e = this.bbox();
                return null == t ? e.width : this.size(t, e.height);
              },
              height: function (t) {
                var e = this.bbox();
                return null == t ? e.height : this.size(e.width, t);
              },
            }),
            (i.Path = i.invent({
              create: "path",
              inherit: i.Shape,
              extend: {
                morphArray: i.PathArray,
                array: function () {
                  return this._array || (this._array = new i.PathArray(this.attr("d")));
                },
                plot: function (t) {
                  return null == t
                    ? this.array()
                    : this.clear().attr("d", "string" == typeof t ? t : (this._array = new i.PathArray(t)));
                },
                clear: function () {
                  return delete this._array, this;
                },
              },
              construct: {
                path: function (t) {
                  return this.put(new i.Path()).plot(t || new i.PathArray());
                },
              },
            })),
            (i.Image = i.invent({
              create: "image",
              inherit: i.Shape,
              extend: {
                load: function (e) {
                  if (!e) return this;
                  var s = this,
                    a = new t.Image();
                  return (
                    i.on(a, "load", function () {
                      i.off(a);
                      var t = s.parent(i.Pattern);
                      null !== t &&
                        (0 == s.width() && 0 == s.height() && s.size(a.width, a.height),
                        t && 0 == t.width() && 0 == t.height() && t.size(s.width(), s.height()),
                        "function" == typeof s._loaded &&
                          s._loaded.call(s, { width: a.width, height: a.height, ratio: a.width / a.height, url: e }));
                    }),
                    i.on(a, "error", function (t) {
                      i.off(a), "function" == typeof s._error && s._error.call(s, t);
                    }),
                    this.attr("href", (a.src = this.src = e), i.xlink)
                  );
                },
                loaded: function (t) {
                  return (this._loaded = t), this;
                },
                error: function (t) {
                  return (this._error = t), this;
                },
              },
              construct: {
                image: function (t, e, s) {
                  return this.put(new i.Image())
                    .load(t)
                    .size(e || 0, s || e || 0);
                },
              },
            })),
            (i.Text = i.invent({
              create: function () {
                this.constructor.call(this, i.create("text")),
                  (this.dom.leading = new i.Number(1.3)),
                  (this._rebuild = !0),
                  (this._build = !1),
                  this.attr("font-family", i.defaults.attrs["font-family"]);
              },
              inherit: i.Shape,
              extend: {
                x: function (t) {
                  return null == t ? this.attr("x") : this.attr("x", t);
                },
                text: function (t) {
                  if (void 0 === t) {
                    t = "";
                    for (var e = this.node.childNodes, s = 0, a = e.length; s < a; ++s)
                      0 != s && 3 != e[s].nodeType && 1 == i.adopt(e[s]).dom.newLined && (t += "\n"),
                        (t += e[s].textContent);
                    return t;
                  }
                  if ((this.clear().build(!0), "function" == typeof t)) t.call(this, this);
                  else {
                    s = 0;
                    for (var n = (t = t.split("\n")).length; s < n; s++) this.tspan(t[s]).newLine();
                  }
                  return this.build(!1).rebuild();
                },
                size: function (t) {
                  return this.attr("font-size", t).rebuild();
                },
                leading: function (t) {
                  return null == t ? this.dom.leading : ((this.dom.leading = new i.Number(t)), this.rebuild());
                },
                lines: function () {
                  var t = ((this.textPath && this.textPath()) || this).node,
                    e = i.utils.map(i.utils.filterSVGElements(t.childNodes), function (t) {
                      return i.adopt(t);
                    });
                  return new i.Set(e);
                },
                rebuild: function (t) {
                  if (("boolean" == typeof t && (this._rebuild = t), this._rebuild)) {
                    var e = this,
                      s = 0,
                      a = this.dom.leading * new i.Number(this.attr("font-size"));
                    this.lines().each(function () {
                      this.dom.newLined &&
                        (e.textPath() || this.attr("x", e.attr("x")),
                        "\n" == this.text() ? (s += a) : (this.attr("dy", a + s), (s = 0)));
                    }),
                      this.fire("rebuild");
                  }
                  return this;
                },
                build: function (t) {
                  return (this._build = !!t), this;
                },
                setData: function (t) {
                  return (this.dom = t), (this.dom.leading = new i.Number(t.leading || 1.3)), this;
                },
              },
              construct: {
                text: function (t) {
                  return this.put(new i.Text()).text(t);
                },
                plain: function (t) {
                  return this.put(new i.Text()).plain(t);
                },
              },
            })),
            (i.Tspan = i.invent({
              create: "tspan",
              inherit: i.Shape,
              extend: {
                text: function (t) {
                  return null == t
                    ? this.node.textContent + (this.dom.newLined ? "\n" : "")
                    : ("function" == typeof t ? t.call(this, this) : this.plain(t), this);
                },
                dx: function (t) {
                  return this.attr("dx", t);
                },
                dy: function (t) {
                  return this.attr("dy", t);
                },
                newLine: function () {
                  var t = this.parent(i.Text);
                  return (this.dom.newLined = !0), this.dy(t.dom.leading * t.attr("font-size")).attr("x", t.x());
                },
              },
            })),
            i.extend(i.Text, i.Tspan, {
              plain: function (t) {
                return !1 === this._build && this.clear(), this.node.appendChild(e.createTextNode(t)), this;
              },
              tspan: function (t) {
                var e = ((this.textPath && this.textPath()) || this).node,
                  s = new i.Tspan();
                return !1 === this._build && this.clear(), e.appendChild(s.node), s.text(t);
              },
              clear: function () {
                for (var t = ((this.textPath && this.textPath()) || this).node; t.hasChildNodes(); )
                  t.removeChild(t.lastChild);
                return this;
              },
              length: function () {
                return this.node.getComputedTextLength();
              },
            }),
            (i.TextPath = i.invent({
              create: "textPath",
              inherit: i.Parent,
              parent: i.Text,
              construct: {
                morphArray: i.PathArray,
                array: function () {
                  var t = this.track();
                  return t ? t.array() : null;
                },
                plot: function (t) {
                  var e = this.track(),
                    i = null;
                  return e && (i = e.plot(t)), null == t ? i : this;
                },
                track: function () {
                  var t = this.textPath();
                  if (t) return t.reference("href");
                },
                textPath: function () {
                  if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName)
                    return i.adopt(this.node.firstChild);
                },
              },
            })),
            (i.Nested = i.invent({
              create: function () {
                this.constructor.call(this, i.create("svg")), this.style("overflow", "visible");
              },
              inherit: i.Container,
              construct: {
                nested: function () {
                  return this.put(new i.Nested());
                },
              },
            }));
          var l = {
            stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
            fill: ["color", "opacity", "rule"],
            prefix: function (t, e) {
              return "color" == e ? t : t + "-" + e;
            },
          };
          function c(t, e, s, a) {
            return s + a.replace(i.regex.dots, " .");
          }
          function h(t) {
            return t.toLowerCase().replace(/-(.)/g, function (t, e) {
              return e.toUpperCase();
            });
          }
          function d(t) {
            return t.charAt(0).toUpperCase() + t.slice(1);
          }
          function u(t) {
            var e = t.toString(16);
            return 1 == e.length ? "0" + e : e;
          }
          function p(t, e, i) {
            if (null == e || null == i) {
              var s = t.bbox();
              null == e ? (e = (s.width / s.height) * i) : null == i && (i = (s.height / s.width) * e);
            }
            return { width: e, height: i };
          }
          function g(t, e, i) {
            return { x: e * t.a + i * t.c + 0, y: e * t.b + i * t.d + 0 };
          }
          function f(t) {
            return { a: t[0], b: t[1], c: t[2], d: t[3], e: t[4], f: t[5] };
          }
          function m(e) {
            for (var s = e.childNodes.length - 1; s >= 0; s--)
              e.childNodes[s] instanceof t.SVGElement && m(e.childNodes[s]);
            return i.adopt(e).id(i.eid(e.nodeName));
          }
          function v(t) {
            return (
              null == t.x && ((t.x = 0), (t.y = 0), (t.width = 0), (t.height = 0)),
              (t.w = t.width),
              (t.h = t.height),
              (t.x2 = t.x + t.width),
              (t.y2 = t.y + t.height),
              (t.cx = t.x + t.width / 2),
              (t.cy = t.y + t.height / 2),
              t
            );
          }
          function x(t) {
            return Math.abs(t) > 1e-37 ? t : 0;
          }
          ["fill", "stroke"].forEach(function (t) {
            var e = {};
            (e[t] = function (e) {
              if (void 0 === e) return this;
              if ("string" == typeof e || i.Color.isRgb(e) || (e && "function" == typeof e.fill)) this.attr(t, e);
              else
                for (var s = l[t].length - 1; s >= 0; s--)
                  null != e[l[t][s]] && this.attr(l.prefix(t, l[t][s]), e[l[t][s]]);
              return this;
            }),
              i.extend(i.Element, i.FX, e);
          }),
            i.extend(i.Element, i.FX, {
              translate: function (t, e) {
                return this.transform({ x: t, y: e });
              },
              matrix: function (t) {
                return this.attr("transform", new i.Matrix(6 == arguments.length ? [].slice.call(arguments) : t));
              },
              opacity: function (t) {
                return this.attr("opacity", t);
              },
              dx: function (t) {
                return this.x(new i.Number(t).plus(this instanceof i.FX ? 0 : this.x()), !0);
              },
              dy: function (t) {
                return this.y(new i.Number(t).plus(this instanceof i.FX ? 0 : this.y()), !0);
              },
            }),
            i.extend(i.Path, {
              length: function () {
                return this.node.getTotalLength();
              },
              pointAt: function (t) {
                return this.node.getPointAtLength(t);
              },
            }),
            (i.Set = i.invent({
              create: function (t) {
                Array.isArray(t) ? (this.members = t) : this.clear();
              },
              extend: {
                add: function () {
                  for (var t = [].slice.call(arguments), e = 0, i = t.length; e < i; e++) this.members.push(t[e]);
                  return this;
                },
                remove: function (t) {
                  var e = this.index(t);
                  return e > -1 && this.members.splice(e, 1), this;
                },
                each: function (t) {
                  for (var e = 0, i = this.members.length; e < i; e++) t.apply(this.members[e], [e, this.members]);
                  return this;
                },
                clear: function () {
                  return (this.members = []), this;
                },
                length: function () {
                  return this.members.length;
                },
                has: function (t) {
                  return this.index(t) >= 0;
                },
                index: function (t) {
                  return this.members.indexOf(t);
                },
                get: function (t) {
                  return this.members[t];
                },
                first: function () {
                  return this.get(0);
                },
                last: function () {
                  return this.get(this.members.length - 1);
                },
                valueOf: function () {
                  return this.members;
                },
              },
              construct: {
                set: function (t) {
                  return new i.Set(t);
                },
              },
            })),
            (i.FX.Set = i.invent({
              create: function (t) {
                this.set = t;
              },
            })),
            (i.Set.inherit = function () {
              var t = [];
              for (var e in i.Shape.prototype)
                "function" == typeof i.Shape.prototype[e] && "function" != typeof i.Set.prototype[e] && t.push(e);
              for (var e in (t.forEach(function (t) {
                i.Set.prototype[t] = function () {
                  for (var e = 0, s = this.members.length; e < s; e++)
                    this.members[e] &&
                      "function" == typeof this.members[e][t] &&
                      this.members[e][t].apply(this.members[e], arguments);
                  return "animate" == t ? this.fx || (this.fx = new i.FX.Set(this)) : this;
                };
              }),
              (t = []),
              i.FX.prototype))
                "function" == typeof i.FX.prototype[e] && "function" != typeof i.FX.Set.prototype[e] && t.push(e);
              t.forEach(function (t) {
                i.FX.Set.prototype[t] = function () {
                  for (var e = 0, i = this.set.members.length; e < i; e++)
                    this.set.members[e].fx[t].apply(this.set.members[e].fx, arguments);
                  return this;
                };
              });
            }),
            i.extend(i.Element, {}),
            i.extend(i.Element, {
              remember: function (t, e) {
                if ("object" === r(arguments[0])) for (var i in t) this.remember(i, t[i]);
                else {
                  if (1 == arguments.length) return this.memory()[t];
                  this.memory()[t] = e;
                }
                return this;
              },
              forget: function () {
                if (0 == arguments.length) this._memory = {};
                else for (var t = arguments.length - 1; t >= 0; t--) delete this.memory()[arguments[t]];
                return this;
              },
              memory: function () {
                return this._memory || (this._memory = {});
              },
            }),
            (i.get = function (t) {
              var s = e.getElementById(
                (function (t) {
                  var e = (t || "").toString().match(i.regex.reference);
                  if (e) return e[1];
                })(t) || t
              );
              return i.adopt(s);
            }),
            (i.select = function (t, s) {
              return new i.Set(
                i.utils.map((s || e).querySelectorAll(t), function (t) {
                  return i.adopt(t);
                })
              );
            }),
            i.extend(i.Parent, {
              select: function (t) {
                return i.select(t, this.node);
              },
            });
          var b = "abcdef".split("");
          if ("function" != typeof t.CustomEvent) {
            var y = function (t, i) {
              i = i || { bubbles: !1, cancelable: !1, detail: void 0 };
              var s = e.createEvent("CustomEvent");
              return s.initCustomEvent(t, i.bubbles, i.cancelable, i.detail), s;
            };
            (y.prototype = t.Event.prototype), (i.CustomEvent = y);
          } else i.CustomEvent = t.CustomEvent;
          return i;
        }),
        void 0 !==
          (s = function () {
            return Nt(zt, zt.document);
          }.call(e, i, e, t)) && (t.exports = s),
        function () {
          (SVG.Filter = SVG.invent({
            create: "filter",
            inherit: SVG.Parent,
            extend: {
              source: "SourceGraphic",
              sourceAlpha: "SourceAlpha",
              background: "BackgroundImage",
              backgroundAlpha: "BackgroundAlpha",
              fill: "FillPaint",
              stroke: "StrokePaint",
              autoSetIn: !0,
              put: function (t, e) {
                return (
                  this.add(t, e),
                  !t.attr("in") && this.autoSetIn && t.attr("in", this.source),
                  t.attr("result") || t.attr("result", t),
                  t
                );
              },
              blend: function (t, e, i) {
                return this.put(new SVG.BlendEffect(t, e, i));
              },
              colorMatrix: function (t, e) {
                return this.put(new SVG.ColorMatrixEffect(t, e));
              },
              convolveMatrix: function (t) {
                return this.put(new SVG.ConvolveMatrixEffect(t));
              },
              componentTransfer: function (t) {
                return this.put(new SVG.ComponentTransferEffect(t));
              },
              composite: function (t, e, i) {
                return this.put(new SVG.CompositeEffect(t, e, i));
              },
              flood: function (t, e) {
                return this.put(new SVG.FloodEffect(t, e));
              },
              offset: function (t, e) {
                return this.put(new SVG.OffsetEffect(t, e));
              },
              image: function (t) {
                return this.put(new SVG.ImageEffect(t));
              },
              merge: function () {
                var t = [void 0];
                for (var e in arguments) t.push(arguments[e]);
                return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t))());
              },
              gaussianBlur: function (t, e) {
                return this.put(new SVG.GaussianBlurEffect(t, e));
              },
              morphology: function (t, e) {
                return this.put(new SVG.MorphologyEffect(t, e));
              },
              diffuseLighting: function (t, e, i) {
                return this.put(new SVG.DiffuseLightingEffect(t, e, i));
              },
              displacementMap: function (t, e, i, s, a) {
                return this.put(new SVG.DisplacementMapEffect(t, e, i, s, a));
              },
              specularLighting: function (t, e, i, s) {
                return this.put(new SVG.SpecularLightingEffect(t, e, i, s));
              },
              tile: function () {
                return this.put(new SVG.TileEffect());
              },
              turbulence: function (t, e, i, s, a) {
                return this.put(new SVG.TurbulenceEffect(t, e, i, s, a));
              },
              toString: function () {
                return "url(#" + this.attr("id") + ")";
              },
            },
          })),
            SVG.extend(SVG.Defs, {
              filter: function (t) {
                var e = this.put(new SVG.Filter());
                return "function" == typeof t && t.call(e, e), e;
              },
            }),
            SVG.extend(SVG.Container, {
              filter: function (t) {
                return this.defs().filter(t);
              },
            }),
            SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
              filter: function (t) {
                return (
                  (this.filterer = t instanceof SVG.Element ? t : this.doc().filter(t)),
                  this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer),
                  this.attr("filter", this.filterer),
                  this.filterer
                );
              },
              unfilter: function (t) {
                return (
                  this.filterer && !0 === t && this.filterer.remove(), delete this.filterer, this.attr("filter", null)
                );
              },
            }),
            (SVG.Effect = SVG.invent({
              create: function () {
                this.constructor.call(this);
              },
              inherit: SVG.Element,
              extend: {
                in: function (t) {
                  return null == t
                    ? (this.parent() &&
                        this.parent()
                          .select('[result="' + this.attr("in") + '"]')
                          .get(0)) ||
                        this.attr("in")
                    : this.attr("in", t);
                },
                result: function (t) {
                  return null == t ? this.attr("result") : this.attr("result", t);
                },
                toString: function () {
                  return this.result();
                },
              },
            })),
            (SVG.ParentEffect = SVG.invent({
              create: function () {
                this.constructor.call(this);
              },
              inherit: SVG.Parent,
              extend: {
                in: function (t) {
                  return null == t
                    ? (this.parent() &&
                        this.parent()
                          .select('[result="' + this.attr("in") + '"]')
                          .get(0)) ||
                        this.attr("in")
                    : this.attr("in", t);
                },
                result: function (t) {
                  return null == t ? this.attr("result") : this.attr("result", t);
                },
                toString: function () {
                  return this.result();
                },
              },
            }));
          var t = {
            blend: function (t, e) {
              return this.parent() && this.parent().blend(this, t, e);
            },
            colorMatrix: function (t, e) {
              return this.parent() && this.parent().colorMatrix(t, e).in(this);
            },
            convolveMatrix: function (t) {
              return this.parent() && this.parent().convolveMatrix(t).in(this);
            },
            componentTransfer: function (t) {
              return this.parent() && this.parent().componentTransfer(t).in(this);
            },
            composite: function (t, e) {
              return this.parent() && this.parent().composite(this, t, e);
            },
            flood: function (t, e) {
              return this.parent() && this.parent().flood(t, e);
            },
            offset: function (t, e) {
              return this.parent() && this.parent().offset(t, e).in(this);
            },
            image: function (t) {
              return this.parent() && this.parent().image(t);
            },
            merge: function () {
              return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
            },
            gaussianBlur: function (t, e) {
              return this.parent() && this.parent().gaussianBlur(t, e).in(this);
            },
            morphology: function (t, e) {
              return this.parent() && this.parent().morphology(t, e).in(this);
            },
            diffuseLighting: function (t, e, i) {
              return this.parent() && this.parent().diffuseLighting(t, e, i).in(this);
            },
            displacementMap: function (t, e, i, s) {
              return this.parent() && this.parent().displacementMap(this, t, e, i, s);
            },
            specularLighting: function (t, e, i, s) {
              return this.parent() && this.parent().specularLighting(t, e, i, s).in(this);
            },
            tile: function () {
              return this.parent() && this.parent().tile().in(this);
            },
            turbulence: function (t, e, i, s, a) {
              return this.parent() && this.parent().turbulence(t, e, i, s, a).in(this);
            },
          };
          SVG.extend(SVG.Effect, t),
            SVG.extend(SVG.ParentEffect, t),
            (SVG.ChildEffect = SVG.invent({
              create: function () {
                this.constructor.call(this);
              },
              inherit: SVG.Element,
              extend: {
                in: function (t) {
                  this.attr("in", t);
                },
              },
            }));
          var e = {
              blend: function (t, e, i) {
                this.attr({ in: t, in2: e, mode: i || "normal" });
              },
              colorMatrix: function (t, e) {
                "matrix" == t && (e = a(e)), this.attr({ type: t, values: void 0 === e ? null : e });
              },
              convolveMatrix: function (t) {
                (t = a(t)), this.attr({ order: Math.sqrt(t.split(" ").length), kernelMatrix: t });
              },
              composite: function (t, e, i) {
                this.attr({ in: t, in2: e, operator: i });
              },
              flood: function (t, e) {
                this.attr("flood-color", t), null != e && this.attr("flood-opacity", e);
              },
              offset: function (t, e) {
                this.attr({ dx: t, dy: e });
              },
              image: function (t) {
                this.attr("href", t, SVG.xlink);
              },
              displacementMap: function (t, e, i, s, a) {
                this.attr({ in: t, in2: e, scale: i, xChannelSelector: s, yChannelSelector: a });
              },
              gaussianBlur: function (t, e) {
                null != t || null != e
                  ? this.attr("stdDeviation", n(Array.prototype.slice.call(arguments)))
                  : this.attr("stdDeviation", "0 0");
              },
              morphology: function (t, e) {
                this.attr({ operator: t, radius: e });
              },
              tile: function () {},
              turbulence: function (t, e, i, s, a) {
                this.attr({ numOctaves: e, seed: i, stitchTiles: s, baseFrequency: t, type: a });
              },
            },
            i = {
              merge: function () {
                var t;
                if (arguments[0] instanceof SVG.Set) {
                  var e = this;
                  arguments[0].each(function (t) {
                    this instanceof SVG.MergeNode
                      ? e.put(this)
                      : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) &&
                        e.put(new SVG.MergeNode(this));
                  });
                } else {
                  t = Array.isArray(arguments[0]) ? arguments[0] : arguments;
                  for (var i = 0; i < t.length; i++)
                    t[i] instanceof SVG.MergeNode ? this.put(t[i]) : this.put(new SVG.MergeNode(t[i]));
                }
              },
              componentTransfer: function (t) {
                if (
                  ((this.rgb = new SVG.Set()),
                  ["r", "g", "b", "a"].forEach(
                    function (t) {
                      (this[t] = new SVG["Func" + t.toUpperCase()]("identity")),
                        this.rgb.add(this[t]),
                        this.node.appendChild(this[t].node);
                    }.bind(this)
                  ),
                  t)
                )
                  for (var e in (t.rgb &&
                    (["r", "g", "b"].forEach(
                      function (e) {
                        this[e].attr(t.rgb);
                      }.bind(this)
                    ),
                    delete t.rgb),
                  t))
                    this[e].attr(t[e]);
              },
              diffuseLighting: function (t, e, i) {
                this.attr({ surfaceScale: t, diffuseConstant: e, kernelUnitLength: i });
              },
              specularLighting: function (t, e, i, s) {
                this.attr({ surfaceScale: t, diffuseConstant: e, specularExponent: i, kernelUnitLength: s });
              },
            },
            s = {
              distantLight: function (t, e) {
                this.attr({ azimuth: t, elevation: e });
              },
              pointLight: function (t, e, i) {
                this.attr({ x: t, y: e, z: i });
              },
              spotLight: function (t, e, i, s, a, n) {
                this.attr({ x: t, y: e, z: i, pointsAtX: s, pointsAtY: a, pointsAtZ: n });
              },
              mergeNode: function (t) {
                this.attr("in", t);
              },
            };
          function a(t) {
            return (
              Array.isArray(t) && (t = new SVG.Array(t)),
              t.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")
            );
          }
          function n(t) {
            if (!Array.isArray(t)) return t;
            for (var e = 0, i = t.length, s = []; e < i; e++) s.push(t[e]);
            return s.join(" ");
          }
          function r() {
            var t = function () {};
            for (var e in ("function" == typeof arguments[arguments.length - 1] &&
              ((t = arguments[arguments.length - 1]), Array.prototype.splice.call(arguments, arguments.length - 1, 1)),
            arguments))
              for (var i in arguments[e]) t(arguments[e][i], i, arguments[e]);
          }
          ["r", "g", "b", "a"].forEach(function (t) {
            s["Func" + t.toUpperCase()] = function (t) {
              switch ((this.attr("type", t), t)) {
                case "table":
                  this.attr("tableValues", arguments[1]);
                  break;
                case "linear":
                  this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
                  break;
                case "gamma":
                  this.attr("amplitude", arguments[1]),
                    this.attr("exponent", arguments[2]),
                    this.attr("offset", arguments[2]);
              }
            };
          }),
            r(e, function (t, e) {
              var i = e.charAt(0).toUpperCase() + e.slice(1);
              SVG[i + "Effect"] = SVG.invent({
                create: function () {
                  this.constructor.call(this, SVG.create("fe" + i)),
                    t.apply(this, arguments),
                    this.result(this.attr("id") + "Out");
                },
                inherit: SVG.Effect,
                extend: {},
              });
            }),
            r(i, function (t, e) {
              var i = e.charAt(0).toUpperCase() + e.slice(1);
              SVG[i + "Effect"] = SVG.invent({
                create: function () {
                  this.constructor.call(this, SVG.create("fe" + i)),
                    t.apply(this, arguments),
                    this.result(this.attr("id") + "Out");
                },
                inherit: SVG.ParentEffect,
                extend: {},
              });
            }),
            r(s, function (t, e) {
              var i = e.charAt(0).toUpperCase() + e.slice(1);
              SVG[i] = SVG.invent({
                create: function () {
                  this.constructor.call(this, SVG.create("fe" + i)), t.apply(this, arguments);
                },
                inherit: SVG.ChildEffect,
                extend: {},
              });
            }),
            SVG.extend(SVG.MergeEffect, {
              in: function (t) {
                return t instanceof SVG.MergeNode ? this.add(t, 0) : this.add(new SVG.MergeNode(t), 0), this;
              },
            }),
            SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
              in2: function (t) {
                return null == t
                  ? (this.parent() &&
                      this.parent()
                        .select('[result="' + this.attr("in2") + '"]')
                        .get(0)) ||
                      this.attr("in2")
                  : this.attr("in2", t);
              },
            }),
            (SVG.filter = {
              sepiatone: [
                0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0,
              ],
            });
        }.call(void 0),
        (function () {
          function t(t, a, n, r, o, l, c) {
            for (
              var h = t.slice(a, n || c),
                d = r.slice(o, l || c),
                u = 0,
                p = { pos: [0, 0], start: [0, 0] },
                g = { pos: [0, 0], start: [0, 0] };
              (h[u] = e.call(p, h[u])),
                (d[u] = e.call(g, d[u])),
                h[u][0] != d[u][0] || "M" == h[u][0] || ("A" == h[u][0] && (h[u][4] != d[u][4] || h[u][5] != d[u][5]))
                  ? (Array.prototype.splice.apply(h, [u, 1].concat(s.call(p, h[u]))),
                    Array.prototype.splice.apply(d, [u, 1].concat(s.call(g, d[u]))))
                  : ((h[u] = i.call(p, h[u])), (d[u] = i.call(g, d[u]))),
                ++u != h.length || u != d.length;

            )
              u == h.length && h.push(["C", p.pos[0], p.pos[1], p.pos[0], p.pos[1], p.pos[0], p.pos[1]]),
                u == d.length && d.push(["C", g.pos[0], g.pos[1], g.pos[0], g.pos[1], g.pos[0], g.pos[1]]);
            return { start: h, dest: d };
          }
          function e(t) {
            switch (t[0]) {
              case "z":
              case "Z":
                (t[0] = "L"), (t[1] = this.start[0]), (t[2] = this.start[1]);
                break;
              case "H":
                (t[0] = "L"), (t[2] = this.pos[1]);
                break;
              case "V":
                (t[0] = "L"), (t[2] = t[1]), (t[1] = this.pos[0]);
                break;
              case "T":
                (t[0] = "Q"), (t[3] = t[1]), (t[4] = t[2]), (t[1] = this.reflection[1]), (t[2] = this.reflection[0]);
                break;
              case "S":
                (t[0] = "C"),
                  (t[6] = t[4]),
                  (t[5] = t[3]),
                  (t[4] = t[2]),
                  (t[3] = t[1]),
                  (t[2] = this.reflection[1]),
                  (t[1] = this.reflection[0]);
            }
            return t;
          }
          function i(t) {
            var e = t.length;
            return (
              (this.pos = [t[e - 2], t[e - 1]]),
              -1 != "SCQT".indexOf(t[0]) &&
                (this.reflection = [2 * this.pos[0] - t[e - 4], 2 * this.pos[1] - t[e - 3]]),
              t
            );
          }
          function s(t) {
            var e = [t];
            switch (t[0]) {
              case "M":
                return (this.pos = this.start = [t[1], t[2]]), e;
              case "L":
                (t[5] = t[3] = t[1]), (t[6] = t[4] = t[2]), (t[1] = this.pos[0]), (t[2] = this.pos[1]);
                break;
              case "Q":
                (t[6] = t[4]),
                  (t[5] = t[3]),
                  (t[4] = (1 * t[4]) / 3 + (2 * t[2]) / 3),
                  (t[3] = (1 * t[3]) / 3 + (2 * t[1]) / 3),
                  (t[2] = (1 * this.pos[1]) / 3 + (2 * t[2]) / 3),
                  (t[1] = (1 * this.pos[0]) / 3 + (2 * t[1]) / 3);
                break;
              case "A":
                (e = (function (t, e) {
                  var i,
                    s,
                    a,
                    n,
                    r,
                    o,
                    l,
                    c,
                    h,
                    d,
                    u,
                    p,
                    g,
                    f,
                    m,
                    v,
                    x,
                    b,
                    y,
                    w,
                    k,
                    S,
                    C,
                    A,
                    E,
                    T,
                    L = Math.abs(e[1]),
                    P = Math.abs(e[2]),
                    M = e[3] % 360,
                    O = e[4],
                    I = e[5],
                    F = e[6],
                    D = e[7],
                    z = new SVG.Point(t),
                    N = new SVG.Point(F, D),
                    R = [];
                  if (0 === L || 0 === P || (z.x === N.x && z.y === N.y)) return [["C", z.x, z.y, N.x, N.y, N.x, N.y]];
                  for (
                    (s =
                      ((i = new SVG.Point((z.x - N.x) / 2, (z.y - N.y) / 2).transform(new SVG.Matrix().rotate(M))).x *
                        i.x) /
                        (L * L) +
                      (i.y * i.y) / (P * P)) > 1 && ((L *= s = Math.sqrt(s)), (P *= s)),
                      a = new SVG.Matrix()
                        .rotate(M)
                        .scale(1 / L, 1 / P)
                        .rotate(-M),
                      z = z.transform(a),
                      o = (n = [(N = N.transform(a)).x - z.x, N.y - z.y])[0] * n[0] + n[1] * n[1],
                      r = Math.sqrt(o),
                      n[0] /= r,
                      n[1] /= r,
                      l = o < 4 ? Math.sqrt(1 - o / 4) : 0,
                      O === I && (l *= -1),
                      c = new SVG.Point((N.x + z.x) / 2 + l * -n[1], (N.y + z.y) / 2 + l * n[0]),
                      h = new SVG.Point(z.x - c.x, z.y - c.y),
                      d = new SVG.Point(N.x - c.x, N.y - c.y),
                      u = Math.acos(h.x / Math.sqrt(h.x * h.x + h.y * h.y)),
                      h.y < 0 && (u *= -1),
                      p = Math.acos(d.x / Math.sqrt(d.x * d.x + d.y * d.y)),
                      d.y < 0 && (p *= -1),
                      I && u > p && (p += 2 * Math.PI),
                      !I && u < p && (p -= 2 * Math.PI),
                      v = [],
                      x = u,
                      g = (p - u) / (f = Math.ceil((2 * Math.abs(u - p)) / Math.PI)),
                      m = (4 * Math.tan(g / 4)) / 3,
                      k = 0;
                    k <= f;
                    k++
                  )
                    (y = Math.cos(x)),
                      (b = Math.sin(x)),
                      (w = new SVG.Point(c.x + y, c.y + b)),
                      (v[k] = [new SVG.Point(w.x + m * b, w.y - m * y), w, new SVG.Point(w.x - m * b, w.y + m * y)]),
                      (x += g);
                  for (
                    v[0][0] = v[0][1].clone(),
                      v[v.length - 1][2] = v[v.length - 1][1].clone(),
                      a = new SVG.Matrix().rotate(M).scale(L, P).rotate(-M),
                      k = 0,
                      S = v.length;
                    k < S;
                    k++
                  )
                    (v[k][0] = v[k][0].transform(a)),
                      (v[k][1] = v[k][1].transform(a)),
                      (v[k][2] = v[k][2].transform(a));
                  for (k = 1, S = v.length; k < S; k++)
                    (C = (w = v[k - 1][2]).x),
                      (A = w.y),
                      (E = (w = v[k][0]).x),
                      (T = w.y),
                      (F = (w = v[k][1]).x),
                      (D = w.y),
                      R.push(["C", C, A, E, T, F, D]);
                  return R;
                })(this.pos, t)),
                  (t = e[0]);
            }
            return (t[0] = "C"), (this.pos = [t[5], t[6]]), (this.reflection = [2 * t[5] - t[3], 2 * t[6] - t[4]]), e;
          }
          function a(t, e) {
            if (!1 === e) return !1;
            for (var i = e, s = t.length; i < s; ++i) if ("M" == t[i][0]) return i;
            return !1;
          }
          SVG.extend(SVG.PathArray, {
            morph: function (e) {
              for (var i = this.value, s = this.parse(e), n = 0, r = 0, o = !1, l = !1; !1 !== n || !1 !== r; ) {
                var c;
                (o = a(i, !1 !== n && n + 1)),
                  (l = a(s, !1 !== r && r + 1)),
                  !1 === n &&
                    (n =
                      0 == (c = new SVG.PathArray(h.start).bbox()).height || 0 == c.width
                        ? i.push(i[0]) - 1
                        : i.push(["M", c.x + c.width / 2, c.y + c.height / 2]) - 1),
                  !1 === r &&
                    (r =
                      0 == (c = new SVG.PathArray(h.dest).bbox()).height || 0 == c.width
                        ? s.push(s[0]) - 1
                        : s.push(["M", c.x + c.width / 2, c.y + c.height / 2]) - 1);
                var h = t(i, n, o, s, r, l);
                (i = i.slice(0, n).concat(h.start, !1 === o ? [] : i.slice(o))),
                  (s = s.slice(0, r).concat(h.dest, !1 === l ? [] : s.slice(l))),
                  (n = !1 !== o && n + h.start.length),
                  (r = !1 !== l && r + h.dest.length);
              }
              return (this.value = i), (this.destination = new SVG.PathArray()), (this.destination.value = s), this;
            },
          });
        })(),
        function () {
          function t(t) {
            t.remember("_draggable", this), (this.el = t);
          }
          (t.prototype.init = function (t, e) {
            var i = this;
            (this.constraint = t),
              (this.value = e),
              this.el.on("mousedown.drag", function (t) {
                i.start(t);
              }),
              this.el.on("touchstart.drag", function (t) {
                i.start(t);
              });
          }),
            (t.prototype.transformPoint = function (t, e) {
              var i = ((t = t || window.event).changedTouches && t.changedTouches[0]) || t;
              return (this.p.x = i.clientX - (e || 0)), (this.p.y = i.clientY), this.p.matrixTransform(this.m);
            }),
            (t.prototype.getBBox = function () {
              var t = this.el.bbox();
              return (
                this.el instanceof SVG.Nested && (t = this.el.rbox()),
                (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) &&
                  ((t.x = this.el.x()), (t.y = this.el.y())),
                t
              );
            }),
            (t.prototype.start = function (t) {
              if (
                ("click" != t.type && "mousedown" != t.type && "mousemove" != t.type) ||
                1 == (t.which || t.buttons)
              ) {
                var e = this;
                if ((this.el.fire("beforedrag", { event: t, handler: this }), !this.el.event().defaultPrevented)) {
                  t.preventDefault(),
                    t.stopPropagation(),
                    (this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc)),
                    (this.p = this.parent.node.createSVGPoint()),
                    (this.m = this.el.node.getScreenCTM().inverse());
                  var i,
                    s = this.getBBox();
                  if (this.el instanceof SVG.Text)
                    switch (((i = this.el.node.getComputedTextLength()), this.el.attr("text-anchor"))) {
                      case "middle":
                        i /= 2;
                        break;
                      case "start":
                        i = 0;
                    }
                  (this.startPoints = { point: this.transformPoint(t, i), box: s, transform: this.el.transform() }),
                    SVG.on(window, "mousemove.drag", function (t) {
                      e.drag(t);
                    }),
                    SVG.on(window, "touchmove.drag", function (t) {
                      e.drag(t);
                    }),
                    SVG.on(window, "mouseup.drag", function (t) {
                      e.end(t);
                    }),
                    SVG.on(window, "touchend.drag", function (t) {
                      e.end(t);
                    }),
                    this.el.fire("dragstart", { event: t, p: this.startPoints.point, m: this.m, handler: this });
                }
              }
            }),
            (t.prototype.drag = function (t) {
              var e = this.getBBox(),
                i = this.transformPoint(t),
                s = this.startPoints.box.x + i.x - this.startPoints.point.x,
                a = this.startPoints.box.y + i.y - this.startPoints.point.y,
                n = this.constraint,
                r = i.x - this.startPoints.point.x,
                o = i.y - this.startPoints.point.y;
              if (
                (this.el.fire("dragmove", { event: t, p: i, m: this.m, handler: this }),
                this.el.event().defaultPrevented)
              )
                return i;
              if ("function" == typeof n) {
                var l = n.call(this.el, s, a, this.m);
                "boolean" == typeof l && (l = { x: l, y: l }),
                  !0 === l.x ? this.el.x(s) : !1 !== l.x && this.el.x(l.x),
                  !0 === l.y ? this.el.y(a) : !1 !== l.y && this.el.y(l.y);
              } else
                "object" == typeof n &&
                  (null != n.minX && s < n.minX
                    ? (r = (s = n.minX) - this.startPoints.box.x)
                    : null != n.maxX && s > n.maxX - e.width && (r = (s = n.maxX - e.width) - this.startPoints.box.x),
                  null != n.minY && a < n.minY
                    ? (o = (a = n.minY) - this.startPoints.box.y)
                    : null != n.maxY && a > n.maxY - e.height && (o = (a = n.maxY - e.height) - this.startPoints.box.y),
                  null != n.snapToGrid &&
                    ((s -= s % n.snapToGrid),
                    (a -= a % n.snapToGrid),
                    (r -= r % n.snapToGrid),
                    (o -= o % n.snapToGrid)),
                  this.el instanceof SVG.G
                    ? this.el.matrix(this.startPoints.transform).transform({ x: r, y: o }, !0)
                    : this.el.move(s, a));
              return i;
            }),
            (t.prototype.end = function (t) {
              var e = this.drag(t);
              this.el.fire("dragend", { event: t, p: e, m: this.m, handler: this }),
                SVG.off(window, "mousemove.drag"),
                SVG.off(window, "touchmove.drag"),
                SVG.off(window, "mouseup.drag"),
                SVG.off(window, "touchend.drag");
            }),
            SVG.extend(SVG.Element, {
              draggable: function (e, i) {
                ("function" != typeof e && "object" != typeof e) || ((i = e), (e = !0));
                var s = this.remember("_draggable") || new t(this);
                return (
                  (e = void 0 === e || e)
                    ? s.init(i || {}, e)
                    : (this.off("mousedown.drag"), this.off("touchstart.drag")),
                  this
                );
              },
            });
        }.call(void 0),
        (function () {
          function t(t) {
            (this.el = t),
              t.remember("_selectHandler", this),
              (this.pointSelection = { isSelected: !1 }),
              (this.rectSelection = { isSelected: !1 }),
              (this.pointsList = {
                lt: [0, 0],
                rt: ["width", 0],
                rb: ["width", "height"],
                lb: [0, "height"],
                t: ["width", 0],
                r: ["width", "height"],
                b: ["width", "height"],
                l: [0, "height"],
              }),
              (this.pointCoord = function (t, e, i) {
                var s = "string" != typeof t ? t : e[t];
                return i ? s / 2 : s;
              }),
              (this.pointCoords = function (t, e) {
                var i = this.pointsList[t];
                return {
                  x: this.pointCoord(i[0], e, "t" === t || "b" === t),
                  y: this.pointCoord(i[1], e, "r" === t || "l" === t),
                };
              });
          }
          (t.prototype.init = function (t, e) {
            var i = this.el.bbox();
            this.options = {};
            var s = this.el.selectize.defaults.points;
            for (var a in this.el.selectize.defaults)
              (this.options[a] = this.el.selectize.defaults[a]), void 0 !== e[a] && (this.options[a] = e[a]);
            var n = ["points", "pointsExclude"];
            for (var a in n) {
              var r = this.options[n[a]];
              "string" == typeof r
                ? (r = r.length > 0 ? r.split(/\s*,\s*/i) : [])
                : "boolean" == typeof r && "points" === n[a] && (r = r ? s : []),
                (this.options[n[a]] = r);
            }
            (this.options.points = [s, this.options.points].reduce(function (t, e) {
              return t.filter(function (t) {
                return e.indexOf(t) > -1;
              });
            })),
              (this.options.points = [this.options.points, this.options.pointsExclude].reduce(function (t, e) {
                return t.filter(function (t) {
                  return e.indexOf(t) < 0;
                });
              })),
              (this.parent = this.el.parent()),
              (this.nested = this.nested || this.parent.group()),
              this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)),
              this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type)
                ? this.selectPoints(t)
                : this.selectRect(t),
              this.observe(),
              this.cleanup();
          }),
            (t.prototype.selectPoints = function (t) {
              return (
                (this.pointSelection.isSelected = t),
                this.pointSelection.set || ((this.pointSelection.set = this.parent.set()), this.drawPoints()),
                this
              );
            }),
            (t.prototype.getPointArray = function () {
              var t = this.el.bbox();
              return this.el
                .array()
                .valueOf()
                .map(function (e) {
                  return [e[0] - t.x, e[1] - t.y];
                });
            }),
            (t.prototype.drawPoints = function () {
              for (var t = this, e = this.getPointArray(), i = 0, s = e.length; i < s; ++i) {
                var a = (function (e) {
                    return function (i) {
                      (i = i || window.event).preventDefault ? i.preventDefault() : (i.returnValue = !1),
                        i.stopPropagation();
                      var s = i.pageX || i.touches[0].pageX,
                        a = i.pageY || i.touches[0].pageY;
                      t.el.fire("point", { x: s, y: a, i: e, event: i });
                    };
                  })(i),
                  n = this.drawPoint(e[i][0], e[i][1])
                    .addClass(this.options.classPoints)
                    .addClass(this.options.classPoints + "_point")
                    .on("touchstart", a)
                    .on("mousedown", a);
                this.pointSelection.set.add(n);
              }
            }),
            (t.prototype.drawPoint = function (t, e) {
              var i = this.options.pointType;
              switch (i) {
                case "circle":
                  return this.drawCircle(t, e);
                case "rect":
                  return this.drawRect(t, e);
                default:
                  if ("function" == typeof i) return i.call(this, t, e);
                  throw new Error("Unknown " + i + " point type!");
              }
            }),
            (t.prototype.drawCircle = function (t, e) {
              return this.nested.circle(this.options.pointSize).center(t, e);
            }),
            (t.prototype.drawRect = function (t, e) {
              return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t, e);
            }),
            (t.prototype.updatePointSelection = function () {
              var t = this.getPointArray();
              this.pointSelection.set.each(function (e) {
                (this.cx() === t[e][0] && this.cy() === t[e][1]) || this.center(t[e][0], t[e][1]);
              });
            }),
            (t.prototype.updateRectSelection = function () {
              var t = this,
                e = this.el.bbox();
              if (
                (this.rectSelection.set.get(0).attr({ width: e.width, height: e.height }),
                this.options.points.length &&
                  this.options.points.map(function (i, s) {
                    var a = t.pointCoords(i, e);
                    t.rectSelection.set.get(s + 1).center(a.x, a.y);
                  }),
                this.options.rotationPoint)
              ) {
                var i = this.rectSelection.set.length();
                this.rectSelection.set.get(i - 1).center(e.width / 2, 20);
              }
            }),
            (t.prototype.selectRect = function (t) {
              var e = this,
                i = this.el.bbox();
              function s(t) {
                return function (i) {
                  (i = i || window.event).preventDefault ? i.preventDefault() : (i.returnValue = !1),
                    i.stopPropagation();
                  var s = i.pageX || i.touches[0].pageX,
                    a = i.pageY || i.touches[0].pageY;
                  e.el.fire(t, { x: s, y: a, event: i });
                };
              }
              if (
                ((this.rectSelection.isSelected = t),
                (this.rectSelection.set = this.rectSelection.set || this.parent.set()),
                this.rectSelection.set.get(0) ||
                  this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)),
                this.options.points.length &&
                  this.rectSelection.set.length() < 2 &&
                  (this.options.points.map(function (t, a) {
                    var n = e.pointCoords(t, i),
                      r = e
                        .drawPoint(n.x, n.y)
                        .attr("class", e.options.classPoints + "_" + t)
                        .on("mousedown", s(t))
                        .on("touchstart", s(t));
                    e.rectSelection.set.add(r);
                  }),
                  this.rectSelection.set.each(function () {
                    this.addClass(e.options.classPoints);
                  })),
                this.options.rotationPoint &&
                  ((this.options.points && !this.rectSelection.set.get(9)) ||
                    (!this.options.points && !this.rectSelection.set.get(1))))
              ) {
                var a = function (t) {
                    (t = t || window.event).preventDefault ? t.preventDefault() : (t.returnValue = !1),
                      t.stopPropagation();
                    var i = t.pageX || t.touches[0].pageX,
                      s = t.pageY || t.touches[0].pageY;
                    e.el.fire("rot", { x: i, y: s, event: t });
                  },
                  n = this.drawPoint(i.width / 2, 20)
                    .attr("class", this.options.classPoints + "_rot")
                    .on("touchstart", a)
                    .on("mousedown", a);
                this.rectSelection.set.add(n);
              }
            }),
            (t.prototype.handler = function () {
              var t = this.el.bbox();
              this.nested.matrix(new SVG.Matrix(this.el).translate(t.x, t.y)),
                this.rectSelection.isSelected && this.updateRectSelection(),
                this.pointSelection.isSelected && this.updatePointSelection();
            }),
            (t.prototype.observe = function () {
              var t = this;
              if (MutationObserver)
                if (this.rectSelection.isSelected || this.pointSelection.isSelected)
                  (this.observerInst =
                    this.observerInst ||
                    new MutationObserver(function () {
                      t.handler();
                    })),
                    this.observerInst.observe(this.el.node, { attributes: !0 });
                else
                  try {
                    this.observerInst.disconnect(), delete this.observerInst;
                  } catch (t) {}
              else
                this.el.off("DOMAttrModified.select"),
                  (this.rectSelection.isSelected || this.pointSelection.isSelected) &&
                    this.el.on("DOMAttrModified.select", function () {
                      t.handler();
                    });
            }),
            (t.prototype.cleanup = function () {
              !this.rectSelection.isSelected &&
                this.rectSelection.set &&
                (this.rectSelection.set.each(function () {
                  this.remove();
                }),
                this.rectSelection.set.clear(),
                delete this.rectSelection.set),
                !this.pointSelection.isSelected &&
                  this.pointSelection.set &&
                  (this.pointSelection.set.each(function () {
                    this.remove();
                  }),
                  this.pointSelection.set.clear(),
                  delete this.pointSelection.set),
                this.pointSelection.isSelected ||
                  this.rectSelection.isSelected ||
                  (this.nested.remove(), delete this.nested);
            }),
            SVG.extend(SVG.Element, {
              selectize: function (e, i) {
                return (
                  "object" == typeof e && ((i = e), (e = !0)),
                  (this.remember("_selectHandler") || new t(this)).init(void 0 === e || e, i || {}),
                  this
                );
              },
            }),
            (SVG.Element.prototype.selectize.defaults = {
              points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"],
              pointsExclude: [],
              classRect: "svg_select_boundingRect",
              classPoints: "svg_select_points",
              pointSize: 7,
              rotationPoint: !0,
              deepSelect: !1,
              pointType: "circle",
            });
        })(),
        (function () {
          (function () {
            function t(t) {
              t.remember("_resizeHandler", this),
                (this.el = t),
                (this.parameters = {}),
                (this.lastUpdateCall = null),
                (this.p = t.doc().node.createSVGPoint());
            }
            (t.prototype.transformPoint = function (t, e, i) {
              return (
                (this.p.x = t - (this.offset.x - window.pageXOffset)),
                (this.p.y = e - (this.offset.y - window.pageYOffset)),
                this.p.matrixTransform(i || this.m)
              );
            }),
              (t.prototype._extractPosition = function (t) {
                return {
                  x: null != t.clientX ? t.clientX : t.touches[0].clientX,
                  y: null != t.clientY ? t.clientY : t.touches[0].clientY,
                };
              }),
              (t.prototype.init = function (t) {
                var e = this;
                if ((this.stop(), "stop" !== t)) {
                  for (var i in ((this.options = {}), this.el.resize.defaults))
                    (this.options[i] = this.el.resize.defaults[i]), void 0 !== t[i] && (this.options[i] = t[i]);
                  this.el.on("lt.resize", function (t) {
                    e.resize(t || window.event);
                  }),
                    this.el.on("rt.resize", function (t) {
                      e.resize(t || window.event);
                    }),
                    this.el.on("rb.resize", function (t) {
                      e.resize(t || window.event);
                    }),
                    this.el.on("lb.resize", function (t) {
                      e.resize(t || window.event);
                    }),
                    this.el.on("t.resize", function (t) {
                      e.resize(t || window.event);
                    }),
                    this.el.on("r.resize", function (t) {
                      e.resize(t || window.event);
                    }),
                    this.el.on("b.resize", function (t) {
                      e.resize(t || window.event);
                    }),
                    this.el.on("l.resize", function (t) {
                      e.resize(t || window.event);
                    }),
                    this.el.on("rot.resize", function (t) {
                      e.resize(t || window.event);
                    }),
                    this.el.on("point.resize", function (t) {
                      e.resize(t || window.event);
                    }),
                    this.update();
                }
              }),
              (t.prototype.stop = function () {
                return (
                  this.el.off("lt.resize"),
                  this.el.off("rt.resize"),
                  this.el.off("rb.resize"),
                  this.el.off("lb.resize"),
                  this.el.off("t.resize"),
                  this.el.off("r.resize"),
                  this.el.off("b.resize"),
                  this.el.off("l.resize"),
                  this.el.off("rot.resize"),
                  this.el.off("point.resize"),
                  this
                );
              }),
              (t.prototype.resize = function (t) {
                var e = this;
                (this.m = this.el.node.getScreenCTM().inverse()),
                  (this.offset = { x: window.pageXOffset, y: window.pageYOffset });
                var i = this._extractPosition(t.detail.event);
                if (
                  ((this.parameters = {
                    type: this.el.type,
                    p: this.transformPoint(i.x, i.y),
                    x: t.detail.x,
                    y: t.detail.y,
                    box: this.el.bbox(),
                    rotation: this.el.transform().rotation,
                  }),
                  "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]),
                  void 0 !== t.detail.i)
                ) {
                  var s = this.el.array().valueOf();
                  (this.parameters.i = t.detail.i),
                    (this.parameters.pointCoords = [s[t.detail.i][0], s[t.detail.i][1]]);
                }
                switch (t.type) {
                  case "lt":
                    this.calc = function (t, e) {
                      var i = this.snapToGrid(t, e);
                      if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height - i[1] > 0) {
                        if ("text" === this.parameters.type)
                          return (
                            this.el.move(this.parameters.box.x + i[0], this.parameters.box.y),
                            void this.el.attr("font-size", this.parameters.fontSize - i[0])
                          );
                        (i = this.checkAspectRatio(i)),
                          this.el
                            .move(this.parameters.box.x + i[0], this.parameters.box.y + i[1])
                            .size(this.parameters.box.width - i[0], this.parameters.box.height - i[1]);
                      }
                    };
                    break;
                  case "rt":
                    this.calc = function (t, e) {
                      var i = this.snapToGrid(t, e, 2);
                      if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height - i[1] > 0) {
                        if ("text" === this.parameters.type)
                          return (
                            this.el.move(this.parameters.box.x - i[0], this.parameters.box.y),
                            void this.el.attr("font-size", this.parameters.fontSize + i[0])
                          );
                        (i = this.checkAspectRatio(i, !0)),
                          this.el
                            .move(this.parameters.box.x, this.parameters.box.y + i[1])
                            .size(this.parameters.box.width + i[0], this.parameters.box.height - i[1]);
                      }
                    };
                    break;
                  case "rb":
                    this.calc = function (t, e) {
                      var i = this.snapToGrid(t, e, 0);
                      if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height + i[1] > 0) {
                        if ("text" === this.parameters.type)
                          return (
                            this.el.move(this.parameters.box.x - i[0], this.parameters.box.y),
                            void this.el.attr("font-size", this.parameters.fontSize + i[0])
                          );
                        (i = this.checkAspectRatio(i)),
                          this.el
                            .move(this.parameters.box.x, this.parameters.box.y)
                            .size(this.parameters.box.width + i[0], this.parameters.box.height + i[1]);
                      }
                    };
                    break;
                  case "lb":
                    this.calc = function (t, e) {
                      var i = this.snapToGrid(t, e, 1);
                      if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height + i[1] > 0) {
                        if ("text" === this.parameters.type)
                          return (
                            this.el.move(this.parameters.box.x + i[0], this.parameters.box.y),
                            void this.el.attr("font-size", this.parameters.fontSize - i[0])
                          );
                        (i = this.checkAspectRatio(i, !0)),
                          this.el
                            .move(this.parameters.box.x + i[0], this.parameters.box.y)
                            .size(this.parameters.box.width - i[0], this.parameters.box.height + i[1]);
                      }
                    };
                    break;
                  case "t":
                    this.calc = function (t, e) {
                      var i = this.snapToGrid(t, e, 2);
                      if (this.parameters.box.height - i[1] > 0) {
                        if ("text" === this.parameters.type) return;
                        this.el
                          .move(this.parameters.box.x, this.parameters.box.y + i[1])
                          .height(this.parameters.box.height - i[1]);
                      }
                    };
                    break;
                  case "r":
                    this.calc = function (t, e) {
                      var i = this.snapToGrid(t, e, 0);
                      if (this.parameters.box.width + i[0] > 0) {
                        if ("text" === this.parameters.type) return;
                        this.el
                          .move(this.parameters.box.x, this.parameters.box.y)
                          .width(this.parameters.box.width + i[0]);
                      }
                    };
                    break;
                  case "b":
                    this.calc = function (t, e) {
                      var i = this.snapToGrid(t, e, 0);
                      if (this.parameters.box.height + i[1] > 0) {
                        if ("text" === this.parameters.type) return;
                        this.el
                          .move(this.parameters.box.x, this.parameters.box.y)
                          .height(this.parameters.box.height + i[1]);
                      }
                    };
                    break;
                  case "l":
                    this.calc = function (t, e) {
                      var i = this.snapToGrid(t, e, 1);
                      if (this.parameters.box.width - i[0] > 0) {
                        if ("text" === this.parameters.type) return;
                        this.el
                          .move(this.parameters.box.x + i[0], this.parameters.box.y)
                          .width(this.parameters.box.width - i[0]);
                      }
                    };
                    break;
                  case "rot":
                    this.calc = function (t, e) {
                      var i = t + this.parameters.p.x,
                        s = e + this.parameters.p.y,
                        a = Math.atan2(
                          this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2,
                          this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2
                        ),
                        n = Math.atan2(
                          s - this.parameters.box.y - this.parameters.box.height / 2,
                          i - this.parameters.box.x - this.parameters.box.width / 2
                        ),
                        r = this.parameters.rotation + (180 * (n - a)) / Math.PI + this.options.snapToAngle / 2;
                      this.el
                        .center(this.parameters.box.cx, this.parameters.box.cy)
                        .rotate(r - (r % this.options.snapToAngle), this.parameters.box.cx, this.parameters.box.cy);
                    };
                    break;
                  case "point":
                    this.calc = function (t, e) {
                      var i = this.snapToGrid(t, e, this.parameters.pointCoords[0], this.parameters.pointCoords[1]),
                        s = this.el.array().valueOf();
                      (s[this.parameters.i][0] = this.parameters.pointCoords[0] + i[0]),
                        (s[this.parameters.i][1] = this.parameters.pointCoords[1] + i[1]),
                        this.el.plot(s);
                    };
                }
                this.el.fire("resizestart", { dx: this.parameters.x, dy: this.parameters.y, event: t }),
                  SVG.on(window, "touchmove.resize", function (t) {
                    e.update(t || window.event);
                  }),
                  SVG.on(window, "touchend.resize", function () {
                    e.done();
                  }),
                  SVG.on(window, "mousemove.resize", function (t) {
                    e.update(t || window.event);
                  }),
                  SVG.on(window, "mouseup.resize", function () {
                    e.done();
                  });
              }),
              (t.prototype.update = function (t) {
                if (t) {
                  var e = this._extractPosition(t),
                    i = this.transformPoint(e.x, e.y),
                    s = i.x - this.parameters.p.x,
                    a = i.y - this.parameters.p.y;
                  (this.lastUpdateCall = [s, a]), this.calc(s, a), this.el.fire("resizing", { dx: s, dy: a, event: t });
                } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
              }),
              (t.prototype.done = function () {
                (this.lastUpdateCall = null),
                  SVG.off(window, "mousemove.resize"),
                  SVG.off(window, "mouseup.resize"),
                  SVG.off(window, "touchmove.resize"),
                  SVG.off(window, "touchend.resize"),
                  this.el.fire("resizedone");
              }),
              (t.prototype.snapToGrid = function (t, e, i, s) {
                var a;
                return (
                  void 0 !== s
                    ? (a = [(i + t) % this.options.snapToGrid, (s + e) % this.options.snapToGrid])
                    : ((i = null == i ? 3 : i),
                      (a = [
                        (this.parameters.box.x + t + (1 & i ? 0 : this.parameters.box.width)) % this.options.snapToGrid,
                        (this.parameters.box.y + e + (2 & i ? 0 : this.parameters.box.height)) %
                          this.options.snapToGrid,
                      ])),
                  t < 0 && (a[0] -= this.options.snapToGrid),
                  e < 0 && (a[1] -= this.options.snapToGrid),
                  (t -=
                    Math.abs(a[0]) < this.options.snapToGrid / 2
                      ? a[0]
                      : a[0] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid)),
                  (e -=
                    Math.abs(a[1]) < this.options.snapToGrid / 2
                      ? a[1]
                      : a[1] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid)),
                  this.constraintToBox(t, e, i, s)
                );
              }),
              (t.prototype.constraintToBox = function (t, e, i, s) {
                var a,
                  n,
                  r = this.options.constraint || {};
                return (
                  void 0 !== s
                    ? ((a = i), (n = s))
                    : ((a = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width)),
                      (n = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height))),
                  void 0 !== r.minX && a + t < r.minX && (t = r.minX - a),
                  void 0 !== r.maxX && a + t > r.maxX && (t = r.maxX - a),
                  void 0 !== r.minY && n + e < r.minY && (e = r.minY - n),
                  void 0 !== r.maxY && n + e > r.maxY && (e = r.maxY - n),
                  [t, e]
                );
              }),
              (t.prototype.checkAspectRatio = function (t, e) {
                if (!this.options.saveAspectRatio) return t;
                var i = t.slice(),
                  s = this.parameters.box.width / this.parameters.box.height,
                  a = this.parameters.box.width + t[0],
                  n = this.parameters.box.height - t[1],
                  r = a / n;
                return (
                  r < s
                    ? ((i[1] = a / s - this.parameters.box.height), e && (i[1] = -i[1]))
                    : r > s && ((i[0] = this.parameters.box.width - n * s), e && (i[0] = -i[0])),
                  i
                );
              }),
              SVG.extend(SVG.Element, {
                resize: function (e) {
                  return (this.remember("_resizeHandler") || new t(this)).init(e || {}), this;
                },
              }),
              (SVG.Element.prototype.resize.defaults = {
                snapToAngle: 0.1,
                snapToGrid: 1,
                constraint: {},
                saveAspectRatio: !1,
              });
          }).call(this);
        })(),
        void 0 === window.Apex && (window.Apex = {});
      var Ht = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "initModules",
                value: function () {
                  (this.ctx.publicMethods = [
                    "updateOptions",
                    "updateSeries",
                    "appendData",
                    "appendSeries",
                    "toggleSeries",
                    "showSeries",
                    "hideSeries",
                    "setLocale",
                    "resetSeries",
                    "zoomX",
                    "toggleDataPointSelection",
                    "dataURI",
                    "exportToCSV",
                    "addXaxisAnnotation",
                    "addYaxisAnnotation",
                    "addPointAnnotation",
                    "clearAnnotations",
                    "removeAnnotation",
                    "paper",
                    "destroy",
                  ]),
                    (this.ctx.eventList = [
                      "click",
                      "mousedown",
                      "mousemove",
                      "mouseleave",
                      "touchstart",
                      "touchmove",
                      "touchleave",
                      "mouseup",
                      "touchend",
                    ]),
                    (this.ctx.animations = new y(this.ctx)),
                    (this.ctx.axes = new tt(this.ctx)),
                    (this.ctx.core = new Bt(this.ctx.el, this.ctx)),
                    (this.ctx.config = new z({})),
                    (this.ctx.data = new W(this.ctx)),
                    (this.ctx.grid = new U(this.ctx)),
                    (this.ctx.graphics = new k(this.ctx)),
                    (this.ctx.coreUtils = new S(this.ctx)),
                    (this.ctx.crosshairs = new et(this.ctx)),
                    (this.ctx.events = new J(this.ctx)),
                    (this.ctx.exports = new j(this.ctx)),
                    (this.ctx.localization = new Q(this.ctx)),
                    (this.ctx.options = new P()),
                    (this.ctx.responsive = new it(this.ctx)),
                    (this.ctx.series = new Y(this.ctx)),
                    (this.ctx.theme = new st(this.ctx)),
                    (this.ctx.formatters = new $(this.ctx)),
                    (this.ctx.titleSubtitle = new at(this.ctx)),
                    (this.ctx.legend = new dt(this.ctx)),
                    (this.ctx.toolbar = new ut(this.ctx)),
                    (this.ctx.tooltip = new yt(this.ctx)),
                    (this.ctx.dimensions = new ct(this.ctx)),
                    (this.ctx.updateHelpers = new Xt(this.ctx)),
                    (this.ctx.zoomPanSelection = new pt(this.ctx)),
                    (this.ctx.w.globals.tooltip = new yt(this.ctx));
                },
              },
            ]),
            t
          );
        })(),
        Yt = (function () {
          function t(e) {
            o(this, t), (this.ctx = e), (this.w = e.w);
          }
          return (
            c(t, [
              {
                key: "clear",
                value: function (t) {
                  var e = t.isUpdating;
                  this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(),
                    this.ctx.toolbar && this.ctx.toolbar.destroy(),
                    (this.ctx.animations = null),
                    (this.ctx.axes = null),
                    (this.ctx.annotations = null),
                    (this.ctx.core = null),
                    (this.ctx.data = null),
                    (this.ctx.grid = null),
                    (this.ctx.series = null),
                    (this.ctx.responsive = null),
                    (this.ctx.theme = null),
                    (this.ctx.formatters = null),
                    (this.ctx.titleSubtitle = null),
                    (this.ctx.legend = null),
                    (this.ctx.dimensions = null),
                    (this.ctx.options = null),
                    (this.ctx.crosshairs = null),
                    (this.ctx.zoomPanSelection = null),
                    (this.ctx.updateHelpers = null),
                    (this.ctx.toolbar = null),
                    (this.ctx.localization = null),
                    (this.ctx.w.globals.tooltip = null),
                    this.clearDomElements({ isUpdating: e });
                },
              },
              {
                key: "killSVG",
                value: function (t) {
                  t.each(function (t, e) {
                    this.removeClass("*"), this.off(), this.stop();
                  }, !0),
                    t.ungroup(),
                    t.clear();
                },
              },
              {
                key: "clearDomElements",
                value: function (t) {
                  var e = this,
                    i = t.isUpdating,
                    s = this.w.globals.dom.Paper.node;
                  s.parentNode && s.parentNode.parentNode && !i && (s.parentNode.parentNode.style.minHeight = "unset");
                  var a = this.w.globals.dom.baseEl;
                  a &&
                    this.ctx.eventList.forEach(function (t) {
                      a.removeEventListener(t, e.ctx.events.documentEvent);
                    });
                  var n = this.w.globals.dom;
                  if (null !== this.ctx.el)
                    for (; this.ctx.el.firstChild; ) this.ctx.el.removeChild(this.ctx.el.firstChild);
                  this.killSVG(n.Paper),
                    n.Paper.remove(),
                    (n.elWrap = null),
                    (n.elGraphical = null),
                    (n.elAnnotations = null),
                    (n.elLegendWrap = null),
                    (n.baseEl = null),
                    (n.elGridRect = null),
                    (n.elGridRectMask = null),
                    (n.elGridRectMarkerMask = null),
                    (n.elForecastMask = null),
                    (n.elNonForecastMask = null),
                    (n.elDefs = null);
                },
              },
            ]),
            t
          );
        })(),
        Wt = new WeakMap(),
        $t = (function () {
          function t(e, i) {
            o(this, t),
              (this.opts = i),
              (this.ctx = this),
              (this.w = new R(i).init()),
              (this.el = e),
              (this.w.globals.cuid = b.randomId()),
              (this.w.globals.chartID = this.w.config.chart.id
                ? b.escapeString(this.w.config.chart.id)
                : this.w.globals.cuid),
              new Ht(this).initModules(),
              (this.create = b.bind(this.create, this)),
              (this.windowResizeHandler = this._windowResizeHandler.bind(this)),
              (this.parentResizeHandler = this._parentResizeCallback.bind(this));
          }
          return (
            c(
              t,
              [
                {
                  key: "render",
                  value: function () {
                    var t = this;
                    return new Promise(function (e, i) {
                      if (null !== t.el) {
                        void 0 === Apex._chartInstances && (Apex._chartInstances = []),
                          t.w.config.chart.id &&
                            Apex._chartInstances.push({
                              id: t.w.globals.chartID,
                              group: t.w.config.chart.group,
                              chart: t,
                            }),
                          t.setLocale(t.w.config.chart.defaultLocale);
                        var s = t.w.config.chart.events.beforeMount;
                        if (
                          ("function" == typeof s && s(t, t.w),
                          t.events.fireEvent("beforeMount", [t, t.w]),
                          window.addEventListener("resize", t.windowResizeHandler),
                          (function (t, e) {
                            var i = !1;
                            if (t.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
                              var s = t.getBoundingClientRect();
                              ("none" !== t.style.display && 0 !== s.width) || (i = !0);
                            }
                            var a = new ResizeObserver(function (s) {
                              i && e.call(t, s), (i = !0);
                            });
                            t.nodeType === Node.DOCUMENT_FRAGMENT_NODE
                              ? Array.from(t.children).forEach(function (t) {
                                  return a.observe(t);
                                })
                              : a.observe(t),
                              Wt.set(e, a);
                          })(t.el.parentNode, t.parentResizeHandler),
                          !t.css)
                        ) {
                          var a = t.el.getRootNode && t.el.getRootNode(),
                            n = b.is("ShadowRoot", a),
                            r = t.el.ownerDocument,
                            o = r.getElementById("apexcharts-css");
                          (!n && o) ||
                            ((t.css = document.createElement("style")),
                            (t.css.id = "apexcharts-css"),
                            (t.css.textContent =
                              '@keyframes opaque {\n  0% {\n      opacity: 0\n  }\n\n  to {\n      opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n  0%,to {\n      opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0,0,0,.5);\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\n.legend-mouseover-inactive {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255,255,255,.96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30,30,30,.8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0,0,0,.7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,.apexcharts-tooltip-text-y-value,.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,.apexcharts-tooltip-text-goals-value:empty,.apexcharts-tooltip-text-y-label:empty,.apexcharts-tooltip-text-y-value:empty,.apexcharts-tooltip-text-z-value:empty,.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0;\n  margin-right: 10px;\n  border-radius: 50%\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0!important\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_boundingRect,.svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_boundingRect,.apexcharts-selection-rect+g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_points_l,.apexcharts-selection-rect+g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,.apexcharts-pan-icon,.apexcharts-reset-icon,.apexcharts-selection-icon,.apexcharts-toolbar-custom-icon,.apexcharts-zoom-icon,.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,.apexcharts-reset-icon svg,.apexcharts-zoom-icon svg,.apexcharts-zoomin-icon svg,.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,.apexcharts-theme-dark .apexcharts-pan-icon svg,.apexcharts-theme-dark .apexcharts-reset-icon svg,.apexcharts-theme-dark .apexcharts-selection-icon svg,.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,.apexcharts-theme-dark .apexcharts-zoom-icon svg,.apexcharts-theme-dark .apexcharts-zoomin-icon svg,.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,.apexcharts-theme-light .apexcharts-reset-icon:hover svg,.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,.apexcharts-reset-icon,.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0,0,0,.7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n      opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,.apexcharts-datalabel.apexcharts-element-hidden,.apexcharts-hide .apexcharts-series-points {\n  opacity: 0\n}\n\n.apexcharts-datalabel,.apexcharts-datalabel-label,.apexcharts-datalabel-value,.apexcharts-datalabels,.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-annotation-rect,.apexcharts-area-series .apexcharts-area,.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-gridline,.apexcharts-line,.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-point-annotation-label,.apexcharts-radar-series path,.apexcharts-radar-series polygon,.apexcharts-toolbar svg,.apexcharts-tooltip .apexcharts-marker,.apexcharts-xaxis-annotation-label,.apexcharts-yaxis-annotation-label,.apexcharts-zoom-rect {\n  pointer-events: none\n}\n\n.apexcharts-marker {\n  transition: .15s ease all\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,.resize-triggers,.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n'),
                            n ? a.prepend(t.css) : r.head.appendChild(t.css));
                        }
                        var l = t.create(t.w.config.series, {});
                        if (!l) return e(t);
                        t.mount(l)
                          .then(function () {
                            "function" == typeof t.w.config.chart.events.mounted &&
                              t.w.config.chart.events.mounted(t, t.w),
                              t.events.fireEvent("mounted", [t, t.w]),
                              e(l);
                          })
                          .catch(function (t) {
                            i(t);
                          });
                      } else i(new Error("Element not found"));
                    });
                  },
                },
                {
                  key: "create",
                  value: function (t, e) {
                    var i = this.w;
                    new Ht(this).initModules();
                    var s = this.w.globals;
                    if (
                      ((s.noData = !1),
                      (s.animationEnded = !1),
                      this.responsive.checkResponsiveConfig(e),
                      i.config.xaxis.convertedCatToNumeric &&
                        new D(i.config).convertCatToNumericXaxis(i.config, this.ctx),
                      null === this.el)
                    )
                      return (s.animationEnded = !0), null;
                    if (
                      (this.core.setupElements(),
                      "treemap" === i.config.chart.type && ((i.config.grid.show = !1), (i.config.yaxis[0].show = !1)),
                      0 === s.svgWidth)
                    )
                      return (s.animationEnded = !0), null;
                    var a = S.checkComboSeries(t);
                    (s.comboCharts = a.comboCharts), (s.comboBarCount = a.comboBarCount);
                    var n = t.every(function (t) {
                      return t.data && 0 === t.data.length;
                    });
                    (0 === t.length || n) && this.series.handleNoData(),
                      this.events.setupEventHandlers(),
                      this.data.parseData(t),
                      this.theme.init(),
                      new B(this).setGlobalMarkerSize(),
                      this.formatters.setLabelFormatters(),
                      this.titleSubtitle.draw(),
                      (s.noData &&
                        s.collapsedSeries.length !== s.series.length &&
                        !i.config.legend.showForSingleSeries) ||
                        this.legend.init(),
                      this.series.hasAllSeriesEqualX(),
                      s.axisCharts &&
                        (this.core.coreCalculations(),
                        "category" !== i.config.xaxis.type && this.formatters.setLabelFormatters(),
                        (this.ctx.toolbar.minX = i.globals.minX),
                        (this.ctx.toolbar.maxX = i.globals.maxX)),
                      this.formatters.heatmapLabelFormatters(),
                      new S(this).getLargestMarkerSize(),
                      this.dimensions.plotCoords();
                    var r = this.core.xySettings();
                    this.grid.createGridMask();
                    var o = this.core.plotChartType(t, r),
                      l = new H(this);
                    l.bringForward(),
                      i.config.dataLabels.background.enabled && l.dataLabelsBackground(),
                      this.core.shiftGraphPosition();
                    var c = {
                      plot: {
                        left: i.globals.translateX,
                        top: i.globals.translateY,
                        width: i.globals.gridWidth,
                        height: i.globals.gridHeight,
                      },
                    };
                    return { elGraph: o, xyRatios: r, elInner: i.globals.dom.elGraphical, dimensions: c };
                  },
                },
                {
                  key: "mount",
                  value: function () {
                    var t = this,
                      e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                      i = this,
                      s = i.w;
                    return new Promise(function (a, n) {
                      if (null === i.el) return n(new Error("Not enough data to display or target element not found"));
                      (null === e || s.globals.allSeriesCollapsed) && i.series.handleNoData(), (i.grid = new U(i));
                      var r = i.grid.drawGrid();
                      "treemap" !== s.config.chart.type && i.axes.drawAxis(s.config.chart.type, r),
                        (i.annotations = new M(i)),
                        i.annotations.drawImageAnnos(),
                        i.annotations.drawTextAnnos(),
                        "back" === s.config.grid.position && r && s.globals.dom.elGraphical.add(r.el);
                      var o = new G(t.ctx, r),
                        l = new K(t.ctx, r);
                      if (
                        (null !== r &&
                          (o.xAxisLabelCorrections(r.xAxisTickWidth),
                          l.setYAxisTextAlignments(),
                          s.config.yaxis.map(function (t, e) {
                            -1 === s.globals.ignoreYAxisIndexes.indexOf(e) && l.yAxisTitleRotate(e, t.opposite);
                          })),
                        "back" === s.config.annotations.position &&
                          (s.globals.dom.Paper.add(s.globals.dom.elAnnotations), i.annotations.drawAxesAnnotations()),
                        Array.isArray(e.elGraph))
                      )
                        for (var c = 0; c < e.elGraph.length; c++) s.globals.dom.elGraphical.add(e.elGraph[c]);
                      else s.globals.dom.elGraphical.add(e.elGraph);
                      if (
                        ("front" === s.config.grid.position && r && s.globals.dom.elGraphical.add(r.el),
                        r && r.elGridBorders && r.elGridBorders.node && s.globals.dom.elGraphical.add(r.elGridBorders),
                        "front" === s.config.xaxis.crosshairs.position && i.crosshairs.drawXCrosshairs(),
                        "front" === s.config.yaxis[0].crosshairs.position && i.crosshairs.drawYCrosshairs(),
                        "front" === s.config.annotations.position &&
                          (s.globals.dom.Paper.add(s.globals.dom.elAnnotations), i.annotations.drawAxesAnnotations()),
                        !s.globals.noData)
                      ) {
                        if (
                          (s.config.tooltip.enabled && !s.globals.noData && i.w.globals.tooltip.drawTooltip(e.xyRatios),
                          s.globals.axisCharts &&
                            (s.globals.isXNumeric || s.config.xaxis.convertedCatToNumeric || s.globals.isRangeBar))
                        )
                          (s.config.chart.zoom.enabled ||
                            (s.config.chart.selection && s.config.chart.selection.enabled) ||
                            (s.config.chart.pan && s.config.chart.pan.enabled)) &&
                            i.zoomPanSelection.init({ xyRatios: e.xyRatios });
                        else {
                          var h = s.config.chart.toolbar.tools;
                          ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function (t) {
                            h[t] = !1;
                          });
                        }
                        s.config.chart.toolbar.show && !s.globals.allSeriesCollapsed && i.toolbar.createToolbar();
                      }
                      s.globals.memory.methodsToExec.length > 0 &&
                        s.globals.memory.methodsToExec.forEach(function (t) {
                          t.method(t.params, !1, t.context);
                        }),
                        s.globals.axisCharts || s.globals.noData || i.core.resizeNonAxisCharts(),
                        a(i);
                    });
                  },
                },
                {
                  key: "destroy",
                  value: function () {
                    var t, e;
                    window.removeEventListener("resize", this.windowResizeHandler),
                      this.el.parentNode,
                      (t = this.parentResizeHandler),
                      (e = Wt.get(t)) && (e.disconnect(), Wt.delete(t));
                    var i = this.w.config.chart.id;
                    i &&
                      Apex._chartInstances.forEach(function (t, e) {
                        t.id === b.escapeString(i) && Apex._chartInstances.splice(e, 1);
                      }),
                      new Yt(this.ctx).clear({ isUpdating: !1 });
                  },
                },
                {
                  key: "updateOptions",
                  value: function (t) {
                    var e = this,
                      i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                      s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                      a = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                      n = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                      r = this.w;
                    return (
                      (r.globals.selection = void 0),
                      t.series &&
                        (this.series.resetSeries(!1, !0, !1),
                        t.series.length &&
                          t.series[0].data &&
                          (t.series = t.series.map(function (t, i) {
                            return e.updateHelpers._extendSeries(t, i);
                          })),
                        this.updateHelpers.revertDefaultAxisMinMax()),
                      t.xaxis && (t = this.updateHelpers.forceXAxisUpdate(t)),
                      t.yaxis && (t = this.updateHelpers.forceYAxisUpdate(t)),
                      r.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(),
                      t.theme && (t = this.theme.updateThemeOptions(t)),
                      this.updateHelpers._updateOptions(t, i, s, a, n)
                    );
                  },
                },
                {
                  key: "updateSeries",
                  value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                      e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                      i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    return (
                      this.series.resetSeries(!1),
                      this.updateHelpers.revertDefaultAxisMinMax(),
                      this.updateHelpers._updateSeries(t, e, i)
                    );
                  },
                },
                {
                  key: "appendSeries",
                  value: function (t) {
                    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                      i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                      s = this.w.config.series.slice();
                    return (
                      s.push(t),
                      this.series.resetSeries(!1),
                      this.updateHelpers.revertDefaultAxisMinMax(),
                      this.updateHelpers._updateSeries(s, e, i)
                    );
                  },
                },
                {
                  key: "appendData",
                  value: function (t) {
                    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                      i = this;
                    (i.w.globals.dataChanged = !0), i.series.getPreviousPaths();
                    for (var s = i.w.config.series.slice(), a = 0; a < s.length; a++)
                      if (null !== t[a] && void 0 !== t[a])
                        for (var n = 0; n < t[a].data.length; n++) s[a].data.push(t[a].data[n]);
                    return (
                      (i.w.config.series = s),
                      e && (i.w.globals.initialSeries = b.clone(i.w.config.series)),
                      this.update()
                    );
                  },
                },
                {
                  key: "update",
                  value: function (t) {
                    var e = this;
                    return new Promise(function (i, s) {
                      new Yt(e.ctx).clear({ isUpdating: !0 });
                      var a = e.create(e.w.config.series, t);
                      if (!a) return i(e);
                      e.mount(a)
                        .then(function () {
                          "function" == typeof e.w.config.chart.events.updated &&
                            e.w.config.chart.events.updated(e, e.w),
                            e.events.fireEvent("updated", [e, e.w]),
                            (e.w.globals.isDirty = !0),
                            i(e);
                        })
                        .catch(function (t) {
                          s(t);
                        });
                    });
                  },
                },
                {
                  key: "getSyncedCharts",
                  value: function () {
                    var t = this.getGroupedCharts(),
                      e = [this];
                    return (
                      t.length &&
                        ((e = []),
                        t.forEach(function (t) {
                          e.push(t);
                        })),
                      e
                    );
                  },
                },
                {
                  key: "getGroupedCharts",
                  value: function () {
                    var t = this;
                    return Apex._chartInstances
                      .filter(function (t) {
                        if (t.group) return !0;
                      })
                      .map(function (e) {
                        return t.w.config.chart.group === e.group ? e.chart : t;
                      });
                  },
                },
                {
                  key: "toggleSeries",
                  value: function (t) {
                    return this.series.toggleSeries(t);
                  },
                },
                {
                  key: "highlightSeriesOnLegendHover",
                  value: function (t, e) {
                    return this.series.toggleSeriesOnHover(t, e);
                  },
                },
                {
                  key: "showSeries",
                  value: function (t) {
                    this.series.showSeries(t);
                  },
                },
                {
                  key: "hideSeries",
                  value: function (t) {
                    this.series.hideSeries(t);
                  },
                },
                {
                  key: "resetSeries",
                  value: function () {
                    var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                      e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    this.series.resetSeries(t, e);
                  },
                },
                {
                  key: "addEventListener",
                  value: function (t, e) {
                    this.events.addEventListener(t, e);
                  },
                },
                {
                  key: "removeEventListener",
                  value: function (t, e) {
                    this.events.removeEventListener(t, e);
                  },
                },
                {
                  key: "addXaxisAnnotation",
                  value: function (t) {
                    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
                      s = this;
                    i && (s = i), s.annotations.addXaxisAnnotationExternal(t, e, s);
                  },
                },
                {
                  key: "addYaxisAnnotation",
                  value: function (t) {
                    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
                      s = this;
                    i && (s = i), s.annotations.addYaxisAnnotationExternal(t, e, s);
                  },
                },
                {
                  key: "addPointAnnotation",
                  value: function (t) {
                    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
                      s = this;
                    i && (s = i), s.annotations.addPointAnnotationExternal(t, e, s);
                  },
                },
                {
                  key: "clearAnnotations",
                  value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0,
                      e = this;
                    t && (e = t), e.annotations.clearAnnotations(e);
                  },
                },
                {
                  key: "removeAnnotation",
                  value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0,
                      i = this;
                    e && (i = e), i.annotations.removeAnnotation(i, t);
                  },
                },
                {
                  key: "getChartArea",
                  value: function () {
                    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
                  },
                },
                {
                  key: "getSeriesTotalXRange",
                  value: function (t, e) {
                    return this.coreUtils.getSeriesTotalsXRange(t, e);
                  },
                },
                {
                  key: "getHighestValueInSeries",
                  value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                      e = new Z(this.ctx);
                    return e.getMinYMaxY(t).highestY;
                  },
                },
                {
                  key: "getLowestValueInSeries",
                  value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                      e = new Z(this.ctx);
                    return e.getMinYMaxY(t).lowestY;
                  },
                },
                {
                  key: "getSeriesTotal",
                  value: function () {
                    return this.w.globals.seriesTotals;
                  },
                },
                {
                  key: "toggleDataPointSelection",
                  value: function (t, e) {
                    return this.updateHelpers.toggleDataPointSelection(t, e);
                  },
                },
                {
                  key: "zoomX",
                  value: function (t, e) {
                    this.ctx.toolbar.zoomUpdateOptions(t, e);
                  },
                },
                {
                  key: "setLocale",
                  value: function (t) {
                    this.localization.setCurrentLocaleValues(t);
                  },
                },
                {
                  key: "dataURI",
                  value: function (t) {
                    return new j(this.ctx).dataURI(t);
                  },
                },
                {
                  key: "exportToCSV",
                  value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                      e = new j(this.ctx);
                    return e.exportToCSV(t);
                  },
                },
                {
                  key: "paper",
                  value: function () {
                    return this.w.globals.dom.Paper;
                  },
                },
                {
                  key: "_parentResizeCallback",
                  value: function () {
                    this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
                  },
                },
                {
                  key: "_windowResize",
                  value: function () {
                    var t = this;
                    clearTimeout(this.w.globals.resizeTimer),
                      (this.w.globals.resizeTimer = window.setTimeout(function () {
                        (t.w.globals.resized = !0), (t.w.globals.dataChanged = !1), t.ctx.update();
                      }, 150));
                  },
                },
                {
                  key: "_windowResizeHandler",
                  value: function () {
                    var t = this.w.config.chart.redrawOnWindowResize;
                    "function" == typeof t && (t = t()), t && this._windowResize();
                  },
                },
              ],
              [
                {
                  key: "getChartByID",
                  value: function (t) {
                    var e = b.escapeString(t),
                      i = Apex._chartInstances.filter(function (t) {
                        return t.id === e;
                      })[0];
                    return i && i.chart;
                  },
                },
                {
                  key: "initOnLoad",
                  value: function () {
                    for (var e = document.querySelectorAll("[data-apexcharts]"), i = 0; i < e.length; i++)
                      new t(e[i], JSON.parse(e[i].getAttribute("data-options"))).render();
                  },
                },
                {
                  key: "exec",
                  value: function (t, e) {
                    var i = this.getChartByID(t);
                    if (i) {
                      i.w.globals.isExecCalled = !0;
                      var s = null;
                      if (-1 !== i.publicMethods.indexOf(e)) {
                        for (var a = arguments.length, n = new Array(a > 2 ? a - 2 : 0), r = 2; r < a; r++)
                          n[r - 2] = arguments[r];
                        s = i[e].apply(i, n);
                      }
                      return s;
                    }
                  },
                },
                {
                  key: "merge",
                  value: function (t, e) {
                    return b.extend(t, e);
                  },
                },
              ]
            ),
            t
          );
        })();
      t.exports = $t;
    },
    935: function (t, e, i) {
      "use strict";
      async function s(t, e = null) {
        t.classList.remove("hidden"), await n("enter", t, e);
      }
      async function a(t, e = null) {
        await n("leave", t, e), t.classList.add("hidden");
      }
      async function n(t, e, i) {
        const s = e.dataset,
          a = i ? `${i}-${t}` : t;
        let n = `transition${t.charAt(0).toUpperCase() + t.slice(1)}`;
        const l = s[n] ? s[n].split(" ") : [a],
          c = s[`${n}Start`] ? s[`${n}Start`].split(" ") : [`${a}-start`],
          h = s[`${n}End`] ? s[`${n}End`].split(" ") : [`${a}-end`];
        r(e, l),
          r(e, c),
          await new Promise((t) => {
            requestAnimationFrame(() => {
              requestAnimationFrame(t);
            });
          }),
          o(e, c),
          r(e, h),
          await (function (t) {
            return new Promise((e) => {
              const i = getComputedStyle(t).transitionDuration.split(",")[0],
                s = 1e3 * Number(i.replace("s", ""));
              setTimeout(() => {
                e();
              }, s);
            });
          })(e),
          o(e, h),
          o(e, l);
      }
      function r(t, e) {
        t.classList.add(...e);
      }
      function o(t, e) {
        t.classList.remove(...e);
      }
      i.d(e, {
        IO: function () {
          return s;
        },
        Zu: function () {
          return a;
        },
      });
    },
    230: function (t) {
      t.exports = "object" == typeof self ? self.FormData : window.FormData;
    },
    131: function (t, e, i) {
      "use strict";
      function s(t) {
        return (
          (s =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                }),
          s(t)
        );
      }
      function a(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
      }
      function n(t, e) {
        for (var i = 0; i < e.length; i++) {
          var s = e[i];
          (s.enumerable = s.enumerable || !1),
            (s.configurable = !0),
            "value" in s && (s.writable = !0),
            Object.defineProperty(t, s.key, s);
        }
      }
      function r(t, e, i) {
        return e && n(t.prototype, e), i && n(t, i), Object.defineProperty(t, "prototype", { writable: !1 }), t;
      }
      function o(t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError("Super expression must either be null or a function");
        (t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } })),
          Object.defineProperty(t, "prototype", { writable: !1 }),
          e && c(t, e);
      }
      function l(t) {
        return (
          (l = Object.setPrototypeOf
            ? Object.getPrototypeOf.bind()
            : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t);
              }),
          l(t)
        );
      }
      function c(t, e) {
        return (
          (c = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          c(t, e)
        );
      }
      function h(t, e) {
        if (null == t) return {};
        var i,
          s,
          a = (function (t, e) {
            if (null == t) return {};
            var i,
              s,
              a = {},
              n = Object.keys(t);
            for (s = 0; s < n.length; s++) (i = n[s]), e.indexOf(i) >= 0 || (a[i] = t[i]);
            return a;
          })(t, e);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(t);
          for (s = 0; s < n.length; s++)
            (i = n[s]), e.indexOf(i) >= 0 || (Object.prototype.propertyIsEnumerable.call(t, i) && (a[i] = t[i]));
        }
        return a;
      }
      function d(t, e) {
        if (e && ("object" == typeof e || "function" == typeof e)) return e;
        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
        return (function (t) {
          if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t;
        })(t);
      }
      function u(t) {
        var e = (function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (t) {
            return !1;
          }
        })();
        return function () {
          var i,
            s = l(t);
          if (e) {
            var a = l(this).constructor;
            i = Reflect.construct(s, arguments, a);
          } else i = s.apply(this, arguments);
          return d(this, i);
        };
      }
      function p(t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = l(t)); );
        return t;
      }
      function g() {
        return (
          (g =
            "undefined" != typeof Reflect && Reflect.get
              ? Reflect.get.bind()
              : function (t, e, i) {
                  var s = p(t, e);
                  if (s) {
                    var a = Object.getOwnPropertyDescriptor(s, e);
                    return a.get ? a.get.call(arguments.length < 3 ? t : i) : a.value;
                  }
                }),
          g.apply(this, arguments)
        );
      }
      function f(t, e, i, s) {
        return (
          (f =
            "undefined" != typeof Reflect && Reflect.set
              ? Reflect.set
              : function (t, e, i, s) {
                  var a,
                    n = p(t, e);
                  if (n) {
                    if ((a = Object.getOwnPropertyDescriptor(n, e)).set) return a.set.call(s, i), !0;
                    if (!a.writable) return !1;
                  }
                  if ((a = Object.getOwnPropertyDescriptor(s, e))) {
                    if (!a.writable) return !1;
                    (a.value = i), Object.defineProperty(s, e, a);
                  } else
                    !(function (t, e, i) {
                      e in t
                        ? Object.defineProperty(t, e, { value: i, enumerable: !0, configurable: !0, writable: !0 })
                        : (t[e] = i);
                    })(s, e, i);
                  return !0;
                }),
          f(t, e, i, s)
        );
      }
      function m(t, e, i, s, a) {
        if (!f(t, e, i, s || t) && a) throw new Error("failed to set property");
        return i;
      }
      function v(t, e) {
        return (
          (function (t) {
            if (Array.isArray(t)) return t;
          })(t) ||
          (function (t, e) {
            var i = null == t ? null : ("undefined" != typeof Symbol && t[Symbol.iterator]) || t["@@iterator"];
            if (null != i) {
              var s,
                a,
                n = [],
                r = !0,
                o = !1;
              try {
                for (i = i.call(t); !(r = (s = i.next()).done) && (n.push(s.value), !e || n.length !== e); r = !0);
              } catch (t) {
                (o = !0), (a = t);
              } finally {
                try {
                  r || null == i.return || i.return();
                } finally {
                  if (o) throw a;
                }
              }
              return n;
            }
          })(t, e) ||
          x(t, e) ||
          (function () {
            throw new TypeError(
              "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          })()
        );
      }
      function x(t, e) {
        if (t) {
          if ("string" == typeof t) return b(t, e);
          var i = Object.prototype.toString.call(t).slice(8, -1);
          return (
            "Object" === i && t.constructor && (i = t.constructor.name),
            "Map" === i || "Set" === i
              ? Array.from(t)
              : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)
              ? b(t, e)
              : void 0
          );
        }
      }
      function b(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var i = 0, s = new Array(e); i < e; i++) s[i] = t[i];
        return s;
      }
      i.d(e, {
        ZP: function () {
          return F;
        },
      });
      var y = (function () {
        function t(e) {
          a(this, t), Object.assign(this, { inserted: "", rawInserted: "", skip: !1, tailShift: 0 }, e);
        }
        return (
          r(t, [
            {
              key: "aggregate",
              value: function (t) {
                return (
                  (this.rawInserted += t.rawInserted),
                  (this.skip = this.skip || t.skip),
                  (this.inserted += t.inserted),
                  (this.tailShift += t.tailShift),
                  this
                );
              },
            },
            {
              key: "offset",
              get: function () {
                return this.tailShift + this.inserted.length;
              },
            },
          ]),
          t
        );
      })();
      function w(t) {
        return "string" == typeof t || t instanceof String;
      }
      var k = "NONE",
        S = "LEFT",
        C = "FORCE_LEFT",
        A = "RIGHT",
        E = "FORCE_RIGHT";
      function T(t) {
        switch (t) {
          case S:
            return C;
          case A:
            return E;
          default:
            return t;
        }
      }
      function L(t) {
        return t.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
      }
      function P(t) {
        return Array.isArray(t) ? t : [t, new y()];
      }
      function M(t, e) {
        if (e === t) return !0;
        var i,
          a = Array.isArray(e),
          n = Array.isArray(t);
        if (a && n) {
          if (e.length != t.length) return !1;
          for (i = 0; i < e.length; i++) if (!M(e[i], t[i])) return !1;
          return !0;
        }
        if (a != n) return !1;
        if (e && t && "object" === s(e) && "object" === s(t)) {
          var r = e instanceof Date,
            o = t instanceof Date;
          if (r && o) return e.getTime() == t.getTime();
          if (r != o) return !1;
          var l = e instanceof RegExp,
            c = t instanceof RegExp;
          if (l && c) return e.toString() == t.toString();
          if (l != c) return !1;
          var h = Object.keys(e);
          for (i = 0; i < h.length; i++) if (!Object.prototype.hasOwnProperty.call(t, h[i])) return !1;
          for (i = 0; i < h.length; i++) if (!M(t[h[i]], e[h[i]])) return !1;
          return !0;
        }
        return !(!e || !t || "function" != typeof e || "function" != typeof t) && e.toString() === t.toString();
      }
      var O = (function () {
          function t(e, i, s, n) {
            for (
              a(this, t), this.value = e, this.cursorPos = i, this.oldValue = s, this.oldSelection = n;
              this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos);

            )
              --this.oldSelection.start;
          }
          return (
            r(t, [
              {
                key: "startChangePos",
                get: function () {
                  return Math.min(this.cursorPos, this.oldSelection.start);
                },
              },
              {
                key: "insertedCount",
                get: function () {
                  return this.cursorPos - this.startChangePos;
                },
              },
              {
                key: "inserted",
                get: function () {
                  return this.value.substr(this.startChangePos, this.insertedCount);
                },
              },
              {
                key: "removedCount",
                get: function () {
                  return Math.max(
                    this.oldSelection.end - this.startChangePos || this.oldValue.length - this.value.length,
                    0
                  );
                },
              },
              {
                key: "removed",
                get: function () {
                  return this.oldValue.substr(this.startChangePos, this.removedCount);
                },
              },
              {
                key: "head",
                get: function () {
                  return this.value.substring(0, this.startChangePos);
                },
              },
              {
                key: "tail",
                get: function () {
                  return this.value.substring(this.startChangePos + this.insertedCount);
                },
              },
              {
                key: "removeDirection",
                get: function () {
                  return !this.removedCount || this.insertedCount
                    ? k
                    : (this.oldSelection.end !== this.cursorPos && this.oldSelection.start !== this.cursorPos) ||
                      this.oldSelection.end !== this.oldSelection.start
                    ? S
                    : A;
                },
              },
            ]),
            t
          );
        })(),
        I = (function () {
          function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
              i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
              s = arguments.length > 2 ? arguments[2] : void 0;
            a(this, t), (this.value = e), (this.from = i), (this.stop = s);
          }
          return (
            r(t, [
              {
                key: "toString",
                value: function () {
                  return this.value;
                },
              },
              {
                key: "extend",
                value: function (t) {
                  this.value += String(t);
                },
              },
              {
                key: "appendTo",
                value: function (t) {
                  return t.append(this.toString(), { tail: !0 }).aggregate(t._appendPlaceholder());
                },
              },
              {
                key: "state",
                get: function () {
                  return { value: this.value, from: this.from, stop: this.stop };
                },
                set: function (t) {
                  Object.assign(this, t);
                },
              },
              {
                key: "unshift",
                value: function (t) {
                  if (!this.value.length || (null != t && this.from >= t)) return "";
                  var e = this.value[0];
                  return (this.value = this.value.slice(1)), e;
                },
              },
              {
                key: "shift",
                value: function () {
                  if (!this.value.length) return "";
                  var t = this.value[this.value.length - 1];
                  return (this.value = this.value.slice(0, -1)), t;
                },
              },
            ]),
            t
          );
        })();
      function F(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return new F.InputMask(t, e);
      }
      var D = (function () {
        function t(e) {
          a(this, t), (this._value = ""), this._update(Object.assign({}, t.DEFAULTS, e)), (this.isInitialized = !0);
        }
        return (
          r(t, [
            {
              key: "updateOptions",
              value: function (t) {
                Object.keys(t).length && this.withValueRefresh(this._update.bind(this, t));
              },
            },
            {
              key: "_update",
              value: function (t) {
                Object.assign(this, t);
              },
            },
            {
              key: "state",
              get: function () {
                return { _value: this.value };
              },
              set: function (t) {
                this._value = t._value;
              },
            },
            {
              key: "reset",
              value: function () {
                this._value = "";
              },
            },
            {
              key: "value",
              get: function () {
                return this._value;
              },
              set: function (t) {
                this.resolve(t);
              },
            },
            {
              key: "resolve",
              value: function (t) {
                return this.reset(), this.append(t, { input: !0 }, ""), this.doCommit(), this.value;
              },
            },
            {
              key: "unmaskedValue",
              get: function () {
                return this.value;
              },
              set: function (t) {
                this.reset(), this.append(t, {}, ""), this.doCommit();
              },
            },
            {
              key: "typedValue",
              get: function () {
                return this.doParse(this.value);
              },
              set: function (t) {
                this.value = this.doFormat(t);
              },
            },
            {
              key: "rawInputValue",
              get: function () {
                return this.extractInput(0, this.value.length, { raw: !0 });
              },
              set: function (t) {
                this.reset(), this.append(t, { raw: !0 }, ""), this.doCommit();
              },
            },
            {
              key: "isComplete",
              get: function () {
                return !0;
              },
            },
            {
              key: "isFilled",
              get: function () {
                return this.isComplete;
              },
            },
            {
              key: "nearestInputPos",
              value: function (t, e) {
                return t;
              },
            },
            {
              key: "extractInput",
              value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                  e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length;
                return this.value.slice(t, e);
              },
            },
            {
              key: "extractTail",
              value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                  e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length;
                return new I(this.extractInput(t, e), t);
              },
            },
            {
              key: "appendTail",
              value: function (t) {
                return w(t) && (t = new I(String(t))), t.appendTo(this);
              },
            },
            {
              key: "_appendCharRaw",
              value: function (t) {
                return t ? ((this._value += t), new y({ inserted: t, rawInserted: t })) : new y();
              },
            },
            {
              key: "_appendChar",
              value: function (t) {
                var e,
                  i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                  s = arguments.length > 2 ? arguments[2] : void 0,
                  a = this.state,
                  n = P(this.doPrepare(t, i)),
                  r = v(n, 2);
                if (((t = r[0]), (e = (e = r[1]).aggregate(this._appendCharRaw(t, i))).inserted)) {
                  var o,
                    l = !1 !== this.doValidate(i);
                  if (l && null != s) {
                    var c = this.state;
                    !0 === this.overwrite && ((o = s.state), s.unshift(this.value.length));
                    var h = this.appendTail(s);
                    ((l = h.rawInserted === s.toString()) && h.inserted) ||
                      "shift" !== this.overwrite ||
                      ((this.state = c),
                      (o = s.state),
                      s.shift(),
                      (l = (h = this.appendTail(s)).rawInserted === s.toString())),
                      l && h.inserted && (this.state = c);
                  }
                  l || ((e = new y()), (this.state = a), s && o && (s.state = o));
                }
                return e;
              },
            },
            {
              key: "_appendPlaceholder",
              value: function () {
                return new y();
              },
            },
            {
              key: "_appendEager",
              value: function () {
                return new y();
              },
            },
            {
              key: "append",
              value: function (t, e, i) {
                if (!w(t)) throw new Error("value should be string");
                var s = new y(),
                  a = w(i) ? new I(String(i)) : i;
                null != e && e.tail && (e._beforeTailState = this.state);
                for (var n = 0; n < t.length; ++n) s.aggregate(this._appendChar(t[n], e, a));
                return (
                  null != a && (s.tailShift += this.appendTail(a).tailShift),
                  this.eager && null != e && e.input && t && s.aggregate(this._appendEager()),
                  s
                );
              },
            },
            {
              key: "remove",
              value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                  e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length;
                return (this._value = this.value.slice(0, t) + this.value.slice(e)), new y();
              },
            },
            {
              key: "withValueRefresh",
              value: function (t) {
                if (this._refreshing || !this.isInitialized) return t();
                this._refreshing = !0;
                var e = this.rawInputValue,
                  i = this.value,
                  s = t();
                return (
                  (this.rawInputValue = e),
                  this.value &&
                    this.value !== i &&
                    0 === i.indexOf(this.value) &&
                    this.append(i.slice(this.value.length), {}, ""),
                  delete this._refreshing,
                  s
                );
              },
            },
            {
              key: "runIsolated",
              value: function (t) {
                if (this._isolated || !this.isInitialized) return t(this);
                this._isolated = !0;
                var e = this.state,
                  i = t(this);
                return (this.state = e), delete this._isolated, i;
              },
            },
            {
              key: "doPrepare",
              value: function (t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return this.prepare ? this.prepare(t, this, e) : t;
              },
            },
            {
              key: "doValidate",
              value: function (t) {
                return (
                  (!this.validate || this.validate(this.value, this, t)) && (!this.parent || this.parent.doValidate(t))
                );
              },
            },
            {
              key: "doCommit",
              value: function () {
                this.commit && this.commit(this.value, this);
              },
            },
            {
              key: "doFormat",
              value: function (t) {
                return this.format ? this.format(t, this) : t;
              },
            },
            {
              key: "doParse",
              value: function (t) {
                return this.parse ? this.parse(t, this) : t;
              },
            },
            {
              key: "splice",
              value: function (t, e, i, s) {
                var a,
                  n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : { input: !0 },
                  r = t + e,
                  o = this.extractTail(r);
                this.eager && ((s = T(s)), (a = this.extractInput(0, r, { raw: !0 })));
                var l = this.nearestInputPos(t, e > 1 && 0 !== t && !this.eager ? k : s),
                  c = new y({ tailShift: l - t }).aggregate(this.remove(l));
                if (this.eager && s !== k && a === this.rawInputValue)
                  if (s === C)
                    for (var h; a === this.rawInputValue && (h = this.value.length); )
                      c.aggregate(new y({ tailShift: -1 })).aggregate(this.remove(h - 1));
                  else s === E && o.unshift();
                return c.aggregate(this.append(i, n, o));
              },
            },
            {
              key: "maskEquals",
              value: function (t) {
                return this.mask === t;
              },
            },
            {
              key: "typedValueEquals",
              value: function (e) {
                var i = this.typedValue;
                return (
                  e === i ||
                  (t.EMPTY_VALUES.includes(e) && t.EMPTY_VALUES.includes(i)) ||
                  this.doFormat(e) === this.doFormat(this.typedValue)
                );
              },
            },
          ]),
          t
        );
      })();
      function z(t) {
        if (null == t) throw new Error("mask property should be defined");
        return t instanceof RegExp
          ? F.MaskedRegExp
          : w(t)
          ? F.MaskedPattern
          : t instanceof Date || t === Date
          ? F.MaskedDate
          : t instanceof Number || "number" == typeof t || t === Number
          ? F.MaskedNumber
          : Array.isArray(t) || t === Array
          ? F.MaskedDynamic
          : F.Masked && t.prototype instanceof F.Masked
          ? t
          : t instanceof F.Masked
          ? t.constructor
          : t instanceof Function
          ? F.MaskedFunction
          : (console.warn("Mask not found for mask", t), F.Masked);
      }
      function N(t) {
        if (F.Masked && t instanceof F.Masked) return t;
        var e = (t = Object.assign({}, t)).mask;
        if (F.Masked && e instanceof F.Masked) return e;
        var i = z(e);
        if (!i)
          throw new Error(
            "Masked class is not found for provided mask, appropriate module needs to be import manually before creating mask."
          );
        return new i(t);
      }
      (D.DEFAULTS = {
        format: function (t) {
          return t;
        },
        parse: function (t) {
          return t;
        },
      }),
        (D.EMPTY_VALUES = [void 0, null, ""]),
        (F.Masked = D),
        (F.createMask = N);
      var R = ["mask"],
        _ = {
          0: /\d/,
          a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
          "*": /./,
        },
        B = (function () {
          function t(e) {
            a(this, t);
            var i = e.mask,
              s = h(e, R);
            (this.masked = N({ mask: i })), Object.assign(this, s);
          }
          return (
            r(t, [
              {
                key: "reset",
                value: function () {
                  (this.isFilled = !1), this.masked.reset();
                },
              },
              {
                key: "remove",
                value: function () {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length;
                  return 0 === t && e >= 1 ? ((this.isFilled = !1), this.masked.remove(t, e)) : new y();
                },
              },
              {
                key: "value",
                get: function () {
                  return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : "");
                },
              },
              {
                key: "unmaskedValue",
                get: function () {
                  return this.masked.unmaskedValue;
                },
              },
              {
                key: "isComplete",
                get: function () {
                  return Boolean(this.masked.value) || this.isOptional;
                },
              },
              {
                key: "_appendChar",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                  if (this.isFilled) return new y();
                  var i = this.masked.state,
                    s = this.masked._appendChar(t, e);
                  return (
                    s.inserted &&
                      !1 === this.doValidate(e) &&
                      ((s.inserted = s.rawInserted = ""), (this.masked.state = i)),
                    s.inserted || this.isOptional || this.lazy || e.input || (s.inserted = this.placeholderChar),
                    (s.skip = !s.inserted && !this.isOptional),
                    (this.isFilled = Boolean(s.inserted)),
                    s
                  );
                },
              },
              {
                key: "append",
                value: function () {
                  var t;
                  return (t = this.masked).append.apply(t, arguments);
                },
              },
              {
                key: "_appendPlaceholder",
                value: function () {
                  var t = new y();
                  return (
                    this.isFilled || this.isOptional || ((this.isFilled = !0), (t.inserted = this.placeholderChar)), t
                  );
                },
              },
              {
                key: "_appendEager",
                value: function () {
                  return new y();
                },
              },
              {
                key: "extractTail",
                value: function () {
                  var t;
                  return (t = this.masked).extractTail.apply(t, arguments);
                },
              },
              {
                key: "appendTail",
                value: function () {
                  var t;
                  return (t = this.masked).appendTail.apply(t, arguments);
                },
              },
              {
                key: "extractInput",
                value: function () {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
                    i = arguments.length > 2 ? arguments[2] : void 0;
                  return this.masked.extractInput(t, e, i);
                },
              },
              {
                key: "nearestInputPos",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : k,
                    i = 0,
                    s = this.value.length,
                    a = Math.min(Math.max(t, i), s);
                  switch (e) {
                    case S:
                    case C:
                      return this.isComplete ? a : i;
                    case A:
                    case E:
                      return this.isComplete ? a : s;
                    default:
                      return a;
                  }
                },
              },
              {
                key: "doValidate",
                value: function () {
                  var t, e;
                  return (
                    (t = this.masked).doValidate.apply(t, arguments) &&
                    (!this.parent || (e = this.parent).doValidate.apply(e, arguments))
                  );
                },
              },
              {
                key: "doCommit",
                value: function () {
                  this.masked.doCommit();
                },
              },
              {
                key: "state",
                get: function () {
                  return { masked: this.masked.state, isFilled: this.isFilled };
                },
                set: function (t) {
                  (this.masked.state = t.masked), (this.isFilled = t.isFilled);
                },
              },
            ]),
            t
          );
        })(),
        X = (function () {
          function t(e) {
            a(this, t), Object.assign(this, e), (this._value = ""), (this.isFixed = !0);
          }
          return (
            r(t, [
              {
                key: "value",
                get: function () {
                  return this._value;
                },
              },
              {
                key: "unmaskedValue",
                get: function () {
                  return this.isUnmasking ? this.value : "";
                },
              },
              {
                key: "reset",
                value: function () {
                  (this._isRawInput = !1), (this._value = "");
                },
              },
              {
                key: "remove",
                value: function () {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._value.length;
                  return (
                    (this._value = this._value.slice(0, t) + this._value.slice(e)),
                    this._value || (this._isRawInput = !1),
                    new y()
                  );
                },
              },
              {
                key: "nearestInputPos",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : k,
                    i = 0,
                    s = this._value.length;
                  switch (e) {
                    case S:
                    case C:
                      return i;
                    default:
                      return s;
                  }
                },
              },
              {
                key: "extractInput",
                value: function () {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._value.length,
                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                  return (i.raw && this._isRawInput && this._value.slice(t, e)) || "";
                },
              },
              {
                key: "isComplete",
                get: function () {
                  return !0;
                },
              },
              {
                key: "isFilled",
                get: function () {
                  return Boolean(this._value);
                },
              },
              {
                key: "_appendChar",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    i = new y();
                  if (this._value) return i;
                  var s = this.char === t,
                    a = s && (this.isUnmasking || e.input || e.raw) && (!e.raw || !this.eager) && !e.tail;
                  return (
                    a && (i.rawInserted = this.char),
                    (this._value = i.inserted = this.char),
                    (this._isRawInput = a && (e.raw || e.input)),
                    i
                  );
                },
              },
              {
                key: "_appendEager",
                value: function () {
                  return this._appendChar(this.char, { tail: !0 });
                },
              },
              {
                key: "_appendPlaceholder",
                value: function () {
                  var t = new y();
                  return this._value || (this._value = t.inserted = this.char), t;
                },
              },
              {
                key: "extractTail",
                value: function () {
                  return (arguments.length > 1 && void 0 !== arguments[1]) || this.value.length, new I("");
                },
              },
              {
                key: "appendTail",
                value: function (t) {
                  return w(t) && (t = new I(String(t))), t.appendTo(this);
                },
              },
              {
                key: "append",
                value: function (t, e, i) {
                  var s = this._appendChar(t[0], e);
                  return null != i && (s.tailShift += this.appendTail(i).tailShift), s;
                },
              },
              { key: "doCommit", value: function () {} },
              {
                key: "state",
                get: function () {
                  return { _value: this._value, _isRawInput: this._isRawInput };
                },
                set: function (t) {
                  Object.assign(this, t);
                },
              },
            ]),
            t
          );
        })(),
        H = ["chunks"],
        Y = (function () {
          function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
              i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            a(this, t), (this.chunks = e), (this.from = i);
          }
          return (
            r(t, [
              {
                key: "toString",
                value: function () {
                  return this.chunks.map(String).join("");
                },
              },
              {
                key: "extend",
                value: function (e) {
                  if (String(e)) {
                    w(e) && (e = new I(String(e)));
                    var i = this.chunks[this.chunks.length - 1],
                      s = i && (i.stop === e.stop || null == e.stop) && e.from === i.from + i.toString().length;
                    if (e instanceof I) s ? i.extend(e.toString()) : this.chunks.push(e);
                    else if (e instanceof t) {
                      if (null == e.stop)
                        for (var a; e.chunks.length && null == e.chunks[0].stop; )
                          ((a = e.chunks.shift()).from += e.from), this.extend(a);
                      e.toString() && ((e.stop = e.blockIndex), this.chunks.push(e));
                    }
                  }
                },
              },
              {
                key: "appendTo",
                value: function (e) {
                  if (!(e instanceof F.MaskedPattern)) return new I(this.toString()).appendTo(e);
                  for (var i = new y(), s = 0; s < this.chunks.length && !i.skip; ++s) {
                    var a = this.chunks[s],
                      n = e._mapPosToBlock(e.value.length),
                      r = a.stop,
                      o = void 0;
                    if (
                      (null != r &&
                        (!n || n.index <= r) &&
                        ((a instanceof t || e._stops.indexOf(r) >= 0) && i.aggregate(e._appendPlaceholder(r)),
                        (o = a instanceof t && e._blocks[r])),
                      o)
                    ) {
                      var l = o.appendTail(a);
                      (l.skip = !1), i.aggregate(l), (e._value += l.inserted);
                      var c = a.toString().slice(l.rawInserted.length);
                      c && i.aggregate(e.append(c, { tail: !0 }));
                    } else i.aggregate(e.append(a.toString(), { tail: !0 }));
                  }
                  return i;
                },
              },
              {
                key: "state",
                get: function () {
                  return {
                    chunks: this.chunks.map(function (t) {
                      return t.state;
                    }),
                    from: this.from,
                    stop: this.stop,
                    blockIndex: this.blockIndex,
                  };
                },
                set: function (e) {
                  var i = e.chunks,
                    s = h(e, H);
                  Object.assign(this, s),
                    (this.chunks = i.map(function (e) {
                      var i = "chunks" in e ? new t() : new I();
                      return (i.state = e), i;
                    }));
                },
              },
              {
                key: "unshift",
                value: function (t) {
                  if (!this.chunks.length || (null != t && this.from >= t)) return "";
                  for (var e = null != t ? t - this.from : t, i = 0; i < this.chunks.length; ) {
                    var s = this.chunks[i],
                      a = s.unshift(e);
                    if (s.toString()) {
                      if (!a) break;
                      ++i;
                    } else this.chunks.splice(i, 1);
                    if (a) return a;
                  }
                  return "";
                },
              },
              {
                key: "shift",
                value: function () {
                  if (!this.chunks.length) return "";
                  for (var t = this.chunks.length - 1; 0 <= t; ) {
                    var e = this.chunks[t],
                      i = e.shift();
                    if (e.toString()) {
                      if (!i) break;
                      --t;
                    } else this.chunks.splice(t, 1);
                    if (i) return i;
                  }
                  return "";
                },
              },
            ]),
            t
          );
        })(),
        W = (function () {
          function t(e, i) {
            a(this, t), (this.masked = e), (this._log = []);
            var s =
                e._mapPosToBlock(i) ||
                (i < 0 ? { index: 0, offset: 0 } : { index: this.masked._blocks.length, offset: 0 }),
              n = s.offset,
              r = s.index;
            (this.offset = n), (this.index = r), (this.ok = !1);
          }
          return (
            r(t, [
              {
                key: "block",
                get: function () {
                  return this.masked._blocks[this.index];
                },
              },
              {
                key: "pos",
                get: function () {
                  return this.masked._blockStartPos(this.index) + this.offset;
                },
              },
              {
                key: "state",
                get: function () {
                  return { index: this.index, offset: this.offset, ok: this.ok };
                },
                set: function (t) {
                  Object.assign(this, t);
                },
              },
              {
                key: "pushState",
                value: function () {
                  this._log.push(this.state);
                },
              },
              {
                key: "popState",
                value: function () {
                  var t = this._log.pop();
                  return (this.state = t), t;
                },
              },
              {
                key: "bindBlock",
                value: function () {
                  this.block ||
                    (this.index < 0 && ((this.index = 0), (this.offset = 0)),
                    this.index >= this.masked._blocks.length &&
                      ((this.index = this.masked._blocks.length - 1), (this.offset = this.block.value.length)));
                },
              },
              {
                key: "_pushLeft",
                value: function (t) {
                  for (
                    this.pushState(), this.bindBlock();
                    0 <= this.index;
                    --this.index,
                      this.offset = (null === (e = this.block) || void 0 === e ? void 0 : e.value.length) || 0
                  ) {
                    var e;
                    if (t()) return (this.ok = !0);
                  }
                  return (this.ok = !1);
                },
              },
              {
                key: "_pushRight",
                value: function (t) {
                  for (
                    this.pushState(), this.bindBlock();
                    this.index < this.masked._blocks.length;
                    ++this.index, this.offset = 0
                  )
                    if (t()) return (this.ok = !0);
                  return (this.ok = !1);
                },
              },
              {
                key: "pushLeftBeforeFilled",
                value: function () {
                  var t = this;
                  return this._pushLeft(function () {
                    if (!t.block.isFixed && t.block.value)
                      return (t.offset = t.block.nearestInputPos(t.offset, C)), 0 !== t.offset || void 0;
                  });
                },
              },
              {
                key: "pushLeftBeforeInput",
                value: function () {
                  var t = this;
                  return this._pushLeft(function () {
                    if (!t.block.isFixed) return (t.offset = t.block.nearestInputPos(t.offset, S)), !0;
                  });
                },
              },
              {
                key: "pushLeftBeforeRequired",
                value: function () {
                  var t = this;
                  return this._pushLeft(function () {
                    if (!(t.block.isFixed || (t.block.isOptional && !t.block.value)))
                      return (t.offset = t.block.nearestInputPos(t.offset, S)), !0;
                  });
                },
              },
              {
                key: "pushRightBeforeFilled",
                value: function () {
                  var t = this;
                  return this._pushRight(function () {
                    if (!t.block.isFixed && t.block.value)
                      return (
                        (t.offset = t.block.nearestInputPos(t.offset, E)), t.offset !== t.block.value.length || void 0
                      );
                  });
                },
              },
              {
                key: "pushRightBeforeInput",
                value: function () {
                  var t = this;
                  return this._pushRight(function () {
                    if (!t.block.isFixed) return (t.offset = t.block.nearestInputPos(t.offset, k)), !0;
                  });
                },
              },
              {
                key: "pushRightBeforeRequired",
                value: function () {
                  var t = this;
                  return this._pushRight(function () {
                    if (!(t.block.isFixed || (t.block.isOptional && !t.block.value)))
                      return (t.offset = t.block.nearestInputPos(t.offset, k)), !0;
                  });
                },
              },
            ]),
            t
          );
        })(),
        $ = (function (t) {
          o(i, t);
          var e = u(i);
          function i() {
            return a(this, i), e.apply(this, arguments);
          }
          return (
            r(i, [
              {
                key: "_update",
                value: function (t) {
                  t.mask &&
                    (t.validate = function (e) {
                      return e.search(t.mask) >= 0;
                    }),
                    g(l(i.prototype), "_update", this).call(this, t);
                },
              },
            ]),
            i
          );
        })(D);
      F.MaskedRegExp = $;
      var V = ["_blocks"],
        j = (function (t) {
          o(i, t);
          var e = u(i);
          function i() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return (
              a(this, i),
              (t.definitions = Object.assign({}, _, t.definitions)),
              e.call(this, Object.assign({}, i.DEFAULTS, t))
            );
          }
          return (
            r(i, [
              {
                key: "_update",
                value: function () {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                  (t.definitions = Object.assign({}, this.definitions, t.definitions)),
                    g(l(i.prototype), "_update", this).call(this, t),
                    this._rebuildMask();
                },
              },
              {
                key: "_rebuildMask",
                value: function () {
                  var t = this,
                    e = this.definitions;
                  (this._blocks = []), (this._stops = []), (this._maskedBlocks = {});
                  var s = this.mask;
                  if (s && e)
                    for (var a = !1, n = !1, r = 0; r < s.length; ++r)
                      if (
                        !this.blocks ||
                        "continue" !==
                          (function () {
                            var e = s.slice(r),
                              i = Object.keys(t.blocks).filter(function (t) {
                                return 0 === e.indexOf(t);
                              });
                            i.sort(function (t, e) {
                              return e.length - t.length;
                            });
                            var a = i[0];
                            if (a) {
                              var n = N(
                                Object.assign(
                                  {
                                    parent: t,
                                    lazy: t.lazy,
                                    eager: t.eager,
                                    placeholderChar: t.placeholderChar,
                                    overwrite: t.overwrite,
                                  },
                                  t.blocks[a]
                                )
                              );
                              return (
                                n &&
                                  (t._blocks.push(n),
                                  t._maskedBlocks[a] || (t._maskedBlocks[a] = []),
                                  t._maskedBlocks[a].push(t._blocks.length - 1)),
                                (r += a.length - 1),
                                "continue"
                              );
                            }
                          })()
                      ) {
                        var o = s[r],
                          l = o in e;
                        if (o !== i.STOP_CHAR)
                          if ("{" !== o && "}" !== o)
                            if ("[" !== o && "]" !== o) {
                              if (o === i.ESCAPE_CHAR) {
                                if ((++r, !(o = s[r]))) break;
                                l = !1;
                              }
                              var c = l
                                ? new B({
                                    parent: this,
                                    lazy: this.lazy,
                                    eager: this.eager,
                                    placeholderChar: this.placeholderChar,
                                    mask: e[o],
                                    isOptional: n,
                                  })
                                : new X({ char: o, eager: this.eager, isUnmasking: a });
                              this._blocks.push(c);
                            } else n = !n;
                          else a = !a;
                        else this._stops.push(this._blocks.length);
                      }
                },
              },
              {
                key: "state",
                get: function () {
                  return Object.assign({}, g(l(i.prototype), "state", this), {
                    _blocks: this._blocks.map(function (t) {
                      return t.state;
                    }),
                  });
                },
                set: function (t) {
                  var e = t._blocks,
                    s = h(t, V);
                  this._blocks.forEach(function (t, i) {
                    return (t.state = e[i]);
                  }),
                    m(l(i.prototype), "state", s, this, !0);
                },
              },
              {
                key: "reset",
                value: function () {
                  g(l(i.prototype), "reset", this).call(this),
                    this._blocks.forEach(function (t) {
                      return t.reset();
                    });
                },
              },
              {
                key: "isComplete",
                get: function () {
                  return this._blocks.every(function (t) {
                    return t.isComplete;
                  });
                },
              },
              {
                key: "isFilled",
                get: function () {
                  return this._blocks.every(function (t) {
                    return t.isFilled;
                  });
                },
              },
              {
                key: "isFixed",
                get: function () {
                  return this._blocks.every(function (t) {
                    return t.isFixed;
                  });
                },
              },
              {
                key: "isOptional",
                get: function () {
                  return this._blocks.every(function (t) {
                    return t.isOptional;
                  });
                },
              },
              {
                key: "doCommit",
                value: function () {
                  this._blocks.forEach(function (t) {
                    return t.doCommit();
                  }),
                    g(l(i.prototype), "doCommit", this).call(this);
                },
              },
              {
                key: "unmaskedValue",
                get: function () {
                  return this._blocks.reduce(function (t, e) {
                    return t + e.unmaskedValue;
                  }, "");
                },
                set: function (t) {
                  m(l(i.prototype), "unmaskedValue", t, this, !0);
                },
              },
              {
                key: "value",
                get: function () {
                  return this._blocks.reduce(function (t, e) {
                    return t + e.value;
                  }, "");
                },
                set: function (t) {
                  m(l(i.prototype), "value", t, this, !0);
                },
              },
              {
                key: "appendTail",
                value: function (t) {
                  return g(l(i.prototype), "appendTail", this).call(this, t).aggregate(this._appendPlaceholder());
                },
              },
              {
                key: "_appendEager",
                value: function () {
                  var t,
                    e = new y(),
                    i = null === (t = this._mapPosToBlock(this.value.length)) || void 0 === t ? void 0 : t.index;
                  if (null == i) return e;
                  this._blocks[i].isFilled && ++i;
                  for (var s = i; s < this._blocks.length; ++s) {
                    var a = this._blocks[s]._appendEager();
                    if (!a.inserted) break;
                    e.aggregate(a);
                  }
                  return e;
                },
              },
              {
                key: "_appendCharRaw",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    i = this._mapPosToBlock(this.value.length),
                    s = new y();
                  if (!i) return s;
                  for (var a = i.index; ; ++a) {
                    var n,
                      r,
                      o = this._blocks[a];
                    if (!o) break;
                    var l = o._appendChar(
                        t,
                        Object.assign({}, e, {
                          _beforeTailState:
                            null === (n = e._beforeTailState) ||
                            void 0 === n ||
                            null === (r = n._blocks) ||
                            void 0 === r
                              ? void 0
                              : r[a],
                        })
                      ),
                      c = l.skip;
                    if ((s.aggregate(l), c || l.rawInserted)) break;
                  }
                  return s;
                },
              },
              {
                key: "extractTail",
                value: function () {
                  var t = this,
                    e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
                    s = new Y();
                  return (
                    e === i ||
                      this._forEachBlocksInRange(e, i, function (e, i, a, n) {
                        var r = e.extractTail(a, n);
                        (r.stop = t._findStopBefore(i)),
                          (r.from = t._blockStartPos(i)),
                          r instanceof Y && (r.blockIndex = i),
                          s.extend(r);
                      }),
                    s
                  );
                },
              },
              {
                key: "extractInput",
                value: function () {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                  if (t === e) return "";
                  var s = "";
                  return (
                    this._forEachBlocksInRange(t, e, function (t, e, a, n) {
                      s += t.extractInput(a, n, i);
                    }),
                    s
                  );
                },
              },
              {
                key: "_findStopBefore",
                value: function (t) {
                  for (var e, i = 0; i < this._stops.length; ++i) {
                    var s = this._stops[i];
                    if (!(s <= t)) break;
                    e = s;
                  }
                  return e;
                },
              },
              {
                key: "_appendPlaceholder",
                value: function (t) {
                  var e = this,
                    i = new y();
                  if (this.lazy && null == t) return i;
                  var s = this._mapPosToBlock(this.value.length);
                  if (!s) return i;
                  var a = s.index,
                    n = null != t ? t : this._blocks.length;
                  return (
                    this._blocks.slice(a, n).forEach(function (s) {
                      if (!s.lazy || null != t) {
                        var a = null != s._blocks ? [s._blocks.length] : [],
                          n = s._appendPlaceholder.apply(s, a);
                        (e._value += n.inserted), i.aggregate(n);
                      }
                    }),
                    i
                  );
                },
              },
              {
                key: "_mapPosToBlock",
                value: function (t) {
                  for (var e = "", i = 0; i < this._blocks.length; ++i) {
                    var s = this._blocks[i],
                      a = e.length;
                    if (t <= (e += s.value).length) return { index: i, offset: t - a };
                  }
                },
              },
              {
                key: "_blockStartPos",
                value: function (t) {
                  return this._blocks.slice(0, t).reduce(function (t, e) {
                    return t + e.value.length;
                  }, 0);
                },
              },
              {
                key: "_forEachBlocksInRange",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
                    i = arguments.length > 2 ? arguments[2] : void 0,
                    s = this._mapPosToBlock(t);
                  if (s) {
                    var a = this._mapPosToBlock(e),
                      n = a && s.index === a.index,
                      r = s.offset,
                      o = a && n ? a.offset : this._blocks[s.index].value.length;
                    if ((i(this._blocks[s.index], s.index, r, o), a && !n)) {
                      for (var l = s.index + 1; l < a.index; ++l)
                        i(this._blocks[l], l, 0, this._blocks[l].value.length);
                      i(this._blocks[a.index], a.index, 0, a.offset);
                    }
                  }
                },
              },
              {
                key: "remove",
                value: function () {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
                    s = g(l(i.prototype), "remove", this).call(this, t, e);
                  return (
                    this._forEachBlocksInRange(t, e, function (t, e, i, a) {
                      s.aggregate(t.remove(i, a));
                    }),
                    s
                  );
                },
              },
              {
                key: "nearestInputPos",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : k;
                  if (!this._blocks.length) return 0;
                  var i = new W(this, t);
                  if (e === k)
                    return i.pushRightBeforeInput()
                      ? i.pos
                      : (i.popState(), i.pushLeftBeforeInput() ? i.pos : this.value.length);
                  if (e === S || e === C) {
                    if (e === S) {
                      if ((i.pushRightBeforeFilled(), i.ok && i.pos === t)) return t;
                      i.popState();
                    }
                    if ((i.pushLeftBeforeInput(), i.pushLeftBeforeRequired(), i.pushLeftBeforeFilled(), e === S)) {
                      if ((i.pushRightBeforeInput(), i.pushRightBeforeRequired(), i.ok && i.pos <= t)) return i.pos;
                      if ((i.popState(), i.ok && i.pos <= t)) return i.pos;
                      i.popState();
                    }
                    return i.ok ? i.pos : e === C ? 0 : (i.popState(), i.ok ? i.pos : (i.popState(), i.ok ? i.pos : 0));
                  }
                  return e === A || e === E
                    ? (i.pushRightBeforeInput(),
                      i.pushRightBeforeRequired(),
                      i.pushRightBeforeFilled()
                        ? i.pos
                        : e === E
                        ? this.value.length
                        : (i.popState(), i.ok ? i.pos : (i.popState(), i.ok ? i.pos : this.nearestInputPos(t, S))))
                    : t;
                },
              },
              {
                key: "maskedBlock",
                value: function (t) {
                  return this.maskedBlocks(t)[0];
                },
              },
              {
                key: "maskedBlocks",
                value: function (t) {
                  var e = this,
                    i = this._maskedBlocks[t];
                  return i
                    ? i.map(function (t) {
                        return e._blocks[t];
                      })
                    : [];
                },
              },
            ]),
            i
          );
        })(D);
      (j.DEFAULTS = { lazy: !0, placeholderChar: "_" }),
        (j.STOP_CHAR = "`"),
        (j.ESCAPE_CHAR = "\\"),
        (j.InputDefinition = B),
        (j.FixedDefinition = X),
        (F.MaskedPattern = j);
      var G = (function (t) {
        o(i, t);
        var e = u(i);
        function i() {
          return a(this, i), e.apply(this, arguments);
        }
        return (
          r(i, [
            {
              key: "_matchFrom",
              get: function () {
                return this.maxLength - String(this.from).length;
              },
            },
            {
              key: "_update",
              value: function (t) {
                t = Object.assign({ to: this.to || 0, from: this.from || 0, maxLength: this.maxLength || 0 }, t);
                var e = String(t.to).length;
                null != t.maxLength && (e = Math.max(e, t.maxLength)), (t.maxLength = e);
                for (
                  var s = String(t.from).padStart(e, "0"), a = String(t.to).padStart(e, "0"), n = 0;
                  n < a.length && a[n] === s[n];

                )
                  ++n;
                (t.mask = a.slice(0, n).replace(/0/g, "\\0") + "0".repeat(e - n)),
                  g(l(i.prototype), "_update", this).call(this, t);
              },
            },
            {
              key: "isComplete",
              get: function () {
                return g(l(i.prototype), "isComplete", this) && Boolean(this.value);
              },
            },
            {
              key: "boundaries",
              value: function (t) {
                var e = "",
                  i = "",
                  s = v(t.match(/^(\D*)(\d*)(\D*)/) || [], 3),
                  a = s[1],
                  n = s[2];
                return (
                  n && ((e = "0".repeat(a.length) + n), (i = "9".repeat(a.length) + n)),
                  [(e = e.padEnd(this.maxLength, "0")), (i = i.padEnd(this.maxLength, "9"))]
                );
              },
            },
            {
              key: "doPrepare",
              value: function (t) {
                var e,
                  s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                  a = P(g(l(i.prototype), "doPrepare", this).call(this, t.replace(/\D/g, ""), s)),
                  n = v(a, 2);
                if (((t = n[0]), (e = n[1]), !this.autofix || !t)) return t;
                var r = String(this.from).padStart(this.maxLength, "0"),
                  o = String(this.to).padStart(this.maxLength, "0"),
                  c = this.value + t;
                if (c.length > this.maxLength) return "";
                var h = this.boundaries(c),
                  d = v(h, 2),
                  u = d[0],
                  p = d[1];
                return Number(p) < this.from
                  ? r[c.length - 1]
                  : Number(u) > this.to
                  ? "pad" === this.autofix && c.length < this.maxLength
                    ? ["", e.aggregate(this.append(r[c.length - 1] + t, s))]
                    : o[c.length - 1]
                  : t;
              },
            },
            {
              key: "doValidate",
              value: function () {
                var t,
                  e = this.value,
                  s = e.search(/[^0]/);
                if (-1 === s && e.length <= this._matchFrom) return !0;
                for (
                  var a = this.boundaries(e),
                    n = v(a, 2),
                    r = n[0],
                    o = n[1],
                    c = arguments.length,
                    h = new Array(c),
                    d = 0;
                  d < c;
                  d++
                )
                  h[d] = arguments[d];
                return (
                  this.from <= Number(o) &&
                  Number(r) <= this.to &&
                  (t = g(l(i.prototype), "doValidate", this)).call.apply(t, [this].concat(h))
                );
              },
            },
          ]),
          i
        );
      })(j);
      F.MaskedRange = G;
      var U = (function (t) {
        o(i, t);
        var e = u(i);
        function i(t) {
          return a(this, i), e.call(this, Object.assign({}, i.DEFAULTS, t));
        }
        return (
          r(i, [
            {
              key: "_update",
              value: function (t) {
                t.mask === Date && delete t.mask, t.pattern && (t.mask = t.pattern);
                var e = t.blocks;
                (t.blocks = Object.assign({}, i.GET_DEFAULT_BLOCKS())),
                  t.min && (t.blocks.Y.from = t.min.getFullYear()),
                  t.max && (t.blocks.Y.to = t.max.getFullYear()),
                  t.min &&
                    t.max &&
                    t.blocks.Y.from === t.blocks.Y.to &&
                    ((t.blocks.m.from = t.min.getMonth() + 1),
                    (t.blocks.m.to = t.max.getMonth() + 1),
                    t.blocks.m.from === t.blocks.m.to &&
                      ((t.blocks.d.from = t.min.getDate()), (t.blocks.d.to = t.max.getDate()))),
                  Object.assign(t.blocks, this.blocks, e),
                  Object.keys(t.blocks).forEach(function (e) {
                    var i = t.blocks[e];
                    !("autofix" in i) && "autofix" in t && (i.autofix = t.autofix);
                  }),
                  g(l(i.prototype), "_update", this).call(this, t);
              },
            },
            {
              key: "doValidate",
              value: function () {
                for (var t, e = this.date, s = arguments.length, a = new Array(s), n = 0; n < s; n++)
                  a[n] = arguments[n];
                return (
                  (t = g(l(i.prototype), "doValidate", this)).call.apply(t, [this].concat(a)) &&
                  (!this.isComplete ||
                    (this.isDateExist(this.value) &&
                      null != e &&
                      (null == this.min || this.min <= e) &&
                      (null == this.max || e <= this.max)))
                );
              },
            },
            {
              key: "isDateExist",
              value: function (t) {
                return this.format(this.parse(t, this), this).indexOf(t) >= 0;
              },
            },
            {
              key: "date",
              get: function () {
                return this.typedValue;
              },
              set: function (t) {
                this.typedValue = t;
              },
            },
            {
              key: "typedValue",
              get: function () {
                return this.isComplete ? g(l(i.prototype), "typedValue", this) : null;
              },
              set: function (t) {
                m(l(i.prototype), "typedValue", t, this, !0);
              },
            },
            {
              key: "maskEquals",
              value: function (t) {
                return t === Date || g(l(i.prototype), "maskEquals", this).call(this, t);
              },
            },
          ]),
          i
        );
      })(j);
      (U.DEFAULTS = {
        pattern: "d{.}`m{.}`Y",
        format: function (t) {
          return t
            ? [String(t.getDate()).padStart(2, "0"), String(t.getMonth() + 1).padStart(2, "0"), t.getFullYear()].join(
                "."
              )
            : "";
        },
        parse: function (t) {
          var e = v(t.split("."), 3),
            i = e[0],
            s = e[1],
            a = e[2];
          return new Date(a, s - 1, i);
        },
      }),
        (U.GET_DEFAULT_BLOCKS = function () {
          return {
            d: { mask: G, from: 1, to: 31, maxLength: 2 },
            m: { mask: G, from: 1, to: 12, maxLength: 2 },
            Y: { mask: G, from: 1900, to: 9999 },
          };
        }),
        (F.MaskedDate = U);
      var q = (function () {
        function t() {
          a(this, t);
        }
        return (
          r(t, [
            {
              key: "selectionStart",
              get: function () {
                var t;
                try {
                  t = this._unsafeSelectionStart;
                } catch (t) {}
                return null != t ? t : this.value.length;
              },
            },
            {
              key: "selectionEnd",
              get: function () {
                var t;
                try {
                  t = this._unsafeSelectionEnd;
                } catch (t) {}
                return null != t ? t : this.value.length;
              },
            },
            {
              key: "select",
              value: function (t, e) {
                if (null != t && null != e && (t !== this.selectionStart || e !== this.selectionEnd))
                  try {
                    this._unsafeSelect(t, e);
                  } catch (t) {}
              },
            },
            { key: "_unsafeSelect", value: function (t, e) {} },
            {
              key: "isActive",
              get: function () {
                return !1;
              },
            },
            { key: "bindEvents", value: function (t) {} },
            { key: "unbindEvents", value: function () {} },
          ]),
          t
        );
      })();
      F.MaskElement = q;
      var Z = (function (t) {
        o(i, t);
        var e = u(i);
        function i(t) {
          var s;
          return a(this, i), ((s = e.call(this)).input = t), (s._handlers = {}), s;
        }
        return (
          r(i, [
            {
              key: "rootElement",
              get: function () {
                var t, e, i;
                return null !==
                  (t = null === (e = (i = this.input).getRootNode) || void 0 === e ? void 0 : e.call(i)) && void 0 !== t
                  ? t
                  : document;
              },
            },
            {
              key: "isActive",
              get: function () {
                return this.input === this.rootElement.activeElement;
              },
            },
            {
              key: "_unsafeSelectionStart",
              get: function () {
                return this.input.selectionStart;
              },
            },
            {
              key: "_unsafeSelectionEnd",
              get: function () {
                return this.input.selectionEnd;
              },
            },
            {
              key: "_unsafeSelect",
              value: function (t, e) {
                this.input.setSelectionRange(t, e);
              },
            },
            {
              key: "value",
              get: function () {
                return this.input.value;
              },
              set: function (t) {
                this.input.value = t;
              },
            },
            {
              key: "bindEvents",
              value: function (t) {
                var e = this;
                Object.keys(t).forEach(function (s) {
                  return e._toggleEventHandler(i.EVENTS_MAP[s], t[s]);
                });
              },
            },
            {
              key: "unbindEvents",
              value: function () {
                var t = this;
                Object.keys(this._handlers).forEach(function (e) {
                  return t._toggleEventHandler(e);
                });
              },
            },
            {
              key: "_toggleEventHandler",
              value: function (t, e) {
                this._handlers[t] && (this.input.removeEventListener(t, this._handlers[t]), delete this._handlers[t]),
                  e && (this.input.addEventListener(t, e), (this._handlers[t] = e));
              },
            },
          ]),
          i
        );
      })(q);
      (Z.EVENTS_MAP = {
        selectionChange: "keydown",
        input: "input",
        drop: "drop",
        click: "click",
        focus: "focus",
        commit: "blur",
      }),
        (F.HTMLMaskElement = Z);
      var K = (function (t) {
        o(i, t);
        var e = u(i);
        function i() {
          return a(this, i), e.apply(this, arguments);
        }
        return (
          r(i, [
            {
              key: "_unsafeSelectionStart",
              get: function () {
                var t = this.rootElement,
                  e = t.getSelection && t.getSelection(),
                  i = e && e.anchorOffset,
                  s = e && e.focusOffset;
                return null == s || null == i || i < s ? i : s;
              },
            },
            {
              key: "_unsafeSelectionEnd",
              get: function () {
                var t = this.rootElement,
                  e = t.getSelection && t.getSelection(),
                  i = e && e.anchorOffset,
                  s = e && e.focusOffset;
                return null == s || null == i || i > s ? i : s;
              },
            },
            {
              key: "_unsafeSelect",
              value: function (t, e) {
                if (this.rootElement.createRange) {
                  var i = this.rootElement.createRange();
                  i.setStart(this.input.firstChild || this.input, t), i.setEnd(this.input.lastChild || this.input, e);
                  var s = this.rootElement,
                    a = s.getSelection && s.getSelection();
                  a && (a.removeAllRanges(), a.addRange(i));
                }
              },
            },
            {
              key: "value",
              get: function () {
                return this.input.textContent;
              },
              set: function (t) {
                this.input.textContent = t;
              },
            },
          ]),
          i
        );
      })(Z);
      F.HTMLContenteditableMaskElement = K;
      var J = ["mask"],
        Q = (function () {
          function t(e, i) {
            a(this, t),
              (this.el =
                e instanceof q
                  ? e
                  : e.isContentEditable && "INPUT" !== e.tagName && "TEXTAREA" !== e.tagName
                  ? new K(e)
                  : new Z(e)),
              (this.masked = N(i)),
              (this._listeners = {}),
              (this._value = ""),
              (this._unmaskedValue = ""),
              (this._saveSelection = this._saveSelection.bind(this)),
              (this._onInput = this._onInput.bind(this)),
              (this._onChange = this._onChange.bind(this)),
              (this._onDrop = this._onDrop.bind(this)),
              (this._onFocus = this._onFocus.bind(this)),
              (this._onClick = this._onClick.bind(this)),
              (this.alignCursor = this.alignCursor.bind(this)),
              (this.alignCursorFriendly = this.alignCursorFriendly.bind(this)),
              this._bindEvents(),
              this.updateValue(),
              this._onChange();
          }
          return (
            r(t, [
              {
                key: "mask",
                get: function () {
                  return this.masked.mask;
                },
                set: function (t) {
                  if (!this.maskEquals(t))
                    if (t instanceof F.Masked || this.masked.constructor !== z(t)) {
                      var e = N({ mask: t });
                      (e.unmaskedValue = this.masked.unmaskedValue), (this.masked = e);
                    } else this.masked.updateOptions({ mask: t });
                },
              },
              {
                key: "maskEquals",
                value: function (t) {
                  var e;
                  return null == t || (null === (e = this.masked) || void 0 === e ? void 0 : e.maskEquals(t));
                },
              },
              {
                key: "value",
                get: function () {
                  return this._value;
                },
                set: function (t) {
                  this.value !== t && ((this.masked.value = t), this.updateControl(), this.alignCursor());
                },
              },
              {
                key: "unmaskedValue",
                get: function () {
                  return this._unmaskedValue;
                },
                set: function (t) {
                  this.unmaskedValue !== t &&
                    ((this.masked.unmaskedValue = t), this.updateControl(), this.alignCursor());
                },
              },
              {
                key: "typedValue",
                get: function () {
                  return this.masked.typedValue;
                },
                set: function (t) {
                  this.masked.typedValueEquals(t) ||
                    ((this.masked.typedValue = t), this.updateControl(), this.alignCursor());
                },
              },
              {
                key: "_bindEvents",
                value: function () {
                  this.el.bindEvents({
                    selectionChange: this._saveSelection,
                    input: this._onInput,
                    drop: this._onDrop,
                    click: this._onClick,
                    focus: this._onFocus,
                    commit: this._onChange,
                  });
                },
              },
              {
                key: "_unbindEvents",
                value: function () {
                  this.el && this.el.unbindEvents();
                },
              },
              {
                key: "_fireEvent",
                value: function (t) {
                  for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), s = 1; s < e; s++)
                    i[s - 1] = arguments[s];
                  var a = this._listeners[t];
                  a &&
                    a.forEach(function (t) {
                      return t.apply(void 0, i);
                    });
                },
              },
              {
                key: "selectionStart",
                get: function () {
                  return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
                },
              },
              {
                key: "cursorPos",
                get: function () {
                  return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
                },
                set: function (t) {
                  this.el && this.el.isActive && (this.el.select(t, t), this._saveSelection());
                },
              },
              {
                key: "_saveSelection",
                value: function () {
                  this.value !== this.el.value &&
                    console.warn(
                      "Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly."
                    ),
                    (this._selection = { start: this.selectionStart, end: this.cursorPos });
                },
              },
              {
                key: "updateValue",
                value: function () {
                  (this.masked.value = this.el.value), (this._value = this.masked.value);
                },
              },
              {
                key: "updateControl",
                value: function () {
                  var t = this.masked.unmaskedValue,
                    e = this.masked.value,
                    i = this.unmaskedValue !== t || this.value !== e;
                  (this._unmaskedValue = t),
                    (this._value = e),
                    this.el.value !== e && (this.el.value = e),
                    i && this._fireChangeEvents();
                },
              },
              {
                key: "updateOptions",
                value: function (t) {
                  var e = t.mask,
                    i = h(t, J),
                    s = !this.maskEquals(e),
                    a = !M(this.masked, i);
                  s && (this.mask = e), a && this.masked.updateOptions(i), (s || a) && this.updateControl();
                },
              },
              {
                key: "updateCursor",
                value: function (t) {
                  null != t && ((this.cursorPos = t), this._delayUpdateCursor(t));
                },
              },
              {
                key: "_delayUpdateCursor",
                value: function (t) {
                  var e = this;
                  this._abortUpdateCursor(),
                    (this._changingCursorPos = t),
                    (this._cursorChanging = setTimeout(function () {
                      e.el && ((e.cursorPos = e._changingCursorPos), e._abortUpdateCursor());
                    }, 10));
                },
              },
              {
                key: "_fireChangeEvents",
                value: function () {
                  this._fireEvent("accept", this._inputEvent),
                    this.masked.isComplete && this._fireEvent("complete", this._inputEvent);
                },
              },
              {
                key: "_abortUpdateCursor",
                value: function () {
                  this._cursorChanging && (clearTimeout(this._cursorChanging), delete this._cursorChanging);
                },
              },
              {
                key: "alignCursor",
                value: function () {
                  this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, S));
                },
              },
              {
                key: "alignCursorFriendly",
                value: function () {
                  this.selectionStart === this.cursorPos && this.alignCursor();
                },
              },
              {
                key: "on",
                value: function (t, e) {
                  return this._listeners[t] || (this._listeners[t] = []), this._listeners[t].push(e), this;
                },
              },
              {
                key: "off",
                value: function (t, e) {
                  if (!this._listeners[t]) return this;
                  if (!e) return delete this._listeners[t], this;
                  var i = this._listeners[t].indexOf(e);
                  return i >= 0 && this._listeners[t].splice(i, 1), this;
                },
              },
              {
                key: "_onInput",
                value: function (t) {
                  if (((this._inputEvent = t), this._abortUpdateCursor(), !this._selection)) return this.updateValue();
                  var e = new O(this.el.value, this.cursorPos, this.value, this._selection),
                    i = this.masked.rawInputValue,
                    s = this.masked.splice(e.startChangePos, e.removed.length, e.inserted, e.removeDirection, {
                      input: !0,
                      raw: !0,
                    }).offset,
                    a = i === this.masked.rawInputValue ? e.removeDirection : k,
                    n = this.masked.nearestInputPos(e.startChangePos + s, a);
                  a !== k && (n = this.masked.nearestInputPos(n, k)),
                    this.updateControl(),
                    this.updateCursor(n),
                    delete this._inputEvent;
                },
              },
              {
                key: "_onChange",
                value: function () {
                  this.value !== this.el.value && this.updateValue(),
                    this.masked.doCommit(),
                    this.updateControl(),
                    this._saveSelection();
                },
              },
              {
                key: "_onDrop",
                value: function (t) {
                  t.preventDefault(), t.stopPropagation();
                },
              },
              {
                key: "_onFocus",
                value: function (t) {
                  this.alignCursorFriendly();
                },
              },
              {
                key: "_onClick",
                value: function (t) {
                  this.alignCursorFriendly();
                },
              },
              {
                key: "destroy",
                value: function () {
                  this._unbindEvents(), (this._listeners.length = 0), delete this.el;
                },
              },
            ]),
            t
          );
        })();
      F.InputMask = Q;
      var tt = (function (t) {
        o(i, t);
        var e = u(i);
        function i() {
          return a(this, i), e.apply(this, arguments);
        }
        return (
          r(i, [
            {
              key: "_update",
              value: function (t) {
                t.enum && (t.mask = "*".repeat(t.enum[0].length)), g(l(i.prototype), "_update", this).call(this, t);
              },
            },
            {
              key: "doValidate",
              value: function () {
                for (var t, e = this, s = arguments.length, a = new Array(s), n = 0; n < s; n++) a[n] = arguments[n];
                return (
                  this.enum.some(function (t) {
                    return t.indexOf(e.unmaskedValue) >= 0;
                  }) && (t = g(l(i.prototype), "doValidate", this)).call.apply(t, [this].concat(a))
                );
              },
            },
          ]),
          i
        );
      })(j);
      F.MaskedEnum = tt;
      var et,
        it = (function (t) {
          o(i, t);
          var e = u(i);
          function i(t) {
            return a(this, i), e.call(this, Object.assign({}, i.DEFAULTS, t));
          }
          return (
            r(i, [
              {
                key: "_update",
                value: function (t) {
                  g(l(i.prototype), "_update", this).call(this, t), this._updateRegExps();
                },
              },
              {
                key: "_updateRegExps",
                value: function () {
                  var t = "^" + (this.allowNegative ? "[+|\\-]?" : ""),
                    e = (this.scale ? "(" + L(this.radix) + "\\d{0," + this.scale + "})?" : "") + "$";
                  (this._numberRegExpInput = new RegExp(t + "(0|([1-9]+\\d*))?" + e)),
                    (this._numberRegExp = new RegExp(t + "\\d*" + e)),
                    (this._mapToRadixRegExp = new RegExp("[" + this.mapToRadix.map(L).join("") + "]", "g")),
                    (this._thousandsSeparatorRegExp = new RegExp(L(this.thousandsSeparator), "g"));
                },
              },
              {
                key: "_removeThousandsSeparators",
                value: function (t) {
                  return t.replace(this._thousandsSeparatorRegExp, "");
                },
              },
              {
                key: "_insertThousandsSeparators",
                value: function (t) {
                  var e = t.split(this.radix);
                  return (e[0] = e[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator)), e.join(this.radix);
                },
              },
              {
                key: "doPrepare",
                value: function (t) {
                  var e;
                  t = t.replace(this._mapToRadixRegExp, this.radix);
                  for (
                    var s = this._removeThousandsSeparators(t),
                      a = arguments.length,
                      n = new Array(a > 1 ? a - 1 : 0),
                      r = 1;
                    r < a;
                    r++
                  )
                    n[r - 1] = arguments[r];
                  var o = P((e = g(l(i.prototype), "doPrepare", this)).call.apply(e, [this, s].concat(n))),
                    c = v(o, 2),
                    h = c[0],
                    d = c[1];
                  return t && !s && (d.skip = !0), [h, d];
                },
              },
              {
                key: "_separatorsCount",
                value: function (t) {
                  for (
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i = 0, s = 0;
                    s < t;
                    ++s
                  )
                    this._value.indexOf(this.thousandsSeparator, s) === s &&
                      (++i, e && (t += this.thousandsSeparator.length));
                  return i;
                },
              },
              {
                key: "_separatorsCountFromSlice",
                value: function () {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._value;
                  return this._separatorsCount(this._removeThousandsSeparators(t).length, !0);
                },
              },
              {
                key: "extractInput",
                value: function () {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
                    s = arguments.length > 2 ? arguments[2] : void 0,
                    a = this._adjustRangeWithSeparators(t, e),
                    n = v(a, 2);
                  return (
                    (t = n[0]),
                    (e = n[1]),
                    this._removeThousandsSeparators(g(l(i.prototype), "extractInput", this).call(this, t, e, s))
                  );
                },
              },
              {
                key: "_appendCharRaw",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                  if (!this.thousandsSeparator) return g(l(i.prototype), "_appendCharRaw", this).call(this, t, e);
                  var s = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value,
                    a = this._separatorsCountFromSlice(s);
                  this._value = this._removeThousandsSeparators(this.value);
                  var n = g(l(i.prototype), "_appendCharRaw", this).call(this, t, e);
                  this._value = this._insertThousandsSeparators(this._value);
                  var r = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value,
                    o = this._separatorsCountFromSlice(r);
                  return (
                    (n.tailShift += (o - a) * this.thousandsSeparator.length),
                    (n.skip = !n.rawInserted && t === this.thousandsSeparator),
                    n
                  );
                },
              },
              {
                key: "_findSeparatorAround",
                value: function (t) {
                  if (this.thousandsSeparator) {
                    var e = t - this.thousandsSeparator.length + 1,
                      i = this.value.indexOf(this.thousandsSeparator, e);
                    if (i <= t) return i;
                  }
                  return -1;
                },
              },
              {
                key: "_adjustRangeWithSeparators",
                value: function (t, e) {
                  var i = this._findSeparatorAround(t);
                  i >= 0 && (t = i);
                  var s = this._findSeparatorAround(e);
                  return s >= 0 && (e = s + this.thousandsSeparator.length), [t, e];
                },
              },
              {
                key: "remove",
                value: function () {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
                    i = this._adjustRangeWithSeparators(t, e),
                    s = v(i, 2);
                  (t = s[0]), (e = s[1]);
                  var a = this.value.slice(0, t),
                    n = this.value.slice(e),
                    r = this._separatorsCount(a.length);
                  this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(a + n));
                  var o = this._separatorsCountFromSlice(a);
                  return new y({ tailShift: (o - r) * this.thousandsSeparator.length });
                },
              },
              {
                key: "nearestInputPos",
                value: function (t, e) {
                  if (!this.thousandsSeparator) return t;
                  switch (e) {
                    case k:
                    case S:
                    case C:
                      var i = this._findSeparatorAround(t - 1);
                      if (i >= 0) {
                        var s = i + this.thousandsSeparator.length;
                        if (t < s || this.value.length <= s || e === C) return i;
                      }
                      break;
                    case A:
                    case E:
                      var a = this._findSeparatorAround(t);
                      if (a >= 0) return a + this.thousandsSeparator.length;
                  }
                  return t;
                },
              },
              {
                key: "doValidate",
                value: function (t) {
                  var e = (t.input ? this._numberRegExpInput : this._numberRegExp).test(
                    this._removeThousandsSeparators(this.value)
                  );
                  if (e) {
                    var s = this.number;
                    e =
                      e &&
                      !isNaN(s) &&
                      (null == this.min || this.min >= 0 || this.min <= this.number) &&
                      (null == this.max || this.max <= 0 || this.number <= this.max);
                  }
                  return e && g(l(i.prototype), "doValidate", this).call(this, t);
                },
              },
              {
                key: "doCommit",
                value: function () {
                  if (this.value) {
                    var t = this.number,
                      e = t;
                    null != this.min && (e = Math.max(e, this.min)),
                      null != this.max && (e = Math.min(e, this.max)),
                      e !== t && (this.unmaskedValue = String(e));
                    var s = this.value;
                    this.normalizeZeros && (s = this._normalizeZeros(s)),
                      this.padFractionalZeros && this.scale > 0 && (s = this._padFractionalZeros(s)),
                      (this._value = s);
                  }
                  g(l(i.prototype), "doCommit", this).call(this);
                },
              },
              {
                key: "_normalizeZeros",
                value: function (t) {
                  var e = this._removeThousandsSeparators(t).split(this.radix);
                  return (
                    (e[0] = e[0].replace(/^(\D*)(0*)(\d*)/, function (t, e, i, s) {
                      return e + s;
                    })),
                    t.length && !/\d$/.test(e[0]) && (e[0] = e[0] + "0"),
                    e.length > 1 && ((e[1] = e[1].replace(/0*$/, "")), e[1].length || (e.length = 1)),
                    this._insertThousandsSeparators(e.join(this.radix))
                  );
                },
              },
              {
                key: "_padFractionalZeros",
                value: function (t) {
                  if (!t) return t;
                  var e = t.split(this.radix);
                  return e.length < 2 && e.push(""), (e[1] = e[1].padEnd(this.scale, "0")), e.join(this.radix);
                },
              },
              {
                key: "unmaskedValue",
                get: function () {
                  return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, ".");
                },
                set: function (t) {
                  m(l(i.prototype), "unmaskedValue", t.replace(".", this.radix), this, !0);
                },
              },
              {
                key: "typedValue",
                get: function () {
                  return Number(this.unmaskedValue);
                },
                set: function (t) {
                  m(l(i.prototype), "unmaskedValue", String(t), this, !0);
                },
              },
              {
                key: "number",
                get: function () {
                  return this.typedValue;
                },
                set: function (t) {
                  this.typedValue = t;
                },
              },
              {
                key: "allowNegative",
                get: function () {
                  return this.signed || (null != this.min && this.min < 0) || (null != this.max && this.max < 0);
                },
              },
              {
                key: "typedValueEquals",
                value: function (t) {
                  return (
                    (g(l(i.prototype), "typedValueEquals", this).call(this, t) ||
                      (i.EMPTY_VALUES.includes(t) && i.EMPTY_VALUES.includes(this.typedValue))) &&
                    !(0 === t && "" === this.value)
                  );
                },
              },
            ]),
            i
          );
        })(D);
      (it.DEFAULTS = {
        radix: ",",
        thousandsSeparator: "",
        mapToRadix: ["."],
        scale: 2,
        signed: !1,
        normalizeZeros: !0,
        padFractionalZeros: !1,
      }),
        (it.EMPTY_VALUES = [].concat(
          (function (t) {
            if (Array.isArray(t)) return b(t);
          })((et = D.EMPTY_VALUES)) ||
            (function (t) {
              if (("undefined" != typeof Symbol && null != t[Symbol.iterator]) || null != t["@@iterator"])
                return Array.from(t);
            })(et) ||
            x(et) ||
            (function () {
              throw new TypeError(
                "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
              );
            })(),
          [0]
        )),
        (F.MaskedNumber = it);
      var st = (function (t) {
        o(i, t);
        var e = u(i);
        function i() {
          return a(this, i), e.apply(this, arguments);
        }
        return (
          r(i, [
            {
              key: "_update",
              value: function (t) {
                t.mask && (t.validate = t.mask), g(l(i.prototype), "_update", this).call(this, t);
              },
            },
          ]),
          i
        );
      })(D);
      F.MaskedFunction = st;
      var at = ["compiledMasks", "currentMaskRef", "currentMask"],
        nt = (function (t) {
          o(i, t);
          var e = u(i);
          function i(t) {
            var s;
            return a(this, i), ((s = e.call(this, Object.assign({}, i.DEFAULTS, t))).currentMask = null), s;
          }
          return (
            r(i, [
              {
                key: "_update",
                value: function (t) {
                  g(l(i.prototype), "_update", this).call(this, t),
                    "mask" in t &&
                      (this.compiledMasks = Array.isArray(t.mask)
                        ? t.mask.map(function (t) {
                            return N(t);
                          })
                        : []);
                },
              },
              {
                key: "_appendCharRaw",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    i = this._applyDispatch(t, e);
                  return this.currentMask && i.aggregate(this.currentMask._appendChar(t, this.currentMaskFlags(e))), i;
                },
              },
              {
                key: "_applyDispatch",
                value: function () {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    i = e.tail && null != e._beforeTailState ? e._beforeTailState._value : this.value,
                    s = this.rawInputValue,
                    a = e.tail && null != e._beforeTailState ? e._beforeTailState._rawInputValue : s,
                    n = s.slice(a.length),
                    r = this.currentMask,
                    o = new y(),
                    l = null == r ? void 0 : r.state;
                  if (((this.currentMask = this.doDispatch(t, Object.assign({}, e))), this.currentMask))
                    if (this.currentMask !== r) {
                      if ((this.currentMask.reset(), a)) {
                        var c = this.currentMask.append(a, { raw: !0 });
                        o.tailShift = c.inserted.length - i.length;
                      }
                      n && (o.tailShift += this.currentMask.append(n, { raw: !0, tail: !0 }).tailShift);
                    } else this.currentMask.state = l;
                  return o;
                },
              },
              {
                key: "_appendPlaceholder",
                value: function () {
                  var t = this._applyDispatch.apply(this, arguments);
                  return this.currentMask && t.aggregate(this.currentMask._appendPlaceholder()), t;
                },
              },
              {
                key: "_appendEager",
                value: function () {
                  var t = this._applyDispatch.apply(this, arguments);
                  return this.currentMask && t.aggregate(this.currentMask._appendEager()), t;
                },
              },
              {
                key: "currentMaskFlags",
                value: function (t) {
                  var e, i;
                  return Object.assign({}, t, {
                    _beforeTailState:
                      ((null === (e = t._beforeTailState) || void 0 === e ? void 0 : e.currentMaskRef) ===
                        this.currentMask &&
                        (null === (i = t._beforeTailState) || void 0 === i ? void 0 : i.currentMask)) ||
                      t._beforeTailState,
                  });
                },
              },
              {
                key: "doDispatch",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                  return this.dispatch(t, this, e);
                },
              },
              {
                key: "doValidate",
                value: function (t) {
                  return (
                    g(l(i.prototype), "doValidate", this).call(this, t) &&
                    (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(t)))
                  );
                },
              },
              {
                key: "doPrepare",
                value: function (t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    s = P(g(l(i.prototype), "doPrepare", this).call(this, t, e)),
                    a = v(s, 2),
                    n = a[0],
                    r = a[1];
                  if (this.currentMask) {
                    var o,
                      c = P(g(l(i.prototype), "doPrepare", this).call(this, n, this.currentMaskFlags(e))),
                      h = v(c, 2);
                    (n = h[0]), (o = h[1]), (r = r.aggregate(o));
                  }
                  return [n, r];
                },
              },
              {
                key: "reset",
                value: function () {
                  var t;
                  null === (t = this.currentMask) || void 0 === t || t.reset(),
                    this.compiledMasks.forEach(function (t) {
                      return t.reset();
                    });
                },
              },
              {
                key: "value",
                get: function () {
                  return this.currentMask ? this.currentMask.value : "";
                },
                set: function (t) {
                  m(l(i.prototype), "value", t, this, !0);
                },
              },
              {
                key: "unmaskedValue",
                get: function () {
                  return this.currentMask ? this.currentMask.unmaskedValue : "";
                },
                set: function (t) {
                  m(l(i.prototype), "unmaskedValue", t, this, !0);
                },
              },
              {
                key: "typedValue",
                get: function () {
                  return this.currentMask ? this.currentMask.typedValue : "";
                },
                set: function (t) {
                  var e = String(t);
                  this.currentMask && ((this.currentMask.typedValue = t), (e = this.currentMask.unmaskedValue)),
                    (this.unmaskedValue = e);
                },
              },
              {
                key: "isComplete",
                get: function () {
                  var t;
                  return Boolean(null === (t = this.currentMask) || void 0 === t ? void 0 : t.isComplete);
                },
              },
              {
                key: "isFilled",
                get: function () {
                  var t;
                  return Boolean(null === (t = this.currentMask) || void 0 === t ? void 0 : t.isFilled);
                },
              },
              {
                key: "remove",
                value: function () {
                  var t,
                    e = new y();
                  return (
                    this.currentMask &&
                      e.aggregate((t = this.currentMask).remove.apply(t, arguments)).aggregate(this._applyDispatch()),
                    e
                  );
                },
              },
              {
                key: "state",
                get: function () {
                  var t;
                  return Object.assign({}, g(l(i.prototype), "state", this), {
                    _rawInputValue: this.rawInputValue,
                    compiledMasks: this.compiledMasks.map(function (t) {
                      return t.state;
                    }),
                    currentMaskRef: this.currentMask,
                    currentMask: null === (t = this.currentMask) || void 0 === t ? void 0 : t.state,
                  });
                },
                set: function (t) {
                  var e = t.compiledMasks,
                    s = t.currentMaskRef,
                    a = t.currentMask,
                    n = h(t, at);
                  this.compiledMasks.forEach(function (t, i) {
                    return (t.state = e[i]);
                  }),
                    null != s && ((this.currentMask = s), (this.currentMask.state = a)),
                    m(l(i.prototype), "state", n, this, !0);
                },
              },
              {
                key: "extractInput",
                value: function () {
                  var t;
                  return this.currentMask ? (t = this.currentMask).extractInput.apply(t, arguments) : "";
                },
              },
              {
                key: "extractTail",
                value: function () {
                  for (var t, e, s = arguments.length, a = new Array(s), n = 0; n < s; n++) a[n] = arguments[n];
                  return this.currentMask
                    ? (t = this.currentMask).extractTail.apply(t, a)
                    : (e = g(l(i.prototype), "extractTail", this)).call.apply(e, [this].concat(a));
                },
              },
              {
                key: "doCommit",
                value: function () {
                  this.currentMask && this.currentMask.doCommit(), g(l(i.prototype), "doCommit", this).call(this);
                },
              },
              {
                key: "nearestInputPos",
                value: function () {
                  for (var t, e, s = arguments.length, a = new Array(s), n = 0; n < s; n++) a[n] = arguments[n];
                  return this.currentMask
                    ? (t = this.currentMask).nearestInputPos.apply(t, a)
                    : (e = g(l(i.prototype), "nearestInputPos", this)).call.apply(e, [this].concat(a));
                },
              },
              {
                key: "overwrite",
                get: function () {
                  return this.currentMask ? this.currentMask.overwrite : g(l(i.prototype), "overwrite", this);
                },
                set: function (t) {
                  console.warn('"overwrite" option is not available in dynamic mask, use this option in siblings');
                },
              },
              {
                key: "eager",
                get: function () {
                  return this.currentMask ? this.currentMask.eager : g(l(i.prototype), "eager", this);
                },
                set: function (t) {
                  console.warn('"eager" option is not available in dynamic mask, use this option in siblings');
                },
              },
              {
                key: "maskEquals",
                value: function (t) {
                  return (
                    Array.isArray(t) &&
                    this.compiledMasks.every(function (e, i) {
                      var s;
                      return e.maskEquals(null === (s = t[i]) || void 0 === s ? void 0 : s.mask);
                    })
                  );
                },
              },
              {
                key: "typedValueEquals",
                value: function (t) {
                  var e;
                  return Boolean(null === (e = this.currentMask) || void 0 === e ? void 0 : e.typedValueEquals(t));
                },
              },
            ]),
            i
          );
        })(D);
      (nt.DEFAULTS = {
        dispatch: function (t, e, i) {
          if (e.compiledMasks.length) {
            var s = e.rawInputValue,
              a = e.compiledMasks.map(function (a, n) {
                return (
                  a.reset(),
                  a.append(s, { raw: !0 }),
                  a.append(t, e.currentMaskFlags(i)),
                  { weight: a.rawInputValue.length, index: n }
                );
              });
            return (
              a.sort(function (t, e) {
                return e.weight - t.weight;
              }),
              e.compiledMasks[a[0].index]
            );
          }
        },
      }),
        (F.MaskedDynamic = nt);
      var rt = { MASKED: "value", UNMASKED: "unmaskedValue", TYPED: "typedValue" };
      function ot(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : rt.MASKED,
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : rt.MASKED,
          s = N(t);
        return function (t) {
          return s.runIsolated(function (s) {
            return (s[e] = t), s[i];
          });
        };
      }
      (F.PIPE_TYPE = rt),
        (F.createPipe = ot),
        (F.pipe = function (t) {
          for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), s = 1; s < e; s++) i[s - 1] = arguments[s];
          return ot.apply(void 0, i)(t);
        });
      try {
        globalThis.IMask = F;
      } catch (t) {}
    },
    685: function (t, e, i) {
      "use strict";
      i.d(e, {
        Iq: function () {
          return h;
        },
      });
      var s,
        a = function () {
          return (
            (a =
              Object.assign ||
              function (t) {
                for (var e, i = 1, s = arguments.length; i < s; i++)
                  for (var a in (e = arguments[i])) Object.prototype.hasOwnProperty.call(e, a) && (t[a] = e[a]);
                return t;
              }),
            a.apply(this, arguments)
          );
        },
        n = (function () {
          function t(t) {
            (this.options = t), (this.listeners = {});
          }
          return (
            (t.prototype.on = function (t, e) {
              var i = this.listeners[t] || [];
              this.listeners[t] = i.concat([e]);
            }),
            (t.prototype.triggerEvent = function (t, e) {
              var i = this;
              (this.listeners[t] || []).forEach(function (t) {
                return t({ target: i, event: e });
              });
            }),
            t
          );
        })();
      !(function (t) {
        (t[(t.Add = 0)] = "Add"), (t[(t.Remove = 1)] = "Remove");
      })(s || (s = {}));
      var r,
        o = (function () {
          function t() {
            this.notifications = [];
          }
          return (
            (t.prototype.push = function (t) {
              this.notifications.push(t), this.updateFn(t, s.Add, this.notifications);
            }),
            (t.prototype.splice = function (t, e) {
              var i = this.notifications.splice(t, e)[0];
              return this.updateFn(i, s.Remove, this.notifications), i;
            }),
            (t.prototype.indexOf = function (t) {
              return this.notifications.indexOf(t);
            }),
            (t.prototype.onUpdate = function (t) {
              this.updateFn = t;
            }),
            t
          );
        })();
      !(function (t) {
        (t.Dismiss = "dismiss"), (t.Click = "click");
      })(r || (r = {}));
      var l = {
          types: [
            {
              type: "success",
              className: "notyf__toast--success",
              backgroundColor: "#3dc763",
              icon: { className: "notyf__icon--success", tagName: "i" },
            },
            {
              type: "error",
              className: "notyf__toast--error",
              backgroundColor: "#ed3d3d",
              icon: { className: "notyf__icon--error", tagName: "i" },
            },
          ],
          duration: 2e3,
          ripple: !0,
          position: { x: "right", y: "bottom" },
          dismissible: !1,
        },
        c = (function () {
          function t() {
            (this.notifications = []),
              (this.events = {}),
              (this.X_POSITION_FLEX_MAP = { left: "flex-start", center: "center", right: "flex-end" }),
              (this.Y_POSITION_FLEX_MAP = { top: "flex-start", center: "center", bottom: "flex-end" });
            var t = document.createDocumentFragment(),
              e = this._createHTMLElement({ tagName: "div", className: "notyf" });
            t.appendChild(e),
              document.body.appendChild(t),
              (this.container = e),
              (this.animationEndEventName = this._getAnimationEndEventName()),
              this._createA11yContainer();
          }
          return (
            (t.prototype.on = function (t, e) {
              var i;
              this.events = a(a({}, this.events), (((i = {})[t] = e), i));
            }),
            (t.prototype.update = function (t, e) {
              e === s.Add ? this.addNotification(t) : e === s.Remove && this.removeNotification(t);
            }),
            (t.prototype.removeNotification = function (t) {
              var e,
                i,
                s = this,
                a = this._popRenderedNotification(t);
              a &&
                ((e = a.node).classList.add("notyf__toast--disappear"),
                e.addEventListener(
                  this.animationEndEventName,
                  (i = function (t) {
                    t.target === e && (e.removeEventListener(s.animationEndEventName, i), s.container.removeChild(e));
                  })
                ));
            }),
            (t.prototype.addNotification = function (t) {
              var e = this._renderNotification(t);
              this.notifications.push({ notification: t, node: e }),
                this._announce(t.options.message || "Notification");
            }),
            (t.prototype._renderNotification = function (t) {
              var e,
                i = this._buildNotificationCard(t),
                s = t.options.className;
              return s && (e = i.classList).add.apply(e, s.split(" ")), this.container.appendChild(i), i;
            }),
            (t.prototype._popRenderedNotification = function (t) {
              for (var e = -1, i = 0; i < this.notifications.length && e < 0; i++)
                this.notifications[i].notification === t && (e = i);
              if (-1 !== e) return this.notifications.splice(e, 1)[0];
            }),
            (t.prototype.getXPosition = function (t) {
              var e;
              return (null === (e = null == t ? void 0 : t.position) || void 0 === e ? void 0 : e.x) || "right";
            }),
            (t.prototype.getYPosition = function (t) {
              var e;
              return (null === (e = null == t ? void 0 : t.position) || void 0 === e ? void 0 : e.y) || "bottom";
            }),
            (t.prototype.adjustContainerAlignment = function (t) {
              var e = this.X_POSITION_FLEX_MAP[this.getXPosition(t)],
                i = this.Y_POSITION_FLEX_MAP[this.getYPosition(t)],
                s = this.container.style;
              s.setProperty("justify-content", i), s.setProperty("align-items", e);
            }),
            (t.prototype._buildNotificationCard = function (t) {
              var e = this,
                i = t.options,
                s = i.icon;
              this.adjustContainerAlignment(i);
              var a = this._createHTMLElement({ tagName: "div", className: "notyf__toast" }),
                n = this._createHTMLElement({ tagName: "div", className: "notyf__ripple" }),
                o = this._createHTMLElement({ tagName: "div", className: "notyf__wrapper" }),
                l = this._createHTMLElement({ tagName: "div", className: "notyf__message" });
              l.innerHTML = i.message || "";
              var c = i.background || i.backgroundColor;
              if (s) {
                var h = this._createHTMLElement({ tagName: "div", className: "notyf__icon" });
                if (
                  (("string" == typeof s || s instanceof String) && (h.innerHTML = new String(s).valueOf()),
                  "object" == typeof s)
                ) {
                  var d = s.tagName,
                    u = void 0 === d ? "i" : d,
                    p = s.className,
                    g = s.text,
                    f = s.color,
                    m = void 0 === f ? c : f,
                    v = this._createHTMLElement({ tagName: u, className: p, text: g });
                  m && (v.style.color = m), h.appendChild(v);
                }
                o.appendChild(h);
              }
              if (
                (o.appendChild(l),
                a.appendChild(o),
                c && (i.ripple ? ((n.style.background = c), a.appendChild(n)) : (a.style.background = c)),
                i.dismissible)
              ) {
                var x = this._createHTMLElement({ tagName: "div", className: "notyf__dismiss" }),
                  b = this._createHTMLElement({ tagName: "button", className: "notyf__dismiss-btn" });
                x.appendChild(b),
                  o.appendChild(x),
                  a.classList.add("notyf__toast--dismissible"),
                  b.addEventListener("click", function (i) {
                    var s, a;
                    null === (a = (s = e.events)[r.Dismiss]) || void 0 === a || a.call(s, { target: t, event: i }),
                      i.stopPropagation();
                  });
              }
              a.addEventListener("click", function (i) {
                var s, a;
                return null === (a = (s = e.events)[r.Click]) || void 0 === a
                  ? void 0
                  : a.call(s, { target: t, event: i });
              });
              var y = "top" === this.getYPosition(i) ? "upper" : "lower";
              return a.classList.add("notyf__toast--" + y), a;
            }),
            (t.prototype._createHTMLElement = function (t) {
              var e = t.tagName,
                i = t.className,
                s = t.text,
                a = document.createElement(e);
              return i && (a.className = i), (a.textContent = s || null), a;
            }),
            (t.prototype._createA11yContainer = function () {
              var t = this._createHTMLElement({ tagName: "div", className: "notyf-announcer" });
              t.setAttribute("aria-atomic", "true"),
                t.setAttribute("aria-live", "polite"),
                (t.style.border = "0"),
                (t.style.clip = "rect(0 0 0 0)"),
                (t.style.height = "1px"),
                (t.style.margin = "-1px"),
                (t.style.overflow = "hidden"),
                (t.style.padding = "0"),
                (t.style.position = "absolute"),
                (t.style.width = "1px"),
                (t.style.outline = "0"),
                document.body.appendChild(t),
                (this.a11yContainer = t);
            }),
            (t.prototype._announce = function (t) {
              var e = this;
              (this.a11yContainer.textContent = ""),
                setTimeout(function () {
                  e.a11yContainer.textContent = t;
                }, 100);
            }),
            (t.prototype._getAnimationEndEventName = function () {
              var t,
                e = document.createElement("_fake"),
                i = {
                  MozTransition: "animationend",
                  OTransition: "oAnimationEnd",
                  WebkitTransition: "webkitAnimationEnd",
                  transition: "animationend",
                };
              for (t in i) if (void 0 !== e.style[t]) return i[t];
              return "animationend";
            }),
            t
          );
        })(),
        h = (function () {
          function t(t) {
            var e = this;
            (this.dismiss = this._removeNotification), (this.notifications = new o()), (this.view = new c());
            var i = this.registerTypes(t);
            (this.options = a(a({}, l), t)),
              (this.options.types = i),
              this.notifications.onUpdate(function (t, i) {
                return e.view.update(t, i);
              }),
              this.view.on(r.Dismiss, function (t) {
                var i = t.target,
                  s = t.event;
                e._removeNotification(i), i.triggerEvent(r.Dismiss, s);
              }),
              this.view.on(r.Click, function (t) {
                var e = t.target,
                  i = t.event;
                return e.triggerEvent(r.Click, i);
              });
          }
          return (
            (t.prototype.error = function (t) {
              var e = this.normalizeOptions("error", t);
              return this.open(e);
            }),
            (t.prototype.success = function (t) {
              var e = this.normalizeOptions("success", t);
              return this.open(e);
            }),
            (t.prototype.open = function (t) {
              var e =
                  this.options.types.find(function (e) {
                    return e.type === t.type;
                  }) || {},
                i = a(a({}, e), t);
              this.assignProps(["ripple", "position", "dismissible"], i);
              var s = new n(i);
              return this._pushNotification(s), s;
            }),
            (t.prototype.dismissAll = function () {
              for (; this.notifications.splice(0, 1); );
            }),
            (t.prototype.assignProps = function (t, e) {
              var i = this;
              t.forEach(function (t) {
                e[t] = null == e[t] ? i.options[t] : e[t];
              });
            }),
            (t.prototype._pushNotification = function (t) {
              var e = this;
              this.notifications.push(t);
              var i = void 0 !== t.options.duration ? t.options.duration : this.options.duration;
              i &&
                setTimeout(function () {
                  return e._removeNotification(t);
                }, i);
            }),
            (t.prototype._removeNotification = function (t) {
              var e = this.notifications.indexOf(t);
              -1 !== e && this.notifications.splice(e, 1);
            }),
            (t.prototype.normalizeOptions = function (t, e) {
              var i = { type: t };
              return "string" == typeof e ? (i.message = e) : "object" == typeof e && (i = a(a({}, i), e)), i;
            }),
            (t.prototype.registerTypes = function (t) {
              var e = ((t && t.types) || []).slice();
              return l.types
                .map(function (t) {
                  var i = -1;
                  e.forEach(function (e, s) {
                    e.type === t.type && (i = s);
                  });
                  var s = -1 !== i ? e.splice(i, 1)[0] : {};
                  return a(a({}, t), s);
                })
                .concat(e);
            }),
            t
          );
        })();
    },
    418: function (t, e, i) {
      "use strict";
      i.d(e, {
        Z: function () {
          return r;
        },
      });
      let s = { easing: "ease", duration: 250, fill: "backwards", display: "block", overflow: "hidden" },
        a = ["overflow", "display"],
        n = (t, e) => {
          let i = Object.assign({}, s, e),
            n = i.display,
            r = (e) => (t.style.display = e),
            o = () => t.clientHeight + "px",
            l = (e) => (t.style.overflow = e ? i.overflow : ""),
            c = () => t.getAnimations(),
            h = async (e) => {
              let s = c().map((t) => t.finish());
              var h;
              return (
                await ((h = async (s) => {
                  let c = e ? o() : "0px";
                  e && r(n),
                    l(!0),
                    await ((e, s) => {
                      var n;
                      a.forEach((t) => delete i[t]);
                      let r = o(),
                        l = [r, s].map((t) => ({ height: t, paddingTop: "0px", paddingBottom: "0px" })),
                        { paddingTop: c, paddingBottom: h } = window.getComputedStyle(t);
                      (l[0].paddingTop = c),
                        (l[0].paddingBottom = h),
                        e && ((l[0].height = r), l.reverse()),
                        (null == (n = window.matchMedia("(prefers-reduced-motion: reduce)")) ? void 0 : n.matches) &&
                          (i.duration = 0);
                      let d = t.animate(l, i);
                      return (d.id = (+e).toString()), d;
                    })(e, c).finished,
                    l(!1),
                    e || r("none"),
                    s();
                }),
                new Promise((t) => {
                  requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                      h(t);
                    });
                  });
                })),
                s.length ? null : e
              );
            },
            d = async () => h(!1),
            u = async () => h(!0);
          return {
            up: d,
            down: u,
            toggle: async () => {
              var e;
              let i = null == (e = c()[0]) ? void 0 : e.id;
              return ((i ? "1" === i : t.offsetHeight) ? d : u)();
            },
          };
        },
        r = (t, e = {}) => n(t, e).toggle();
    },
    192: function (t) {
      var e;
      "undefined" != typeof self && self,
        (e = () =>
          (() => {
            var t = {
                75: function (t) {
                  (function () {
                    var e, i, s, a, n, r;
                    "undefined" != typeof performance && null !== performance && performance.now
                      ? (t.exports = function () {
                          return performance.now();
                        })
                      : "undefined" != typeof process && null !== process && process.hrtime
                      ? ((t.exports = function () {
                          return (e() - n) / 1e6;
                        }),
                        (i = process.hrtime),
                        (a = (e = function () {
                          var t;
                          return 1e9 * (t = i())[0] + t[1];
                        })()),
                        (r = 1e9 * process.uptime()),
                        (n = a - r))
                      : Date.now
                      ? ((t.exports = function () {
                          return Date.now() - s;
                        }),
                        (s = Date.now()))
                      : ((t.exports = function () {
                          return new Date().getTime() - s;
                        }),
                        (s = new Date().getTime()));
                  }).call(this);
                },
                4087: (t, e, i) => {
                  for (
                    var s = i(75),
                      a = "undefined" == typeof window ? i.g : window,
                      n = ["moz", "webkit"],
                      r = "AnimationFrame",
                      o = a["request" + r],
                      l = a["cancel" + r] || a["cancelRequest" + r],
                      c = 0;
                    !o && c < n.length;
                    c++
                  )
                    (o = a[n[c] + "Request" + r]), (l = a[n[c] + "Cancel" + r] || a[n[c] + "CancelRequest" + r]);
                  if (!o || !l) {
                    var h = 0,
                      d = 0,
                      u = [];
                    (o = function (t) {
                      if (0 === u.length) {
                        var e = s(),
                          i = Math.max(0, 16.666666666666668 - (e - h));
                        (h = i + e),
                          setTimeout(function () {
                            var t = u.slice(0);
                            u.length = 0;
                            for (var e = 0; e < t.length; e++)
                              if (!t[e].cancelled)
                                try {
                                  t[e].callback(h);
                                } catch (t) {
                                  setTimeout(function () {
                                    throw t;
                                  }, 0);
                                }
                          }, Math.round(i));
                      }
                      return u.push({ handle: ++d, callback: t, cancelled: !1 }), d;
                    }),
                      (l = function (t) {
                        for (var e = 0; e < u.length; e++) u[e].handle === t && (u[e].cancelled = !0);
                      });
                  }
                  (t.exports = function (t) {
                    return o.call(a, t);
                  }),
                    (t.exports.cancel = function () {
                      l.apply(a, arguments);
                    }),
                    (t.exports.polyfill = function (t) {
                      t || (t = a), (t.requestAnimationFrame = o), (t.cancelAnimationFrame = l);
                    });
                },
              },
              e = {};
            function i(s) {
              var a = e[s];
              if (void 0 !== a) return a.exports;
              var n = (e[s] = { exports: {} });
              return t[s].call(n.exports, n, n.exports, i), n.exports;
            }
            (i.n = (t) => {
              var e = t && t.__esModule ? () => t.default : () => t;
              return i.d(e, { a: e }), e;
            }),
              (i.d = (t, e) => {
                for (var s in e) i.o(e, s) && !i.o(t, s) && Object.defineProperty(t, s, { enumerable: !0, get: e[s] });
              }),
              (i.g = (function () {
                if ("object" == typeof globalThis) return globalThis;
                try {
                  return this || new Function("return this")();
                } catch (t) {
                  if ("object" == typeof window) return window;
                }
              })()),
              (i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e));
            var s = {};
            return (
              (() => {
                "use strict";
                i.d(s, { default: () => C });
                var t = i(4087),
                  e = i.n(t);
                const a = function (t) {
                    return new RegExp(/<[a-z][\s\S]*>/i).test(t);
                  },
                  n = function (t) {
                    var e = document.createElement("div");
                    return (e.innerHTML = t), e.childNodes;
                  },
                  r = function (t, e) {
                    return Math.floor(Math.random() * (e - t + 1)) + t;
                  };
                var o = "TYPE_CHARACTER",
                  l = "REMOVE_CHARACTER",
                  c = "REMOVE_ALL",
                  h = "REMOVE_LAST_VISIBLE_NODE",
                  d = "PAUSE_FOR",
                  u = "CALL_FUNCTION",
                  p = "ADD_HTML_TAG_ELEMENT",
                  g = "CHANGE_DELETE_SPEED",
                  f = "CHANGE_DELAY",
                  m = "CHANGE_CURSOR",
                  v = "PASTE_STRING",
                  x = "HTML_TAG";
                function b(t, e) {
                  var i = Object.keys(t);
                  if (Object.getOwnPropertySymbols) {
                    var s = Object.getOwnPropertySymbols(t);
                    e &&
                      (s = s.filter(function (e) {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable;
                      })),
                      i.push.apply(i, s);
                  }
                  return i;
                }
                function y(t) {
                  for (var e = 1; e < arguments.length; e++) {
                    var i = null != arguments[e] ? arguments[e] : {};
                    e % 2
                      ? b(Object(i), !0).forEach(function (e) {
                          S(t, e, i[e]);
                        })
                      : Object.getOwnPropertyDescriptors
                      ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i))
                      : b(Object(i)).forEach(function (e) {
                          Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));
                        });
                  }
                  return t;
                }
                function w(t) {
                  return (
                    (function (t) {
                      if (Array.isArray(t)) return k(t);
                    })(t) ||
                    (function (t) {
                      if (("undefined" != typeof Symbol && null != t[Symbol.iterator]) || null != t["@@iterator"])
                        return Array.from(t);
                    })(t) ||
                    (function (t, e) {
                      if (t) {
                        if ("string" == typeof t) return k(t, e);
                        var i = Object.prototype.toString.call(t).slice(8, -1);
                        return (
                          "Object" === i && t.constructor && (i = t.constructor.name),
                          "Map" === i || "Set" === i
                            ? Array.from(t)
                            : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)
                            ? k(t, e)
                            : void 0
                        );
                      }
                    })(t) ||
                    (function () {
                      throw new TypeError(
                        "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                      );
                    })()
                  );
                }
                function k(t, e) {
                  (null == e || e > t.length) && (e = t.length);
                  for (var i = 0, s = new Array(e); i < e; i++) s[i] = t[i];
                  return s;
                }
                function S(t, e, i) {
                  return (
                    e in t
                      ? Object.defineProperty(t, e, { value: i, enumerable: !0, configurable: !0, writable: !0 })
                      : (t[e] = i),
                    t
                  );
                }
                const C = (function () {
                  function i(s, b) {
                    var k = this;
                    if (
                      ((function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                      })(this, i),
                      S(this, "state", {
                        cursorAnimation: null,
                        lastFrameTime: null,
                        pauseUntil: null,
                        eventQueue: [],
                        eventLoop: null,
                        eventLoopPaused: !1,
                        reverseCalledEvents: [],
                        calledEvents: [],
                        visibleNodes: [],
                        initialOptions: null,
                        elements: {
                          container: null,
                          wrapper: document.createElement("span"),
                          cursor: document.createElement("span"),
                        },
                      }),
                      S(this, "options", {
                        strings: null,
                        cursor: "|",
                        delay: "natural",
                        pauseFor: 1500,
                        deleteSpeed: "natural",
                        loop: !1,
                        autoStart: !1,
                        devMode: !1,
                        skipAddStyles: !1,
                        wrapperClassName: "Typewriter__wrapper",
                        cursorClassName: "Typewriter__cursor",
                        stringSplitter: null,
                        onCreateTextNode: null,
                        onRemoveNode: null,
                      }),
                      S(this, "setupWrapperElement", function () {
                        k.state.elements.container &&
                          ((k.state.elements.wrapper.className = k.options.wrapperClassName),
                          (k.state.elements.cursor.className = k.options.cursorClassName),
                          (k.state.elements.cursor.innerHTML = k.options.cursor),
                          (k.state.elements.container.innerHTML = ""),
                          k.state.elements.container.appendChild(k.state.elements.wrapper),
                          k.state.elements.container.appendChild(k.state.elements.cursor));
                      }),
                      S(this, "start", function () {
                        return (k.state.eventLoopPaused = !1), k.runEventLoop(), k;
                      }),
                      S(this, "pause", function () {
                        return (k.state.eventLoopPaused = !0), k;
                      }),
                      S(this, "stop", function () {
                        return k.state.eventLoop && ((0, t.cancel)(k.state.eventLoop), (k.state.eventLoop = null)), k;
                      }),
                      S(this, "pauseFor", function (t) {
                        return k.addEventToQueue(d, { ms: t }), k;
                      }),
                      S(this, "typeOutAllStrings", function () {
                        return "string" == typeof k.options.strings
                          ? (k.typeString(k.options.strings).pauseFor(k.options.pauseFor), k)
                          : (k.options.strings.forEach(function (t) {
                              k.typeString(t).pauseFor(k.options.pauseFor).deleteAll(k.options.deleteSpeed);
                            }),
                            k);
                      }),
                      S(this, "typeString", function (t) {
                        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                        if (a(t)) return k.typeOutHTMLString(t, e);
                        if (t) {
                          var i = k.options || {},
                            s = i.stringSplitter,
                            n = "function" == typeof s ? s(t) : t.split("");
                          k.typeCharacters(n, e);
                        }
                        return k;
                      }),
                      S(this, "pasteString", function (t) {
                        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                        return a(t)
                          ? k.typeOutHTMLString(t, e, !0)
                          : (t && k.addEventToQueue(v, { character: t, node: e }), k);
                      }),
                      S(this, "typeOutHTMLString", function (t) {
                        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                          i = arguments.length > 2 ? arguments[2] : void 0,
                          s = n(t);
                        if (s.length > 0)
                          for (var a = 0; a < s.length; a++) {
                            var r = s[a],
                              o = r.innerHTML;
                            r && 3 !== r.nodeType
                              ? ((r.innerHTML = ""),
                                k.addEventToQueue(p, { node: r, parentNode: e }),
                                i ? k.pasteString(o, r) : k.typeString(o, r))
                              : r.textContent && (i ? k.pasteString(r.textContent, e) : k.typeString(r.textContent, e));
                          }
                        return k;
                      }),
                      S(this, "deleteAll", function () {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "natural";
                        return k.addEventToQueue(c, { speed: t }), k;
                      }),
                      S(this, "changeDeleteSpeed", function (t) {
                        if (!t) throw new Error("Must provide new delete speed");
                        return k.addEventToQueue(g, { speed: t }), k;
                      }),
                      S(this, "changeDelay", function (t) {
                        if (!t) throw new Error("Must provide new delay");
                        return k.addEventToQueue(f, { delay: t }), k;
                      }),
                      S(this, "changeCursor", function (t) {
                        if (!t) throw new Error("Must provide new cursor");
                        return k.addEventToQueue(m, { cursor: t }), k;
                      }),
                      S(this, "deleteChars", function (t) {
                        if (!t) throw new Error("Must provide amount of characters to delete");
                        for (var e = 0; e < t; e++) k.addEventToQueue(l);
                        return k;
                      }),
                      S(this, "callFunction", function (t, e) {
                        if (!t || "function" != typeof t) throw new Error("Callbak must be a function");
                        return k.addEventToQueue(u, { cb: t, thisArg: e }), k;
                      }),
                      S(this, "typeCharacters", function (t) {
                        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                        if (!t || !Array.isArray(t)) throw new Error("Characters must be an array");
                        return (
                          t.forEach(function (t) {
                            k.addEventToQueue(o, { character: t, node: e });
                          }),
                          k
                        );
                      }),
                      S(this, "removeCharacters", function (t) {
                        if (!t || !Array.isArray(t)) throw new Error("Characters must be an array");
                        return (
                          t.forEach(function () {
                            k.addEventToQueue(l);
                          }),
                          k
                        );
                      }),
                      S(this, "addEventToQueue", function (t, e) {
                        var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        return k.addEventToStateProperty(t, e, i, "eventQueue");
                      }),
                      S(this, "addReverseCalledEvent", function (t, e) {
                        var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                          s = k.options.loop;
                        return s ? k.addEventToStateProperty(t, e, i, "reverseCalledEvents") : k;
                      }),
                      S(this, "addEventToStateProperty", function (t, e) {
                        var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                          s = arguments.length > 3 ? arguments[3] : void 0,
                          a = { eventName: t, eventArgs: e || {} };
                        return (k.state[s] = i ? [a].concat(w(k.state[s])) : [].concat(w(k.state[s]), [a])), k;
                      }),
                      S(this, "runEventLoop", function () {
                        k.state.lastFrameTime || (k.state.lastFrameTime = Date.now());
                        var t = Date.now(),
                          i = t - k.state.lastFrameTime;
                        if (!k.state.eventQueue.length) {
                          if (!k.options.loop) return;
                          (k.state.eventQueue = w(k.state.calledEvents)),
                            (k.state.calledEvents = []),
                            (k.options = y({}, k.state.initialOptions));
                        }
                        if (((k.state.eventLoop = e()(k.runEventLoop)), !k.state.eventLoopPaused)) {
                          if (k.state.pauseUntil) {
                            if (t < k.state.pauseUntil) return;
                            k.state.pauseUntil = null;
                          }
                          var s,
                            a = w(k.state.eventQueue),
                            n = a.shift();
                          if (
                            !(
                              i <=
                              (s =
                                n.eventName === h || n.eventName === l
                                  ? "natural" === k.options.deleteSpeed
                                    ? r(40, 80)
                                    : k.options.deleteSpeed
                                  : "natural" === k.options.delay
                                  ? r(120, 160)
                                  : k.options.delay)
                            )
                          ) {
                            var b = n.eventName,
                              S = n.eventArgs;
                            switch ((k.logInDevMode({ currentEvent: n, state: k.state, delay: s }), b)) {
                              case v:
                              case o:
                                var C = S.character,
                                  A = S.node,
                                  E = document.createTextNode(C),
                                  T = E;
                                k.options.onCreateTextNode &&
                                  "function" == typeof k.options.onCreateTextNode &&
                                  (T = k.options.onCreateTextNode(C, E)),
                                  T && (A ? A.appendChild(T) : k.state.elements.wrapper.appendChild(T)),
                                  (k.state.visibleNodes = [].concat(w(k.state.visibleNodes), [
                                    { type: "TEXT_NODE", character: C, node: T },
                                  ]));
                                break;
                              case l:
                                a.unshift({ eventName: h, eventArgs: { removingCharacterNode: !0 } });
                                break;
                              case d:
                                var L = n.eventArgs.ms;
                                k.state.pauseUntil = Date.now() + parseInt(L);
                                break;
                              case u:
                                var P = n.eventArgs,
                                  M = P.cb,
                                  O = P.thisArg;
                                M.call(O, { elements: k.state.elements });
                                break;
                              case p:
                                var I = n.eventArgs,
                                  F = I.node,
                                  D = I.parentNode;
                                D ? D.appendChild(F) : k.state.elements.wrapper.appendChild(F),
                                  (k.state.visibleNodes = [].concat(w(k.state.visibleNodes), [
                                    { type: x, node: F, parentNode: D || k.state.elements.wrapper },
                                  ]));
                                break;
                              case c:
                                var z = k.state.visibleNodes,
                                  N = S.speed,
                                  R = [];
                                N && R.push({ eventName: g, eventArgs: { speed: N, temp: !0 } });
                                for (var _ = 0, B = z.length; _ < B; _++)
                                  R.push({ eventName: h, eventArgs: { removingCharacterNode: !1 } });
                                N && R.push({ eventName: g, eventArgs: { speed: k.options.deleteSpeed, temp: !0 } }),
                                  a.unshift.apply(a, R);
                                break;
                              case h:
                                var X = n.eventArgs.removingCharacterNode;
                                if (k.state.visibleNodes.length) {
                                  var H = k.state.visibleNodes.pop(),
                                    Y = H.type,
                                    W = H.node,
                                    $ = H.character;
                                  k.options.onRemoveNode &&
                                    "function" == typeof k.options.onRemoveNode &&
                                    k.options.onRemoveNode({ node: W, character: $ }),
                                    W && W.parentNode.removeChild(W),
                                    Y === x && X && a.unshift({ eventName: h, eventArgs: {} });
                                }
                                break;
                              case g:
                                k.options.deleteSpeed = n.eventArgs.speed;
                                break;
                              case f:
                                k.options.delay = n.eventArgs.delay;
                                break;
                              case m:
                                (k.options.cursor = n.eventArgs.cursor),
                                  (k.state.elements.cursor.innerHTML = n.eventArgs.cursor);
                            }
                            k.options.loop &&
                              (n.eventName === h ||
                                (n.eventArgs && n.eventArgs.temp) ||
                                (k.state.calledEvents = [].concat(w(k.state.calledEvents), [n]))),
                              (k.state.eventQueue = a),
                              (k.state.lastFrameTime = t);
                          }
                        }
                      }),
                      s)
                    )
                      if ("string" == typeof s) {
                        var C = document.querySelector(s);
                        if (!C) throw new Error("Could not find container element");
                        this.state.elements.container = C;
                      } else this.state.elements.container = s;
                    b && (this.options = y(y({}, this.options), b)),
                      (this.state.initialOptions = y({}, this.options)),
                      this.init();
                  }
                  var s, b;
                  return (
                    (s = i),
                    (b = [
                      {
                        key: "init",
                        value: function () {
                          var t;
                          this.setupWrapperElement(),
                            this.addEventToQueue(m, { cursor: this.options.cursor }, !0),
                            this.addEventToQueue(c, null, !0),
                            !window ||
                              window.___TYPEWRITER_JS_STYLES_ADDED___ ||
                              this.options.skipAddStyles ||
                              ((t = document.createElement("style")).appendChild(
                                document.createTextNode(
                                  ".Typewriter__cursor{-webkit-animation:Typewriter-cursor 1s infinite;animation:Typewriter-cursor 1s infinite;margin-left:1px}@-webkit-keyframes Typewriter-cursor{0%{opacity:0}50%{opacity:1}100%{opacity:0}}@keyframes Typewriter-cursor{0%{opacity:0}50%{opacity:1}100%{opacity:0}}"
                                )
                              ),
                              document.head.appendChild(t),
                              (window.___TYPEWRITER_JS_STYLES_ADDED___ = !0)),
                            !0 === this.options.autoStart && this.options.strings && this.typeOutAllStrings().start();
                        },
                      },
                      {
                        key: "logInDevMode",
                        value: function (t) {
                          this.options.devMode && console.log(t);
                        },
                      },
                    ]) &&
                      (function (t, e) {
                        for (var i = 0; i < e.length; i++) {
                          var s = e[i];
                          (s.enumerable = s.enumerable || !1),
                            (s.configurable = !0),
                            "value" in s && (s.writable = !0),
                            Object.defineProperty(t, s.key, s);
                        }
                      })(s.prototype, b),
                    Object.defineProperty(s, "prototype", { writable: !1 }),
                    i
                  );
                })();
              })(),
              s.default
            );
          })()),
        (t.exports = e());
    },
    721: function (t, e, i) {
      "use strict";
      function s(t, e) {
        return function () {
          return t.apply(e, arguments);
        };
      }
      i.d(e, {
        ZP: function () {
          return Gt;
        },
      });
      const { toString: a } = Object.prototype,
        { getPrototypeOf: n } = Object,
        r =
          ((o = Object.create(null)),
          (t) => {
            const e = a.call(t);
            return o[e] || (o[e] = e.slice(8, -1).toLowerCase());
          });
      var o;
      const l = (t) => ((t = t.toLowerCase()), (e) => r(e) === t),
        c = (t) => (e) => typeof e === t,
        { isArray: h } = Array,
        d = c("undefined"),
        u = l("ArrayBuffer"),
        p = c("string"),
        g = c("function"),
        f = c("number"),
        m = (t) => null !== t && "object" == typeof t,
        v = (t) => {
          if ("object" !== r(t)) return !1;
          const e = n(t);
          return !(
            (null !== e && e !== Object.prototype && null !== Object.getPrototypeOf(e)) ||
            Symbol.toStringTag in t ||
            Symbol.iterator in t
          );
        },
        x = l("Date"),
        b = l("File"),
        y = l("Blob"),
        w = l("FileList"),
        k = l("URLSearchParams");
      function S(t, e, { allOwnKeys: i = !1 } = {}) {
        if (null == t) return;
        let s, a;
        if (("object" != typeof t && (t = [t]), h(t))) for (s = 0, a = t.length; s < a; s++) e.call(null, t[s], s, t);
        else {
          const a = i ? Object.getOwnPropertyNames(t) : Object.keys(t),
            n = a.length;
          let r;
          for (s = 0; s < n; s++) (r = a[s]), e.call(null, t[r], r, t);
        }
      }
      const C = ((A = "undefined" != typeof Uint8Array && n(Uint8Array)), (t) => A && t instanceof A);
      var A;
      const E = l("HTMLFormElement"),
        T = (
          ({ hasOwnProperty: t }) =>
          (e, i) =>
            t.call(e, i)
        )(Object.prototype),
        L = l("RegExp"),
        P = (t, e) => {
          const i = Object.getOwnPropertyDescriptors(t),
            s = {};
          S(i, (i, a) => {
            !1 !== e(i, a, t) && (s[a] = i);
          }),
            Object.defineProperties(t, s);
        };
      var M = {
        isArray: h,
        isArrayBuffer: u,
        isBuffer: function (t) {
          return (
            null !== t &&
            !d(t) &&
            null !== t.constructor &&
            !d(t.constructor) &&
            g(t.constructor.isBuffer) &&
            t.constructor.isBuffer(t)
          );
        },
        isFormData: (t) => {
          const e = "[object FormData]";
          return (
            t &&
            (("function" == typeof FormData && t instanceof FormData) ||
              a.call(t) === e ||
              (g(t.toString) && t.toString() === e))
          );
        },
        isArrayBufferView: function (t) {
          let e;
          return (
            (e =
              "undefined" != typeof ArrayBuffer && ArrayBuffer.isView
                ? ArrayBuffer.isView(t)
                : t && t.buffer && u(t.buffer)),
            e
          );
        },
        isString: p,
        isNumber: f,
        isBoolean: (t) => !0 === t || !1 === t,
        isObject: m,
        isPlainObject: v,
        isUndefined: d,
        isDate: x,
        isFile: b,
        isBlob: y,
        isRegExp: L,
        isFunction: g,
        isStream: (t) => m(t) && g(t.pipe),
        isURLSearchParams: k,
        isTypedArray: C,
        isFileList: w,
        forEach: S,
        merge: function t() {
          const e = {},
            i = (i, s) => {
              v(e[s]) && v(i) ? (e[s] = t(e[s], i)) : v(i) ? (e[s] = t({}, i)) : h(i) ? (e[s] = i.slice()) : (e[s] = i);
            };
          for (let t = 0, e = arguments.length; t < e; t++) arguments[t] && S(arguments[t], i);
          return e;
        },
        extend: (t, e, i, { allOwnKeys: a } = {}) => (
          S(
            e,
            (e, a) => {
              i && g(e) ? (t[a] = s(e, i)) : (t[a] = e);
            },
            { allOwnKeys: a }
          ),
          t
        ),
        trim: (t) => (t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")),
        stripBOM: (t) => (65279 === t.charCodeAt(0) && (t = t.slice(1)), t),
        inherits: (t, e, i, s) => {
          (t.prototype = Object.create(e.prototype, s)),
            (t.prototype.constructor = t),
            Object.defineProperty(t, "super", { value: e.prototype }),
            i && Object.assign(t.prototype, i);
        },
        toFlatObject: (t, e, i, s) => {
          let a, r, o;
          const l = {};
          if (((e = e || {}), null == t)) return e;
          do {
            for (a = Object.getOwnPropertyNames(t), r = a.length; r-- > 0; )
              (o = a[r]), (s && !s(o, t, e)) || l[o] || ((e[o] = t[o]), (l[o] = !0));
            t = !1 !== i && n(t);
          } while (t && (!i || i(t, e)) && t !== Object.prototype);
          return e;
        },
        kindOf: r,
        kindOfTest: l,
        endsWith: (t, e, i) => {
          (t = String(t)), (void 0 === i || i > t.length) && (i = t.length), (i -= e.length);
          const s = t.indexOf(e, i);
          return -1 !== s && s === i;
        },
        toArray: (t) => {
          if (!t) return null;
          if (h(t)) return t;
          let e = t.length;
          if (!f(e)) return null;
          const i = new Array(e);
          for (; e-- > 0; ) i[e] = t[e];
          return i;
        },
        forEachEntry: (t, e) => {
          const i = (t && t[Symbol.iterator]).call(t);
          let s;
          for (; (s = i.next()) && !s.done; ) {
            const i = s.value;
            e.call(t, i[0], i[1]);
          }
        },
        matchAll: (t, e) => {
          let i;
          const s = [];
          for (; null !== (i = t.exec(e)); ) s.push(i);
          return s;
        },
        isHTMLForm: E,
        hasOwnProperty: T,
        hasOwnProp: T,
        reduceDescriptors: P,
        freezeMethods: (t) => {
          P(t, (e, i) => {
            const s = t[i];
            g(s) &&
              ((e.enumerable = !1),
              "writable" in e
                ? (e.writable = !1)
                : e.set ||
                  (e.set = () => {
                    throw Error("Can not read-only method '" + i + "'");
                  }));
          });
        },
        toObjectSet: (t, e) => {
          const i = {},
            s = (t) => {
              t.forEach((t) => {
                i[t] = !0;
              });
            };
          return h(t) ? s(t) : s(String(t).split(e)), i;
        },
        toCamelCase: (t) =>
          t.toLowerCase().replace(/[_-\s]([a-z\d])(\w*)/g, function (t, e, i) {
            return e.toUpperCase() + i;
          }),
        noop: () => {},
        toFiniteNumber: (t, e) => ((t = +t), Number.isFinite(t) ? t : e),
      };
      function O(t, e, i, s, a) {
        Error.call(this),
          Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error().stack),
          (this.message = t),
          (this.name = "AxiosError"),
          e && (this.code = e),
          i && (this.config = i),
          s && (this.request = s),
          a && (this.response = a);
      }
      M.inherits(O, Error, {
        toJSON: function () {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: this.config,
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null,
          };
        },
      });
      const I = O.prototype,
        F = {};
      [
        "ERR_BAD_OPTION_VALUE",
        "ERR_BAD_OPTION",
        "ECONNABORTED",
        "ETIMEDOUT",
        "ERR_NETWORK",
        "ERR_FR_TOO_MANY_REDIRECTS",
        "ERR_DEPRECATED",
        "ERR_BAD_RESPONSE",
        "ERR_BAD_REQUEST",
        "ERR_CANCELED",
        "ERR_NOT_SUPPORT",
        "ERR_INVALID_URL",
      ].forEach((t) => {
        F[t] = { value: t };
      }),
        Object.defineProperties(O, F),
        Object.defineProperty(I, "isAxiosError", { value: !0 }),
        (O.from = (t, e, i, s, a, n) => {
          const r = Object.create(I);
          return (
            M.toFlatObject(
              t,
              r,
              function (t) {
                return t !== Error.prototype;
              },
              (t) => "isAxiosError" !== t
            ),
            O.call(r, t.message, e, i, s, a),
            (r.cause = t),
            (r.name = t.name),
            n && Object.assign(r, n),
            r
          );
        });
      var D = O,
        z = i(230);
      function N(t) {
        return M.isPlainObject(t) || M.isArray(t);
      }
      function R(t) {
        return M.endsWith(t, "[]") ? t.slice(0, -2) : t;
      }
      function _(t, e, i) {
        return t
          ? t
              .concat(e)
              .map(function (t, e) {
                return (t = R(t)), !i && e ? "[" + t + "]" : t;
              })
              .join(i ? "." : "")
          : e;
      }
      const B = M.toFlatObject(M, {}, null, function (t) {
        return /^is[A-Z]/.test(t);
      });
      var X = function (t, e, i) {
        if (!M.isObject(t)) throw new TypeError("target must be an object");
        e = e || new (z || FormData)();
        const s = (i = M.toFlatObject(i, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (t, e) {
            return !M.isUndefined(e[t]);
          })).metaTokens,
          a = i.visitor || h,
          n = i.dots,
          r = i.indexes,
          o =
            (i.Blob || ("undefined" != typeof Blob && Blob)) &&
            (l = e) &&
            M.isFunction(l.append) &&
            "FormData" === l[Symbol.toStringTag] &&
            l[Symbol.iterator];
        var l;
        if (!M.isFunction(a)) throw new TypeError("visitor must be a function");
        function c(t) {
          if (null === t) return "";
          if (M.isDate(t)) return t.toISOString();
          if (!o && M.isBlob(t)) throw new D("Blob is not supported. Use a Buffer instead.");
          return M.isArrayBuffer(t) || M.isTypedArray(t)
            ? o && "function" == typeof Blob
              ? new Blob([t])
              : Buffer.from(t)
            : t;
        }
        function h(t, i, a) {
          let o = t;
          if (t && !a && "object" == typeof t)
            if (M.endsWith(i, "{}")) (i = s ? i : i.slice(0, -2)), (t = JSON.stringify(t));
            else if (
              (M.isArray(t) &&
                (function (t) {
                  return M.isArray(t) && !t.some(N);
                })(t)) ||
              M.isFileList(t) ||
              (M.endsWith(i, "[]") && (o = M.toArray(t)))
            )
              return (
                (i = R(i)),
                o.forEach(function (t, s) {
                  !M.isUndefined(t) &&
                    null !== t &&
                    e.append(!0 === r ? _([i], s, n) : null === r ? i : i + "[]", c(t));
                }),
                !1
              );
          return !!N(t) || (e.append(_(a, i, n), c(t)), !1);
        }
        const d = [],
          u = Object.assign(B, { defaultVisitor: h, convertValue: c, isVisitable: N });
        if (!M.isObject(t)) throw new TypeError("data must be an object");
        return (
          (function t(i, s) {
            if (!M.isUndefined(i)) {
              if (-1 !== d.indexOf(i)) throw Error("Circular reference detected in " + s.join("."));
              d.push(i),
                M.forEach(i, function (i, n) {
                  !0 === (!(M.isUndefined(i) || null === i) && a.call(e, i, M.isString(n) ? n.trim() : n, s, u)) &&
                    t(i, s ? s.concat(n) : [n]);
                }),
                d.pop();
            }
          })(t),
          e
        );
      };
      function H(t) {
        const e = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
        return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (t) {
          return e[t];
        });
      }
      function Y(t, e) {
        (this._pairs = []), t && X(t, this, e);
      }
      const W = Y.prototype;
      (W.append = function (t, e) {
        this._pairs.push([t, e]);
      }),
        (W.toString = function (t) {
          const e = t
            ? function (e) {
                return t.call(this, e, H);
              }
            : H;
          return this._pairs
            .map(function (t) {
              return e(t[0]) + "=" + e(t[1]);
            }, "")
            .join("&");
        });
      var $ = Y;
      function V(t) {
        return encodeURIComponent(t)
          .replace(/%3A/gi, ":")
          .replace(/%24/g, "$")
          .replace(/%2C/gi, ",")
          .replace(/%20/g, "+")
          .replace(/%5B/gi, "[")
          .replace(/%5D/gi, "]");
      }
      function j(t, e, i) {
        if (!e) return t;
        const s = (i && i.encode) || V,
          a = i && i.serialize;
        let n;
        if (((n = a ? a(e, i) : M.isURLSearchParams(e) ? e.toString() : new $(e, i).toString(s)), n)) {
          const e = t.indexOf("#");
          -1 !== e && (t = t.slice(0, e)), (t += (-1 === t.indexOf("?") ? "?" : "&") + n);
        }
        return t;
      }
      var G = class {
          constructor() {
            this.handlers = [];
          }
          use(t, e, i) {
            return (
              this.handlers.push({
                fulfilled: t,
                rejected: e,
                synchronous: !!i && i.synchronous,
                runWhen: i ? i.runWhen : null,
              }),
              this.handlers.length - 1
            );
          }
          eject(t) {
            this.handlers[t] && (this.handlers[t] = null);
          }
          clear() {
            this.handlers && (this.handlers = []);
          }
          forEach(t) {
            M.forEach(this.handlers, function (e) {
              null !== e && t(e);
            });
          }
        },
        U = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 },
        q = "undefined" != typeof URLSearchParams ? URLSearchParams : $,
        Z = FormData;
      const K = (() => {
        let t;
        return (
          ("undefined" == typeof navigator ||
            ("ReactNative" !== (t = navigator.product) && "NativeScript" !== t && "NS" !== t)) &&
          "undefined" != typeof window &&
          "undefined" != typeof document
        );
      })();
      var J = {
          isBrowser: !0,
          classes: { URLSearchParams: q, FormData: Z, Blob: Blob },
          isStandardBrowserEnv: K,
          protocols: ["http", "https", "file", "blob", "url", "data"],
        },
        Q = function (t) {
          function e(t, i, s, a) {
            let n = t[a++];
            const r = Number.isFinite(+n),
              o = a >= t.length;
            return (
              (n = !n && M.isArray(s) ? s.length : n),
              o
                ? (M.hasOwnProp(s, n) ? (s[n] = [s[n], i]) : (s[n] = i), !r)
                : ((s[n] && M.isObject(s[n])) || (s[n] = []),
                  e(t, i, s[n], a) &&
                    M.isArray(s[n]) &&
                    (s[n] = (function (t) {
                      const e = {},
                        i = Object.keys(t);
                      let s;
                      const a = i.length;
                      let n;
                      for (s = 0; s < a; s++) (n = i[s]), (e[n] = t[n]);
                      return e;
                    })(s[n])),
                  !r)
            );
          }
          if (M.isFormData(t) && M.isFunction(t.entries)) {
            const i = {};
            return (
              M.forEachEntry(t, (t, s) => {
                e(
                  (function (t) {
                    return M.matchAll(/\w+|\[(\w*)]/g, t).map((t) => ("[]" === t[0] ? "" : t[1] || t[0]));
                  })(t),
                  s,
                  i,
                  0
                );
              }),
              i
            );
          }
          return null;
        },
        tt = J.isStandardBrowserEnv
          ? {
              write: function (t, e, i, s, a, n) {
                const r = [];
                r.push(t + "=" + encodeURIComponent(e)),
                  M.isNumber(i) && r.push("expires=" + new Date(i).toGMTString()),
                  M.isString(s) && r.push("path=" + s),
                  M.isString(a) && r.push("domain=" + a),
                  !0 === n && r.push("secure"),
                  (document.cookie = r.join("; "));
              },
              read: function (t) {
                const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
                return e ? decodeURIComponent(e[3]) : null;
              },
              remove: function (t) {
                this.write(t, "", Date.now() - 864e5);
              },
            }
          : {
              write: function () {},
              read: function () {
                return null;
              },
              remove: function () {},
            };
      function et(t, e) {
        return t && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
          ? (function (t, e) {
              return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t;
            })(t, e)
          : e;
      }
      var it = J.isStandardBrowserEnv
        ? (function () {
            const t = /(msie|trident)/i.test(navigator.userAgent),
              e = document.createElement("a");
            let i;
            function s(i) {
              let s = i;
              return (
                t && (e.setAttribute("href", s), (s = e.href)),
                e.setAttribute("href", s),
                {
                  href: e.href,
                  protocol: e.protocol ? e.protocol.replace(/:$/, "") : "",
                  host: e.host,
                  search: e.search ? e.search.replace(/^\?/, "") : "",
                  hash: e.hash ? e.hash.replace(/^#/, "") : "",
                  hostname: e.hostname,
                  port: e.port,
                  pathname: "/" === e.pathname.charAt(0) ? e.pathname : "/" + e.pathname,
                }
              );
            }
            return (
              (i = s(window.location.href)),
              function (t) {
                const e = M.isString(t) ? s(t) : t;
                return e.protocol === i.protocol && e.host === i.host;
              }
            );
          })()
        : function () {
            return !0;
          };
      function st(t, e, i) {
        D.call(this, null == t ? "canceled" : t, D.ERR_CANCELED, e, i), (this.name = "CanceledError");
      }
      M.inherits(st, D, { __CANCEL__: !0 });
      var at = st;
      const nt = M.toObjectSet([
          "age",
          "authorization",
          "content-length",
          "content-type",
          "etag",
          "expires",
          "from",
          "host",
          "if-modified-since",
          "if-unmodified-since",
          "last-modified",
          "location",
          "max-forwards",
          "proxy-authorization",
          "referer",
          "retry-after",
          "user-agent",
        ]),
        rt = Symbol("internals"),
        ot = Symbol("defaults");
      function lt(t) {
        return t && String(t).trim().toLowerCase();
      }
      function ct(t) {
        return !1 === t || null == t ? t : M.isArray(t) ? t.map(ct) : String(t);
      }
      function ht(t, e, i, s) {
        return M.isFunction(s)
          ? s.call(this, e, i)
          : M.isString(e)
          ? M.isString(s)
            ? -1 !== e.indexOf(s)
            : M.isRegExp(s)
            ? s.test(e)
            : void 0
          : void 0;
      }
      function dt(t, e) {
        e = e.toLowerCase();
        const i = Object.keys(t);
        let s,
          a = i.length;
        for (; a-- > 0; ) if (((s = i[a]), e === s.toLowerCase())) return s;
        return null;
      }
      function ut(t, e) {
        t && this.set(t), (this[ot] = e || null);
      }
      Object.assign(ut.prototype, {
        set: function (t, e, i) {
          const s = this;
          function a(t, e, i) {
            const a = lt(e);
            if (!a) throw new Error("header name must be a non-empty string");
            const n = dt(s, a);
            (!n || !0 === i || (!1 !== s[n] && !1 !== i)) && (s[n || e] = ct(t));
          }
          return (
            M.isPlainObject(t)
              ? M.forEach(t, (t, i) => {
                  a(t, i, e);
                })
              : a(e, t, i),
            this
          );
        },
        get: function (t, e) {
          if (!(t = lt(t))) return;
          const i = dt(this, t);
          if (i) {
            const t = this[i];
            if (!e) return t;
            if (!0 === e)
              return (function (t) {
                const e = Object.create(null),
                  i = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                let s;
                for (; (s = i.exec(t)); ) e[s[1]] = s[2];
                return e;
              })(t);
            if (M.isFunction(e)) return e.call(this, t, i);
            if (M.isRegExp(e)) return e.exec(t);
            throw new TypeError("parser must be boolean|regexp|function");
          }
        },
        has: function (t, e) {
          if ((t = lt(t))) {
            const i = dt(this, t);
            return !(!i || (e && !ht(0, this[i], i, e)));
          }
          return !1;
        },
        delete: function (t, e) {
          const i = this;
          let s = !1;
          function a(t) {
            if ((t = lt(t))) {
              const a = dt(i, t);
              !a || (e && !ht(0, i[a], a, e)) || (delete i[a], (s = !0));
            }
          }
          return M.isArray(t) ? t.forEach(a) : a(t), s;
        },
        clear: function () {
          return Object.keys(this).forEach(this.delete.bind(this));
        },
        normalize: function (t) {
          const e = this,
            i = {};
          return (
            M.forEach(this, (s, a) => {
              const n = dt(i, a);
              if (n) return (e[n] = ct(s)), void delete e[a];
              const r = t
                ? (function (t) {
                    return t
                      .trim()
                      .toLowerCase()
                      .replace(/([a-z\d])(\w*)/g, (t, e, i) => e.toUpperCase() + i);
                  })(a)
                : String(a).trim();
              r !== a && delete e[a], (e[r] = ct(s)), (i[r] = !0);
            }),
            this
          );
        },
        toJSON: function (t) {
          const e = Object.create(null);
          return (
            M.forEach(Object.assign({}, this[ot] || null, this), (i, s) => {
              null != i && !1 !== i && (e[s] = t && M.isArray(i) ? i.join(", ") : i);
            }),
            e
          );
        },
      }),
        Object.assign(ut, {
          from: function (t) {
            return M.isString(t)
              ? new this(
                  ((t) => {
                    const e = {};
                    let i, s, a;
                    return (
                      t &&
                        t.split("\n").forEach(function (t) {
                          (a = t.indexOf(":")),
                            (i = t.substring(0, a).trim().toLowerCase()),
                            (s = t.substring(a + 1).trim()),
                            !i ||
                              (e[i] && nt[i]) ||
                              ("set-cookie" === i
                                ? e[i]
                                  ? e[i].push(s)
                                  : (e[i] = [s])
                                : (e[i] = e[i] ? e[i] + ", " + s : s));
                        }),
                      e
                    );
                  })(t)
                )
              : t instanceof this
              ? t
              : new this(t);
          },
          accessor: function (t) {
            const e = (this[rt] = this[rt] = { accessors: {} }).accessors,
              i = this.prototype;
            function s(t) {
              const s = lt(t);
              e[s] ||
                ((function (t, e) {
                  const i = M.toCamelCase(" " + e);
                  ["get", "set", "has"].forEach((s) => {
                    Object.defineProperty(t, s + i, {
                      value: function (t, i, a) {
                        return this[s].call(this, e, t, i, a);
                      },
                      configurable: !0,
                    });
                  });
                })(i, t),
                (e[s] = !0));
            }
            return M.isArray(t) ? t.forEach(s) : s(t), this;
          },
        }),
        ut.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]),
        M.freezeMethods(ut.prototype),
        M.freezeMethods(ut);
      var pt = ut;
      function gt(t, e) {
        let i = 0;
        const s = (function (t, e) {
          t = t || 10;
          const i = new Array(t),
            s = new Array(t);
          let a,
            n = 0,
            r = 0;
          return (
            (e = void 0 !== e ? e : 1e3),
            function (o) {
              const l = Date.now(),
                c = s[r];
              a || (a = l), (i[n] = o), (s[n] = l);
              let h = r,
                d = 0;
              for (; h !== n; ) (d += i[h++]), (h %= t);
              if (((n = (n + 1) % t), n === r && (r = (r + 1) % t), l - a < e)) return;
              const u = c && l - c;
              return u ? Math.round((1e3 * d) / u) : void 0;
            }
          );
        })(50, 250);
        return (a) => {
          const n = a.loaded,
            r = a.lengthComputable ? a.total : void 0,
            o = n - i,
            l = s(o);
          i = n;
          const c = {
            loaded: n,
            total: r,
            progress: r ? n / r : void 0,
            bytes: o,
            rate: l || void 0,
            estimated: l && r && n <= r ? (r - n) / l : void 0,
          };
          (c[e ? "download" : "upload"] = !0), t(c);
        };
      }
      function ft(t) {
        return new Promise(function (e, i) {
          let s = t.data;
          const a = pt.from(t.headers).normalize(),
            n = t.responseType;
          let r;
          function o() {
            t.cancelToken && t.cancelToken.unsubscribe(r), t.signal && t.signal.removeEventListener("abort", r);
          }
          M.isFormData(s) && J.isStandardBrowserEnv && a.setContentType(!1);
          let l = new XMLHttpRequest();
          if (t.auth) {
            const e = t.auth.username || "",
              i = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : "";
            a.set("Authorization", "Basic " + btoa(e + ":" + i));
          }
          const c = et(t.baseURL, t.url);
          function h() {
            if (!l) return;
            const s = pt.from("getAllResponseHeaders" in l && l.getAllResponseHeaders());
            !(function (t, e, i) {
              const s = i.config.validateStatus;
              i.status && s && !s(i.status)
                ? e(
                    new D(
                      "Request failed with status code " + i.status,
                      [D.ERR_BAD_REQUEST, D.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4],
                      i.config,
                      i.request,
                      i
                    )
                  )
                : t(i);
            })(
              function (t) {
                e(t), o();
              },
              function (t) {
                i(t), o();
              },
              {
                data: n && "text" !== n && "json" !== n ? l.response : l.responseText,
                status: l.status,
                statusText: l.statusText,
                headers: s,
                config: t,
                request: l,
              }
            ),
              (l = null);
          }
          if (
            (l.open(t.method.toUpperCase(), j(c, t.params, t.paramsSerializer), !0),
            (l.timeout = t.timeout),
            "onloadend" in l
              ? (l.onloadend = h)
              : (l.onreadystatechange = function () {
                  l &&
                    4 === l.readyState &&
                    (0 !== l.status || (l.responseURL && 0 === l.responseURL.indexOf("file:"))) &&
                    setTimeout(h);
                }),
            (l.onabort = function () {
              l && (i(new D("Request aborted", D.ECONNABORTED, t, l)), (l = null));
            }),
            (l.onerror = function () {
              i(new D("Network Error", D.ERR_NETWORK, t, l)), (l = null);
            }),
            (l.ontimeout = function () {
              let e = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
              const s = t.transitional || U;
              t.timeoutErrorMessage && (e = t.timeoutErrorMessage),
                i(new D(e, s.clarifyTimeoutError ? D.ETIMEDOUT : D.ECONNABORTED, t, l)),
                (l = null);
            }),
            J.isStandardBrowserEnv)
          ) {
            const e = (t.withCredentials || it(c)) && t.xsrfCookieName && tt.read(t.xsrfCookieName);
            e && a.set(t.xsrfHeaderName, e);
          }
          void 0 === s && a.setContentType(null),
            "setRequestHeader" in l &&
              M.forEach(a.toJSON(), function (t, e) {
                l.setRequestHeader(e, t);
              }),
            M.isUndefined(t.withCredentials) || (l.withCredentials = !!t.withCredentials),
            n && "json" !== n && (l.responseType = t.responseType),
            "function" == typeof t.onDownloadProgress && l.addEventListener("progress", gt(t.onDownloadProgress, !0)),
            "function" == typeof t.onUploadProgress &&
              l.upload &&
              l.upload.addEventListener("progress", gt(t.onUploadProgress)),
            (t.cancelToken || t.signal) &&
              ((r = (e) => {
                l && (i(!e || e.type ? new at(null, t, l) : e), l.abort(), (l = null));
              }),
              t.cancelToken && t.cancelToken.subscribe(r),
              t.signal && (t.signal.aborted ? r() : t.signal.addEventListener("abort", r)));
          const d = (function (t) {
            const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
            return (e && e[1]) || "";
          })(c);
          d && -1 === J.protocols.indexOf(d)
            ? i(new D("Unsupported protocol " + d + ":", D.ERR_BAD_REQUEST, t))
            : l.send(s || null);
        });
      }
      const mt = { http: ft, xhr: ft };
      var vt = (t) => {
        if (M.isString(t)) {
          const e = mt[t];
          if (!t)
            throw Error(
              M.hasOwnProp(t) ? `Adapter '${t}' is not available in the build` : `Can not resolve adapter '${t}'`
            );
          return e;
        }
        if (!M.isFunction(t)) throw new TypeError("adapter is not a function");
        return t;
      };
      const xt = { "Content-Type": "application/x-www-form-urlencoded" },
        bt = {
          transitional: U,
          adapter: (function () {
            let t;
            return (
              "undefined" != typeof XMLHttpRequest
                ? (t = vt("xhr"))
                : "undefined" != typeof process && "process" === M.kindOf(process) && (t = vt("http")),
              t
            );
          })(),
          transformRequest: [
            function (t, e) {
              const i = e.getContentType() || "",
                s = i.indexOf("application/json") > -1,
                a = M.isObject(t);
              if ((a && M.isHTMLForm(t) && (t = new FormData(t)), M.isFormData(t)))
                return s && s ? JSON.stringify(Q(t)) : t;
              if (M.isArrayBuffer(t) || M.isBuffer(t) || M.isStream(t) || M.isFile(t) || M.isBlob(t)) return t;
              if (M.isArrayBufferView(t)) return t.buffer;
              if (M.isURLSearchParams(t))
                return e.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
              let n;
              if (a) {
                if (i.indexOf("application/x-www-form-urlencoded") > -1)
                  return (function (t, e) {
                    return X(
                      t,
                      new J.classes.URLSearchParams(),
                      Object.assign(
                        {
                          visitor: function (t, e, i, s) {
                            return J.isNode && M.isBuffer(t)
                              ? (this.append(e, t.toString("base64")), !1)
                              : s.defaultVisitor.apply(this, arguments);
                          },
                        },
                        e
                      )
                    );
                  })(t, this.formSerializer).toString();
                if ((n = M.isFileList(t)) || i.indexOf("multipart/form-data") > -1) {
                  const e = this.env && this.env.FormData;
                  return X(n ? { "files[]": t } : t, e && new e(), this.formSerializer);
                }
              }
              return a || s
                ? (e.setContentType("application/json", !1),
                  (function (t, e, i) {
                    if (M.isString(t))
                      try {
                        return (0, JSON.parse)(t), M.trim(t);
                      } catch (t) {
                        if ("SyntaxError" !== t.name) throw t;
                      }
                    return (0, JSON.stringify)(t);
                  })(t))
                : t;
            },
          ],
          transformResponse: [
            function (t) {
              const e = this.transitional || bt.transitional,
                i = e && e.forcedJSONParsing,
                s = "json" === this.responseType;
              if (t && M.isString(t) && ((i && !this.responseType) || s)) {
                const i = !(e && e.silentJSONParsing) && s;
                try {
                  return JSON.parse(t);
                } catch (t) {
                  if (i) {
                    if ("SyntaxError" === t.name) throw D.from(t, D.ERR_BAD_RESPONSE, this, null, this.response);
                    throw t;
                  }
                }
              }
              return t;
            },
          ],
          timeout: 0,
          xsrfCookieName: "XSRF-TOKEN",
          xsrfHeaderName: "X-XSRF-TOKEN",
          maxContentLength: -1,
          maxBodyLength: -1,
          env: { FormData: J.classes.FormData, Blob: J.classes.Blob },
          validateStatus: function (t) {
            return t >= 200 && t < 300;
          },
          headers: { common: { Accept: "application/json, text/plain, */*" } },
        };
      M.forEach(["delete", "get", "head"], function (t) {
        bt.headers[t] = {};
      }),
        M.forEach(["post", "put", "patch"], function (t) {
          bt.headers[t] = M.merge(xt);
        });
      var yt = bt;
      function wt(t, e) {
        const i = this || yt,
          s = e || i,
          a = pt.from(s.headers);
        let n = s.data;
        return (
          M.forEach(t, function (t) {
            n = t.call(i, n, a.normalize(), e ? e.status : void 0);
          }),
          a.normalize(),
          n
        );
      }
      function kt(t) {
        return !(!t || !t.__CANCEL__);
      }
      function St(t) {
        if ((t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)) throw new at();
      }
      function Ct(t) {
        return (
          St(t),
          (t.headers = pt.from(t.headers)),
          (t.data = wt.call(t, t.transformRequest)),
          (t.adapter || yt.adapter)(t).then(
            function (e) {
              return St(t), (e.data = wt.call(t, t.transformResponse, e)), (e.headers = pt.from(e.headers)), e;
            },
            function (e) {
              return (
                kt(e) ||
                  (St(t),
                  e &&
                    e.response &&
                    ((e.response.data = wt.call(t, t.transformResponse, e.response)),
                    (e.response.headers = pt.from(e.response.headers)))),
                Promise.reject(e)
              );
            }
          )
        );
      }
      function At(t, e) {
        e = e || {};
        const i = {};
        function s(t, e) {
          return M.isPlainObject(t) && M.isPlainObject(e)
            ? M.merge(t, e)
            : M.isPlainObject(e)
            ? M.merge({}, e)
            : M.isArray(e)
            ? e.slice()
            : e;
        }
        function a(i) {
          return M.isUndefined(e[i]) ? (M.isUndefined(t[i]) ? void 0 : s(void 0, t[i])) : s(t[i], e[i]);
        }
        function n(t) {
          if (!M.isUndefined(e[t])) return s(void 0, e[t]);
        }
        function r(i) {
          return M.isUndefined(e[i]) ? (M.isUndefined(t[i]) ? void 0 : s(void 0, t[i])) : s(void 0, e[i]);
        }
        function o(i) {
          return i in e ? s(t[i], e[i]) : i in t ? s(void 0, t[i]) : void 0;
        }
        const l = {
          url: n,
          method: n,
          data: n,
          baseURL: r,
          transformRequest: r,
          transformResponse: r,
          paramsSerializer: r,
          timeout: r,
          timeoutMessage: r,
          withCredentials: r,
          adapter: r,
          responseType: r,
          xsrfCookieName: r,
          xsrfHeaderName: r,
          onUploadProgress: r,
          onDownloadProgress: r,
          decompress: r,
          maxContentLength: r,
          maxBodyLength: r,
          beforeRedirect: r,
          transport: r,
          httpAgent: r,
          httpsAgent: r,
          cancelToken: r,
          socketPath: r,
          responseEncoding: r,
          validateStatus: o,
        };
        return (
          M.forEach(Object.keys(t).concat(Object.keys(e)), function (t) {
            const e = l[t] || a,
              s = e(t);
            (M.isUndefined(s) && e !== o) || (i[t] = s);
          }),
          i
        );
      }
      const Et = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
        Et[t] = function (i) {
          return typeof i === t || "a" + (e < 1 ? "n " : " ") + t;
        };
      });
      const Tt = {};
      Et.transitional = function (t, e, i) {
        function s(t, e) {
          return "[Axios v1.1.3] Transitional option '" + t + "'" + e + (i ? ". " + i : "");
        }
        return (i, a, n) => {
          if (!1 === t) throw new D(s(a, " has been removed" + (e ? " in " + e : "")), D.ERR_DEPRECATED);
          return (
            e &&
              !Tt[a] &&
              ((Tt[a] = !0),
              console.warn(s(a, " has been deprecated since v" + e + " and will be removed in the near future"))),
            !t || t(i, a, n)
          );
        };
      };
      var Lt = {
        assertOptions: function (t, e, i) {
          if ("object" != typeof t) throw new D("options must be an object", D.ERR_BAD_OPTION_VALUE);
          const s = Object.keys(t);
          let a = s.length;
          for (; a-- > 0; ) {
            const n = s[a],
              r = e[n];
            if (r) {
              const e = t[n],
                i = void 0 === e || r(e, n, t);
              if (!0 !== i) throw new D("option " + n + " must be " + i, D.ERR_BAD_OPTION_VALUE);
            } else if (!0 !== i) throw new D("Unknown option " + n, D.ERR_BAD_OPTION);
          }
        },
        validators: Et,
      };
      const Pt = Lt.validators;
      class Mt {
        constructor(t) {
          (this.defaults = t), (this.interceptors = { request: new G(), response: new G() });
        }
        request(t, e) {
          "string" == typeof t ? ((e = e || {}).url = t) : (e = t || {}), (e = At(this.defaults, e));
          const { transitional: i, paramsSerializer: s } = e;
          void 0 !== i &&
            Lt.assertOptions(
              i,
              {
                silentJSONParsing: Pt.transitional(Pt.boolean),
                forcedJSONParsing: Pt.transitional(Pt.boolean),
                clarifyTimeoutError: Pt.transitional(Pt.boolean),
              },
              !1
            ),
            void 0 !== s && Lt.assertOptions(s, { encode: Pt.function, serialize: Pt.function }, !0),
            (e.method = (e.method || this.defaults.method || "get").toLowerCase());
          const a = e.headers && M.merge(e.headers.common, e.headers[e.method]);
          a &&
            M.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function (t) {
              delete e.headers[t];
            }),
            (e.headers = new pt(e.headers, a));
          const n = [];
          let r = !0;
          this.interceptors.request.forEach(function (t) {
            ("function" == typeof t.runWhen && !1 === t.runWhen(e)) ||
              ((r = r && t.synchronous), n.unshift(t.fulfilled, t.rejected));
          });
          const o = [];
          let l;
          this.interceptors.response.forEach(function (t) {
            o.push(t.fulfilled, t.rejected);
          });
          let c,
            h = 0;
          if (!r) {
            const t = [Ct.bind(this), void 0];
            for (t.unshift.apply(t, n), t.push.apply(t, o), c = t.length, l = Promise.resolve(e); h < c; )
              l = l.then(t[h++], t[h++]);
            return l;
          }
          c = n.length;
          let d = e;
          for (h = 0; h < c; ) {
            const t = n[h++],
              e = n[h++];
            try {
              d = t(d);
            } catch (t) {
              e.call(this, t);
              break;
            }
          }
          try {
            l = Ct.call(this, d);
          } catch (t) {
            return Promise.reject(t);
          }
          for (h = 0, c = o.length; h < c; ) l = l.then(o[h++], o[h++]);
          return l;
        }
        getUri(t) {
          return j(et((t = At(this.defaults, t)).baseURL, t.url), t.params, t.paramsSerializer);
        }
      }
      M.forEach(["delete", "get", "head", "options"], function (t) {
        Mt.prototype[t] = function (e, i) {
          return this.request(At(i || {}, { method: t, url: e, data: (i || {}).data }));
        };
      }),
        M.forEach(["post", "put", "patch"], function (t) {
          function e(e) {
            return function (i, s, a) {
              return this.request(
                At(a || {}, { method: t, headers: e ? { "Content-Type": "multipart/form-data" } : {}, url: i, data: s })
              );
            };
          }
          (Mt.prototype[t] = e()), (Mt.prototype[t + "Form"] = e(!0));
        });
      var Ot = Mt;
      class It {
        constructor(t) {
          if ("function" != typeof t) throw new TypeError("executor must be a function.");
          let e;
          this.promise = new Promise(function (t) {
            e = t;
          });
          const i = this;
          this.promise.then((t) => {
            if (!i._listeners) return;
            let e = i._listeners.length;
            for (; e-- > 0; ) i._listeners[e](t);
            i._listeners = null;
          }),
            (this.promise.then = (t) => {
              let e;
              const s = new Promise((t) => {
                i.subscribe(t), (e = t);
              }).then(t);
              return (
                (s.cancel = function () {
                  i.unsubscribe(e);
                }),
                s
              );
            }),
            t(function (t, s, a) {
              i.reason || ((i.reason = new at(t, s, a)), e(i.reason));
            });
        }
        throwIfRequested() {
          if (this.reason) throw this.reason;
        }
        subscribe(t) {
          this.reason ? t(this.reason) : this._listeners ? this._listeners.push(t) : (this._listeners = [t]);
        }
        unsubscribe(t) {
          if (!this._listeners) return;
          const e = this._listeners.indexOf(t);
          -1 !== e && this._listeners.splice(e, 1);
        }
        static source() {
          let t;
          return {
            token: new It(function (e) {
              t = e;
            }),
            cancel: t,
          };
        }
      }
      var Ft = It;
      const Dt = (function t(e) {
        const i = new Ot(e),
          a = s(Ot.prototype.request, i);
        return (
          M.extend(a, Ot.prototype, i, { allOwnKeys: !0 }),
          M.extend(a, i, null, { allOwnKeys: !0 }),
          (a.create = function (i) {
            return t(At(e, i));
          }),
          a
        );
      })(yt);
      (Dt.Axios = Ot),
        (Dt.CanceledError = at),
        (Dt.CancelToken = Ft),
        (Dt.isCancel = kt),
        (Dt.VERSION = "1.1.3"),
        (Dt.toFormData = X),
        (Dt.AxiosError = D),
        (Dt.Cancel = Dt.CanceledError),
        (Dt.all = function (t) {
          return Promise.all(t);
        }),
        (Dt.spread = function (t) {
          return function (e) {
            return t.apply(null, e);
          };
        }),
        (Dt.isAxiosError = function (t) {
          return M.isObject(t) && !0 === t.isAxiosError;
        }),
        (Dt.formToJSON = (t) => Q(M.isHTMLForm(t) ? new FormData(t) : t));
      var zt = Dt;
      const {
        Axios: Nt,
        AxiosError: Rt,
        CanceledError: _t,
        isCancel: Bt,
        CancelToken: Xt,
        VERSION: Ht,
        all: Yt,
        Cancel: Wt,
        isAxiosError: $t,
        spread: Vt,
        toFormData: jt,
      } = zt;
      var Gt = zt;
    },
    955: function (t, e) {
      "use strict";
      function i(t) {
        for (var e = 1; e < arguments.length; e++) {
          var i = arguments[e];
          for (var s in i) t[s] = i[s];
        }
        return t;
      }
      var s = (function t(e, s) {
        function a(t, a, n) {
          if ("undefined" != typeof document) {
            "number" == typeof (n = i({}, s, n)).expires && (n.expires = new Date(Date.now() + 864e5 * n.expires)),
              n.expires && (n.expires = n.expires.toUTCString()),
              (t = encodeURIComponent(t)
                .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
                .replace(/[()]/g, escape));
            var r = "";
            for (var o in n) n[o] && ((r += "; " + o), !0 !== n[o] && (r += "=" + n[o].split(";")[0]));
            return (document.cookie = t + "=" + e.write(a, t) + r);
          }
        }
        return Object.create(
          {
            set: a,
            get: function (t) {
              if ("undefined" != typeof document && (!arguments.length || t)) {
                for (var i = document.cookie ? document.cookie.split("; ") : [], s = {}, a = 0; a < i.length; a++) {
                  var n = i[a].split("="),
                    r = n.slice(1).join("=");
                  try {
                    var o = decodeURIComponent(n[0]);
                    if (((s[o] = e.read(r, o)), t === o)) break;
                  } catch (t) {}
                }
                return t ? s[t] : s;
              }
            },
            remove: function (t, e) {
              a(t, "", i({}, e, { expires: -1 }));
            },
            withAttributes: function (e) {
              return t(this.converter, i({}, this.attributes, e));
            },
            withConverter: function (e) {
              return t(i({}, this.converter, e), this.attributes);
            },
          },
          { attributes: { value: Object.freeze(s) }, converter: { value: Object.freeze(e) } }
        );
      })(
        {
          read: function (t) {
            return '"' === t[0] && (t = t.slice(1, -1)), t.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
          },
          write: function (t) {
            return encodeURIComponent(t).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
          },
        },
        { path: "/" }
      );
      e.Z = s;
    },
    466: function (t, e) {
      "use strict";
      var i,
        s,
        a = {};
      (i = window),
        (s = function () {
          return (
            (i = {}),
            (t.m = e =
              [
                function (t, e, i) {
                  function s(t, e) {
                    e = e || { bubbles: !1, cancelable: !1, detail: void 0 };
                    var i = document.createEvent("CustomEvent");
                    return i.initCustomEvent(t, e.bubbles, e.cancelable, e.detail), i;
                  }
                  (e.__esModule = !0),
                    (e.kebabCase =
                      e.highlight =
                      e.isValueInArrayOfObjects =
                      e.debounce =
                      e.putContent =
                      e.ensureElementInView =
                      e.hasClassInTree =
                        void 0),
                    (e.hasClassInTree = function (t, e) {
                      function i(t, e) {
                        return e && t && t.classList && t.classList.contains(e) ? t : null;
                      }
                      return (
                        i(t, e) ||
                        (function t(e, s) {
                          return e && e !== document ? (i(e, s) ? e : t(e.parentNode, s)) : null;
                        })(t, e)
                      );
                    }),
                    (e.ensureElementInView = function (t, e) {
                      var i = t.scrollTop + t.offsetTop,
                        s = i + t.clientHeight,
                        a = e.offsetTop;
                      (e = a + e.clientHeight), a < i ? (t.scrollTop -= i - a) : s < e && (t.scrollTop += e - s);
                    }),
                    (e.putContent = function (t, e, i) {
                      var s = t.offsetHeight,
                        a = t.getBoundingClientRect();
                      return (
                        (t = i ? a.top : a.top - s),
                        (s = i ? a.bottom : a.bottom + s),
                        t <= 0 ? "below" : s >= window.innerHeight ? "above" : i ? e : "below"
                      );
                    }),
                    (e.debounce = function (t, e, i) {
                      var s;
                      return (
                        void 0 === e && (e = 100),
                        void 0 === i && (i = !1),
                        function () {
                          for (var a = [], n = 0; n < arguments.length; n++) a[n] = arguments[n];
                          var r = self,
                            o = i && !s;
                          clearTimeout(s),
                            (s = setTimeout(function () {
                              (s = null), i || t.apply(r, a);
                            }, e)),
                            o && t.apply(r, a);
                        }
                      );
                    }),
                    (e.isValueInArrayOfObjects = function (t, e, i) {
                      if (!Array.isArray(t)) return t[e] === i;
                      for (var s = 0, a = t; s < a.length; s++) {
                        var n = a[s];
                        if (n && n[e] && n[e] === i) return !0;
                      }
                      return !1;
                    }),
                    (e.highlight = function (t, e, i) {
                      var s = t,
                        a = new RegExp("(" + e.trim() + ")(?![^<]*>[^<>]*</)", "i");
                      if (!t.match(a)) return t;
                      var n = t.match(a).index;
                      return (
                        (e = n + t.match(a)[0].toString().length),
                        (e = t.substring(n, e)),
                        s.replace(a, '<mark class="'.concat(i, '">').concat(e, "</mark>"))
                      );
                    }),
                    (e.kebabCase = function (t) {
                      var e = t.replace(/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, function (t) {
                        return "-" + t.toLowerCase();
                      });
                      return t[0] === t[0].toUpperCase() ? e.substring(1) : e;
                    }),
                    "function" != typeof (e = window).CustomEvent &&
                      ((s.prototype = e.Event.prototype), (e.CustomEvent = s));
                },
                function (t, e, i) {
                  (e.__esModule = !0), (e.validateOption = e.validateData = e.Data = void 0);
                  var s =
                    ((a.prototype.newOption = function (t) {
                      return {
                        id: t.id || String(Math.floor(1e8 * Math.random())),
                        value: t.value || "",
                        text: t.text || "",
                        innerHTML: t.innerHTML || "",
                        selected: t.selected || !1,
                        display: void 0 === t.display || t.display,
                        disabled: t.disabled || !1,
                        placeholder: t.placeholder || !1,
                        class: t.class || void 0,
                        data: t.data || {},
                        mandatory: t.mandatory || !1,
                      };
                    }),
                    (a.prototype.add = function (t) {
                      this.data.push({
                        id: String(Math.floor(1e8 * Math.random())),
                        value: t.value,
                        text: t.text,
                        innerHTML: "",
                        selected: !1,
                        display: !0,
                        disabled: !1,
                        placeholder: !1,
                        class: void 0,
                        mandatory: t.mandatory,
                        data: {},
                      });
                    }),
                    (a.prototype.parseSelectData = function () {
                      this.data = [];
                      for (var t = 0, e = this.main.select.element.childNodes; t < e.length; t++) {
                        var i = e[t];
                        if ("OPTGROUP" === i.nodeName) {
                          for (var s = { label: i.label, options: [] }, a = 0, n = i.childNodes; a < n.length; a++) {
                            var r,
                              o = n[a];
                            "OPTION" === o.nodeName &&
                              ((r = this.pullOptionData(o)),
                              s.options.push(r),
                              r.placeholder && "" !== r.text.trim() && (this.main.config.placeholderText = r.text));
                          }
                          this.data.push(s);
                        } else
                          "OPTION" === i.nodeName &&
                            ((r = this.pullOptionData(i)),
                            this.data.push(r),
                            r.placeholder && "" !== r.text.trim() && (this.main.config.placeholderText = r.text));
                      }
                    }),
                    (a.prototype.pullOptionData = function (t) {
                      return {
                        id: (!!t.dataset && t.dataset.id) || String(Math.floor(1e8 * Math.random())),
                        value: t.value,
                        text: t.text,
                        innerHTML: t.innerHTML,
                        selected: t.selected,
                        disabled: t.disabled,
                        placeholder: "true" === t.dataset.placeholder,
                        class: t.className,
                        style: t.style.cssText,
                        data: t.dataset,
                        mandatory: !!t.dataset && "true" === t.dataset.mandatory,
                      };
                    }),
                    (a.prototype.setSelectedFromSelect = function () {
                      if (this.main.config.isMultiple) {
                        for (var t = [], e = 0, i = this.main.select.element.options; e < i.length; e++) {
                          var s = i[e];
                          !s.selected || ((s = this.getObjectFromData(s.value, "value")) && s.id && t.push(s.id));
                        }
                        this.setSelected(t, "id");
                      } else {
                        var a = this.main.select.element;
                        -1 !== a.selectedIndex &&
                          ((a = a.options[a.selectedIndex].value), this.setSelected(a, "value"));
                      }
                    }),
                    (a.prototype.setSelected = function (t, e) {
                      void 0 === e && (e = "id");
                      for (var i = 0, s = this.data; i < s.length; i++) {
                        var a = s[i];
                        if (a.hasOwnProperty("label")) {
                          if (a.hasOwnProperty("options")) {
                            var n = a.options;
                            if (n)
                              for (var r = 0, o = n; r < o.length; r++) {
                                var l = o[r];
                                l.placeholder || (l.selected = this.shouldBeSelected(l, t, e));
                              }
                          }
                        } else a.selected = this.shouldBeSelected(a, t, e);
                      }
                    }),
                    (a.prototype.shouldBeSelected = function (t, e, i) {
                      if ((void 0 === i && (i = "id"), Array.isArray(e)))
                        for (var s = 0, a = e; s < a.length; s++) {
                          var n = a[s];
                          if (i in t && String(t[i]) === String(n)) return !0;
                        }
                      else if (i in t && String(t[i]) === String(e)) return !0;
                      return !1;
                    }),
                    (a.prototype.getSelected = function () {
                      for (
                        var t = { text: "", placeholder: this.main.config.placeholderText },
                          e = [],
                          i = 0,
                          s = this.data;
                        i < s.length;
                        i++
                      ) {
                        var a = s[i];
                        if (a.hasOwnProperty("label")) {
                          if (a.hasOwnProperty("options")) {
                            var n = a.options;
                            if (n)
                              for (var r = 0, o = n; r < o.length; r++) {
                                var l = o[r];
                                l.selected && (this.main.config.isMultiple ? e.push(l) : (t = l));
                              }
                          }
                        } else a.selected && (this.main.config.isMultiple ? e.push(a) : (t = a));
                      }
                      return this.main.config.isMultiple ? e : t;
                    }),
                    (a.prototype.addToSelected = function (t, e) {
                      if ((void 0 === e && (e = "id"), this.main.config.isMultiple)) {
                        var i = [],
                          s = this.getSelected();
                        if (Array.isArray(s))
                          for (var a = 0, n = s; a < n.length; a++) {
                            var r = n[a];
                            i.push(r[e]);
                          }
                        i.push(t), this.setSelected(i, e);
                      }
                    }),
                    (a.prototype.removeFromSelected = function (t, e) {
                      if ((void 0 === e && (e = "id"), this.main.config.isMultiple)) {
                        for (var i = [], s = 0, a = this.getSelected(); s < a.length; s++) {
                          var n = a[s];
                          String(n[e]) !== String(t) && i.push(n[e]);
                        }
                        this.setSelected(i, e);
                      }
                    }),
                    (a.prototype.onDataChange = function () {
                      this.main.onChange &&
                        this.isOnChangeEnabled &&
                        this.main.onChange(JSON.parse(JSON.stringify(this.getSelected())));
                    }),
                    (a.prototype.getObjectFromData = function (t, e) {
                      void 0 === e && (e = "id");
                      for (var i = 0, s = this.data; i < s.length; i++) {
                        var a = s[i];
                        if (e in a && String(a[e]) === String(t)) return a;
                        if (a.hasOwnProperty("options") && a.options)
                          for (var n = 0, r = a.options; n < r.length; n++) {
                            var o = r[n];
                            if (String(o[e]) === String(t)) return o;
                          }
                      }
                      return null;
                    }),
                    (a.prototype.search = function (t) {
                      var e, i;
                      "" !== (this.searchValue = t).trim()
                        ? ((e = this.main.config.searchFilter),
                          (i = this.data.slice(0)),
                          (t = t.trim()),
                          (i = i.map(function (i) {
                            if (i.hasOwnProperty("options")) {
                              var s = i,
                                a = [];
                              if (
                                0 !==
                                (a = s.options
                                  ? s.options.filter(function (i) {
                                      return e(i, t);
                                    })
                                  : a).length
                              )
                                return ((s = Object.assign({}, s)).options = a), s;
                            }
                            return i.hasOwnProperty("text") && e(i, t) ? i : null;
                          })),
                          (this.filtered = i.filter(function (t) {
                            return t;
                          })))
                        : (this.filtered = null);
                    }),
                    a);
                  function a(t) {
                    (this.contentOpen = !1),
                      (this.contentPosition = "below"),
                      (this.isOnChangeEnabled = !0),
                      (this.main = t.main),
                      (this.searchValue = ""),
                      (this.data = []),
                      (this.filtered = null),
                      this.parseSelectData(),
                      this.setSelectedFromSelect();
                  }
                  function n(t) {
                    return (
                      void 0 !== t.text ||
                      (console.error(
                        "Data object option must have at least have a text value. Check object: " + JSON.stringify(t)
                      ),
                      !1)
                    );
                  }
                  (e.Data = s),
                    (e.validateData = function (t) {
                      if (!t) return console.error("Data must be an array of objects"), !1;
                      for (var e = 0, i = 0, s = t; i < s.length; i++) {
                        var a = s[i];
                        if (a.hasOwnProperty("label")) {
                          if (a.hasOwnProperty("options")) {
                            var r = a.options;
                            if (r) for (var o = 0, l = r; o < l.length; o++) n(l[o]) || e++;
                          }
                        } else n(a) || e++;
                      }
                      return 0 === e;
                    }),
                    (e.validateOption = n);
                },
                function (t, e, i) {
                  e.__esModule = !0;
                  var s = i(3),
                    a = i(4),
                    n = i(5),
                    r = i(1),
                    o = i(0);
                  function l(t) {
                    var e = this;
                    (this.ajax = null),
                      (this.addable = null),
                      (this.beforeOnChange = null),
                      (this.onChange = null),
                      (this.beforeOpen = null),
                      (this.afterOpen = null),
                      (this.beforeClose = null),
                      (this.afterClose = null),
                      (this.windowScroll = (0, o.debounce)(function (t) {
                        e.data.contentOpen &&
                          ("above" === (0, o.putContent)(e.slim.content, e.data.contentPosition, e.data.contentOpen)
                            ? e.moveContentAbove()
                            : e.moveContentBelow());
                      })),
                      (this.documentClick = function (t) {
                        t.target && !(0, o.hasClassInTree)(t.target, e.config.id) && e.close();
                      });
                    var i = this.validate(t);
                    i.dataset.ssid && this.destroy(i.dataset.ssid),
                      t.ajax && (this.ajax = t.ajax),
                      t.addable && (this.addable = t.addable),
                      (this.config = new s.Config({
                        select: i,
                        isAjax: !!t.ajax,
                        showSearch: t.showSearch,
                        searchPlaceholder: t.searchPlaceholder,
                        searchText: t.searchText,
                        searchingText: t.searchingText,
                        searchFocus: t.searchFocus,
                        searchHighlight: t.searchHighlight,
                        searchFilter: t.searchFilter,
                        closeOnSelect: t.closeOnSelect,
                        showContent: t.showContent,
                        placeholderText: t.placeholder,
                        allowDeselect: t.allowDeselect,
                        allowDeselectOption: t.allowDeselectOption,
                        hideSelectedOption: t.hideSelectedOption,
                        deselectLabel: t.deselectLabel,
                        isEnabled: t.isEnabled,
                        valuesUseText: t.valuesUseText,
                        showOptionTooltips: t.showOptionTooltips,
                        selectByGroup: t.selectByGroup,
                        limit: t.limit,
                        timeoutDelay: t.timeoutDelay,
                        addToBody: t.addToBody,
                      })),
                      (this.select = new a.Select({ select: i, main: this })),
                      (this.data = new r.Data({ main: this })),
                      (this.slim = new n.Slim({ main: this })),
                      this.select.element.parentNode &&
                        this.select.element.parentNode.insertBefore(
                          this.slim.container,
                          this.select.element.nextSibling
                        ),
                      t.data ? this.setData(t.data) : this.render(),
                      document.addEventListener("click", this.documentClick),
                      "auto" === this.config.showContent && window.addEventListener("scroll", this.windowScroll, !1),
                      t.beforeOnChange && (this.beforeOnChange = t.beforeOnChange),
                      t.onChange && (this.onChange = t.onChange),
                      t.beforeOpen && (this.beforeOpen = t.beforeOpen),
                      t.afterOpen && (this.afterOpen = t.afterOpen),
                      t.beforeClose && (this.beforeClose = t.beforeClose),
                      t.afterClose && (this.afterClose = t.afterClose),
                      this.config.isEnabled || this.disable();
                  }
                  (l.prototype.validate = function (t) {
                    if (!(t = "string" == typeof t.select ? document.querySelector(t.select) : t.select))
                      throw new Error("Could not find select element");
                    if ("SELECT" !== t.tagName) throw new Error("Element isnt of type select");
                    return t;
                  }),
                    (l.prototype.selected = function () {
                      if (this.config.isMultiple) {
                        for (var t = [], e = 0, i = (a = this.data.getSelected()); e < i.length; e++) {
                          var s = i[e];
                          t.push(s.value);
                        }
                        return t;
                      }
                      var a;
                      return (a = this.data.getSelected()) ? a.value : "";
                    }),
                    (l.prototype.set = function (t, e, i, s) {
                      void 0 === e && (e = "value"),
                        void 0 === i && (i = !0),
                        void 0 === s && (s = !0),
                        this.config.isMultiple && !Array.isArray(t)
                          ? this.data.addToSelected(t, e)
                          : this.data.setSelected(t, e),
                        this.select.setValue(),
                        this.data.onDataChange(),
                        this.render(),
                        (i =
                          !(
                            !this.config.hideSelectedOption ||
                            !this.config.isMultiple ||
                            this.data.getSelected().length !== this.data.data.length
                          ) || i) && this.close();
                    }),
                    (l.prototype.setSelected = function (t, e, i, s) {
                      this.set(t, (e = void 0 === e ? "value" : e), (i = void 0 === i || i), (s = void 0 === s || s));
                    }),
                    (l.prototype.setData = function (t) {
                      if ((0, r.validateData)(t)) {
                        for (
                          var e = JSON.parse(JSON.stringify(t)), i = this.data.getSelected(), s = 0;
                          s < e.length;
                          s++
                        )
                          e[s].value || e[s].placeholder || (e[s].value = e[s].text);
                        if (this.config.isAjax && i)
                          if (this.config.isMultiple)
                            for (var a = 0, n = i.reverse(); a < n.length; a++) {
                              var o = n[a];
                              e.unshift(o);
                            }
                          else {
                            for (e.unshift(i), s = 0; s < e.length; s++)
                              e[s].placeholder || e[s].value !== i.value || e[s].text !== i.text || e.splice(s, 1);
                            var l = !1;
                            for (s = 0; s < e.length; s++) e[s].placeholder && (l = !0);
                            l || e.unshift({ text: "", placeholder: !0 });
                          }
                        this.select.create(e), this.data.parseSelectData(), this.data.setSelectedFromSelect();
                      } else console.error("Validation problem on: #" + this.select.element.id);
                    }),
                    (l.prototype.addData = function (t) {
                      (0, r.validateData)([t])
                        ? (this.data.add(this.data.newOption(t)),
                          this.select.create(this.data.data),
                          this.data.parseSelectData(),
                          this.data.setSelectedFromSelect(),
                          this.render())
                        : console.error("Validation problem on: #" + this.select.element.id);
                    }),
                    (l.prototype.open = function () {
                      var t,
                        e = this;
                      this.config.isEnabled &&
                        (this.data.contentOpen ||
                          (this.config.hideSelectedOption &&
                            this.config.isMultiple &&
                            this.data.getSelected().length === this.data.data.length) ||
                          (this.beforeOpen && this.beforeOpen(),
                          this.config.isMultiple && this.slim.multiSelected
                            ? this.slim.multiSelected.plus.classList.add("ss-cross")
                            : this.slim.singleSelected &&
                              (this.slim.singleSelected.arrowIcon.arrow.classList.remove("arrow-down"),
                              this.slim.singleSelected.arrowIcon.arrow.classList.add("arrow-up")),
                          this.slim[
                            this.config.isMultiple ? "multiSelected" : "singleSelected"
                          ].container.classList.add(
                            "above" === this.data.contentPosition ? this.config.openAbove : this.config.openBelow
                          ),
                          this.config.addToBody &&
                            ((t = this.slim.container.getBoundingClientRect()),
                            (this.slim.content.style.top = t.top + t.height + window.scrollY + "px"),
                            (this.slim.content.style.left = t.left + window.scrollX + "px"),
                            (this.slim.content.style.width = t.width + "px")),
                          this.slim.content.classList.add(this.config.open),
                          "up" === this.config.showContent.toLowerCase() ||
                          ("down" !== this.config.showContent.toLowerCase() &&
                            "above" ===
                              (0, o.putContent)(this.slim.content, this.data.contentPosition, this.data.contentOpen))
                            ? this.moveContentAbove()
                            : this.moveContentBelow(),
                          this.config.isMultiple ||
                            ((t = this.data.getSelected()) &&
                              ((t = t.id),
                              (t = this.slim.list.querySelector('[data-id="' + t + '"]')) &&
                                (0, o.ensureElementInView)(this.slim.list, t))),
                          setTimeout(function () {
                            (e.data.contentOpen = !0),
                              e.config.searchFocus && e.slim.search.input.focus(),
                              e.afterOpen && e.afterOpen();
                          }, this.config.timeoutDelay)));
                    }),
                    (l.prototype.close = function () {
                      var t = this;
                      this.data.contentOpen &&
                        (this.beforeClose && this.beforeClose(),
                        this.config.isMultiple && this.slim.multiSelected
                          ? (this.slim.multiSelected.container.classList.remove(this.config.openAbove),
                            this.slim.multiSelected.container.classList.remove(this.config.openBelow),
                            this.slim.multiSelected.plus.classList.remove("ss-cross"))
                          : this.slim.singleSelected &&
                            (this.slim.singleSelected.container.classList.remove(this.config.openAbove),
                            this.slim.singleSelected.container.classList.remove(this.config.openBelow),
                            this.slim.singleSelected.arrowIcon.arrow.classList.add("arrow-down"),
                            this.slim.singleSelected.arrowIcon.arrow.classList.remove("arrow-up")),
                        this.slim.content.classList.remove(this.config.open),
                        (this.data.contentOpen = !1),
                        this.search(""),
                        setTimeout(function () {
                          t.slim.content.removeAttribute("style"),
                            (t.data.contentPosition = "below"),
                            t.config.isMultiple && t.slim.multiSelected
                              ? (t.slim.multiSelected.container.classList.remove(t.config.openAbove),
                                t.slim.multiSelected.container.classList.remove(t.config.openBelow))
                              : t.slim.singleSelected &&
                                (t.slim.singleSelected.container.classList.remove(t.config.openAbove),
                                t.slim.singleSelected.container.classList.remove(t.config.openBelow)),
                            t.slim.search.input.blur(),
                            t.afterClose && t.afterClose();
                        }, this.config.timeoutDelay));
                    }),
                    (l.prototype.moveContentAbove = function () {
                      var t = 0;
                      this.config.isMultiple && this.slim.multiSelected
                        ? (t = this.slim.multiSelected.container.offsetHeight)
                        : this.slim.singleSelected && (t = this.slim.singleSelected.container.offsetHeight);
                      var e = t + this.slim.content.offsetHeight - 1;
                      (this.slim.content.style.margin = "-" + e + "px 0 0 0"),
                        (this.slim.content.style.height = e - t + 1 + "px"),
                        (this.slim.content.style.transformOrigin = "center bottom"),
                        (this.data.contentPosition = "above"),
                        this.config.isMultiple && this.slim.multiSelected
                          ? (this.slim.multiSelected.container.classList.remove(this.config.openBelow),
                            this.slim.multiSelected.container.classList.add(this.config.openAbove))
                          : this.slim.singleSelected &&
                            (this.slim.singleSelected.container.classList.remove(this.config.openBelow),
                            this.slim.singleSelected.container.classList.add(this.config.openAbove));
                    }),
                    (l.prototype.moveContentBelow = function () {
                      (this.data.contentPosition = "below"),
                        this.config.isMultiple && this.slim.multiSelected
                          ? (this.slim.multiSelected.container.classList.remove(this.config.openAbove),
                            this.slim.multiSelected.container.classList.add(this.config.openBelow))
                          : this.slim.singleSelected &&
                            (this.slim.singleSelected.container.classList.remove(this.config.openAbove),
                            this.slim.singleSelected.container.classList.add(this.config.openBelow));
                    }),
                    (l.prototype.enable = function () {
                      (this.config.isEnabled = !0),
                        this.config.isMultiple && this.slim.multiSelected
                          ? this.slim.multiSelected.container.classList.remove(this.config.disabled)
                          : this.slim.singleSelected &&
                            this.slim.singleSelected.container.classList.remove(this.config.disabled),
                        (this.select.triggerMutationObserver = !1),
                        (this.select.element.disabled = !1),
                        (this.slim.search.input.disabled = !1),
                        (this.select.triggerMutationObserver = !0);
                    }),
                    (l.prototype.disable = function () {
                      (this.config.isEnabled = !1),
                        this.config.isMultiple && this.slim.multiSelected
                          ? this.slim.multiSelected.container.classList.add(this.config.disabled)
                          : this.slim.singleSelected &&
                            this.slim.singleSelected.container.classList.add(this.config.disabled),
                        (this.select.triggerMutationObserver = !1),
                        (this.select.element.disabled = !0),
                        (this.slim.search.input.disabled = !0),
                        (this.select.triggerMutationObserver = !0);
                    }),
                    (l.prototype.search = function (t) {
                      var e;
                      this.data.searchValue !== t &&
                        ((this.slim.search.input.value = t),
                        this.config.isAjax
                          ? (((e = this).config.isSearching = !0),
                            this.render(),
                            this.ajax &&
                              this.ajax(t, function (i) {
                                (e.config.isSearching = !1),
                                  Array.isArray(i)
                                    ? (i.unshift({ text: "", placeholder: !0 }),
                                      e.setData(i),
                                      e.data.search(t),
                                      e.render())
                                    : "string" == typeof i
                                    ? e.slim.options(i)
                                    : e.render();
                              }))
                          : (this.data.search(t), this.render()));
                    }),
                    (l.prototype.setSearchText = function (t) {
                      this.config.searchText = t;
                    }),
                    (l.prototype.render = function () {
                      this.config.isMultiple ? this.slim.values() : (this.slim.placeholder(), this.slim.deselect()),
                        this.slim.options();
                    }),
                    (l.prototype.destroy = function (t) {
                      var e = (t = void 0 === t ? null : t)
                          ? document.querySelector("." + t + ".ss-main")
                          : this.slim.container,
                        i = t ? document.querySelector("[data-ssid=".concat(t, "]")) : this.select.element;
                      e &&
                        i &&
                        (document.removeEventListener("click", this.documentClick),
                        "auto" === this.config.showContent &&
                          window.removeEventListener("scroll", this.windowScroll, !1),
                        (i.style.display = ""),
                        delete i.dataset.ssid,
                        (i.slim = null),
                        e.parentElement && e.parentElement.removeChild(e),
                        !this.config.addToBody ||
                          ((t = t ? document.querySelector("." + t + ".ss-content") : this.slim.content) &&
                            document.body.removeChild(t)));
                    }),
                    (i = l),
                    (e.default = i);
                },
                function (t, e, i) {
                  (e.__esModule = !0), (e.Config = void 0);
                  var s =
                    ((a.prototype.searchFilter = function (t, e) {
                      return -1 !== t.text.toLowerCase().indexOf(e.toLowerCase());
                    }),
                    a);
                  function a(t) {
                    (this.id = ""),
                      (this.isMultiple = !1),
                      (this.isAjax = !1),
                      (this.isSearching = !1),
                      (this.showSearch = !0),
                      (this.searchFocus = !0),
                      (this.searchHighlight = !1),
                      (this.closeOnSelect = !0),
                      (this.showContent = "auto"),
                      (this.searchPlaceholder = "Search"),
                      (this.searchText = "No Results"),
                      (this.searchingText = "Searching..."),
                      (this.placeholderText = "Select Value"),
                      (this.allowDeselect = !1),
                      (this.allowDeselectOption = !1),
                      (this.hideSelectedOption = !1),
                      (this.deselectLabel = "x"),
                      (this.isEnabled = !0),
                      (this.valuesUseText = !1),
                      (this.showOptionTooltips = !1),
                      (this.selectByGroup = !1),
                      (this.limit = 0),
                      (this.timeoutDelay = 200),
                      (this.addToBody = !1),
                      (this.main = "ss-main"),
                      (this.singleSelected = "ss-single-selected"),
                      (this.arrow = "ss-arrow"),
                      (this.multiSelected = "ss-multi-selected"),
                      (this.add = "ss-add"),
                      (this.plus = "ss-plus"),
                      (this.values = "ss-values"),
                      (this.value = "ss-value"),
                      (this.valueText = "ss-value-text"),
                      (this.valueDelete = "ss-value-delete"),
                      (this.content = "ss-content"),
                      (this.open = "ss-open"),
                      (this.openAbove = "ss-open-above"),
                      (this.openBelow = "ss-open-below"),
                      (this.search = "ss-search"),
                      (this.searchHighlighter = "ss-search-highlight"),
                      (this.addable = "ss-addable"),
                      (this.list = "ss-list"),
                      (this.optgroup = "ss-optgroup"),
                      (this.optgroupLabel = "ss-optgroup-label"),
                      (this.optgroupLabelSelectable = "ss-optgroup-label-selectable"),
                      (this.option = "ss-option"),
                      (this.optionSelected = "ss-option-selected"),
                      (this.highlighted = "ss-highlighted"),
                      (this.disabled = "ss-disabled"),
                      (this.hide = "ss-hide"),
                      (this.id = "ss-" + Math.floor(1e5 * Math.random())),
                      (this.style = t.select.style.cssText),
                      (this.class = t.select.className.split(" ")),
                      (this.isMultiple = t.select.multiple),
                      (this.isAjax = t.isAjax),
                      (this.showSearch = !1 !== t.showSearch),
                      (this.searchFocus = !1 !== t.searchFocus),
                      (this.searchHighlight = !0 === t.searchHighlight),
                      (this.closeOnSelect = !1 !== t.closeOnSelect),
                      t.showContent && (this.showContent = t.showContent),
                      (this.isEnabled = !1 !== t.isEnabled),
                      t.searchPlaceholder && (this.searchPlaceholder = t.searchPlaceholder),
                      t.searchText && (this.searchText = t.searchText),
                      t.searchingText && (this.searchingText = t.searchingText),
                      t.placeholderText && (this.placeholderText = t.placeholderText),
                      (this.allowDeselect = !0 === t.allowDeselect),
                      (this.allowDeselectOption = !0 === t.allowDeselectOption),
                      (this.hideSelectedOption = !0 === t.hideSelectedOption),
                      t.deselectLabel && (this.deselectLabel = t.deselectLabel),
                      t.valuesUseText && (this.valuesUseText = t.valuesUseText),
                      t.showOptionTooltips && (this.showOptionTooltips = t.showOptionTooltips),
                      t.selectByGroup && (this.selectByGroup = t.selectByGroup),
                      t.limit && (this.limit = t.limit),
                      t.searchFilter && (this.searchFilter = t.searchFilter),
                      null != t.timeoutDelay && (this.timeoutDelay = t.timeoutDelay),
                      (this.addToBody = !0 === t.addToBody);
                  }
                  e.Config = s;
                },
                function (t, e, i) {
                  (e.__esModule = !0), (e.Select = void 0);
                  var s = i(0);
                  function a(t) {
                    (this.triggerMutationObserver = !0),
                      (this.element = t.select),
                      (this.main = t.main),
                      this.element.disabled && (this.main.config.isEnabled = !1),
                      this.addAttributes(),
                      this.addEventListeners(),
                      (this.mutationObserver = null),
                      this.addMutationObserver(),
                      (this.element.slim = t.main);
                  }
                  (a.prototype.setValue = function () {
                    if (this.main.data.getSelected()) {
                      if (this.main.config.isMultiple)
                        for (var t = this.main.data.getSelected(), e = 0, i = this.element.options; e < i.length; e++) {
                          var s = i[e];
                          s.selected = !1;
                          for (var a = 0, n = t; a < n.length; a++) n[a].value === s.value && (s.selected = !0);
                        }
                      else (t = this.main.data.getSelected()), (this.element.value = t ? t.value : "");
                      (this.main.data.isOnChangeEnabled = !1),
                        this.element.dispatchEvent(new CustomEvent("change", { bubbles: !0 })),
                        (this.main.data.isOnChangeEnabled = !0);
                    }
                  }),
                    (a.prototype.addAttributes = function () {
                      (this.element.tabIndex = -1),
                        (this.element.style.display = "none"),
                        (this.element.dataset.ssid = this.main.config.id),
                        this.element.setAttribute("aria-hidden", "true");
                    }),
                    (a.prototype.addEventListeners = function () {
                      var t = this;
                      this.element.addEventListener("change", function (e) {
                        t.main.data.setSelectedFromSelect(), t.main.render();
                      });
                    }),
                    (a.prototype.addMutationObserver = function () {
                      var t = this;
                      this.main.config.isAjax ||
                        ((this.mutationObserver = new MutationObserver(function (e) {
                          t.triggerMutationObserver &&
                            (t.main.data.parseSelectData(),
                            t.main.data.setSelectedFromSelect(),
                            t.main.render(),
                            e.forEach(function (e) {
                              "class" === e.attributeName && t.main.slim.updateContainerDivClass(t.main.slim.container);
                            }));
                        })),
                        this.observeMutationObserver());
                    }),
                    (a.prototype.observeMutationObserver = function () {
                      this.mutationObserver &&
                        this.mutationObserver.observe(this.element, {
                          attributes: !0,
                          childList: !0,
                          characterData: !0,
                        });
                    }),
                    (a.prototype.disconnectMutationObserver = function () {
                      this.mutationObserver && this.mutationObserver.disconnect();
                    }),
                    (a.prototype.create = function (t) {
                      this.element.innerHTML = "";
                      for (var e = 0, i = t; e < i.length; e++) {
                        var s = i[e];
                        if (s.hasOwnProperty("options")) {
                          var a = s,
                            n = document.createElement("optgroup");
                          if (((n.label = a.label), a.options))
                            for (var r = 0, o = a.options; r < o.length; r++) {
                              var l = o[r];
                              n.appendChild(this.createOption(l));
                            }
                          this.element.appendChild(n);
                        } else this.element.appendChild(this.createOption(s));
                      }
                    }),
                    (a.prototype.createOption = function (t) {
                      var e = document.createElement("option");
                      return (
                        (e.value = "" !== t.value ? t.value : t.text),
                        (e.innerHTML = t.innerHTML || t.text),
                        t.selected && (e.selected = t.selected),
                        !1 === t.display && (e.style.display = "none"),
                        t.disabled && (e.disabled = !0),
                        t.placeholder && e.setAttribute("data-placeholder", "true"),
                        t.mandatory && e.setAttribute("data-mandatory", "true"),
                        t.class &&
                          t.class.split(" ").forEach(function (t) {
                            e.classList.add(t);
                          }),
                        t.data &&
                          "object" == typeof t.data &&
                          Object.keys(t.data).forEach(function (i) {
                            e.setAttribute("data-" + (0, s.kebabCase)(i), t.data[i]);
                          }),
                        e
                      );
                    }),
                    (i = a),
                    (e.Select = i);
                },
                function (t, e, i) {
                  (e.__esModule = !0), (e.Slim = void 0);
                  var s = i(0),
                    a = i(1);
                  function n(t) {
                    (this.main = t.main),
                      (this.container = this.containerDiv()),
                      (this.content = this.contentDiv()),
                      (this.search = this.searchDiv()),
                      (this.list = this.listDiv()),
                      this.options(),
                      (this.singleSelected = null),
                      (this.multiSelected = null),
                      this.main.config.isMultiple
                        ? ((this.multiSelected = this.multiSelectedDiv()),
                          this.multiSelected && this.container.appendChild(this.multiSelected.container))
                        : ((this.singleSelected = this.singleSelectedDiv()),
                          this.container.appendChild(this.singleSelected.container)),
                      this.main.config.addToBody
                        ? (this.content.classList.add(this.main.config.id), document.body.appendChild(this.content))
                        : this.container.appendChild(this.content),
                      this.content.appendChild(this.search.container),
                      this.content.appendChild(this.list);
                  }
                  (n.prototype.containerDiv = function () {
                    var t = document.createElement("div");
                    return (t.style.cssText = this.main.config.style), this.updateContainerDivClass(t), t;
                  }),
                    (n.prototype.updateContainerDivClass = function (t) {
                      (this.main.config.class = this.main.select.element.className.split(" ")),
                        (t.className = ""),
                        t.classList.add(this.main.config.id),
                        t.classList.add(this.main.config.main);
                      for (var e = 0, i = this.main.config.class; e < i.length; e++) {
                        var s = i[e];
                        "" !== s.trim() && t.classList.add(s);
                      }
                    }),
                    (n.prototype.singleSelectedDiv = function () {
                      var t = this,
                        e = document.createElement("div");
                      e.classList.add(this.main.config.singleSelected);
                      var i = document.createElement("span");
                      i.classList.add("placeholder"), e.appendChild(i);
                      var s = document.createElement("span");
                      (s.innerHTML = this.main.config.deselectLabel),
                        s.classList.add("ss-deselect"),
                        (s.onclick = function (e) {
                          e.stopPropagation(), t.main.config.isEnabled && t.main.set("");
                        }),
                        e.appendChild(s);
                      var a = document.createElement("span");
                      a.classList.add(this.main.config.arrow);
                      var n = document.createElement("span");
                      return (
                        n.classList.add("arrow-down"),
                        a.appendChild(n),
                        e.appendChild(a),
                        (e.onclick = function () {
                          t.main.config.isEnabled && (t.main.data.contentOpen ? t.main.close() : t.main.open());
                        }),
                        { container: e, placeholder: i, deselect: s, arrowIcon: { container: a, arrow: n } }
                      );
                    }),
                    (n.prototype.placeholder = function () {
                      var t,
                        e = this.main.data.getSelected();
                      null === e || (e && e.placeholder)
                        ? ((t = document.createElement("span")).classList.add(this.main.config.disabled),
                          (t.innerHTML = this.main.config.placeholderText),
                          this.singleSelected && (this.singleSelected.placeholder.innerHTML = t.outerHTML))
                        : ((t = ""),
                          e && (t = e.innerHTML && !0 !== this.main.config.valuesUseText ? e.innerHTML : e.text),
                          this.singleSelected && (this.singleSelected.placeholder.innerHTML = e ? t : ""));
                    }),
                    (n.prototype.deselect = function () {
                      this.singleSelected &&
                        (this.main.config.allowDeselect && "" !== this.main.selected()
                          ? this.singleSelected.deselect.classList.remove("ss-hide")
                          : this.singleSelected.deselect.classList.add("ss-hide"));
                    }),
                    (n.prototype.multiSelectedDiv = function () {
                      var t = this,
                        e = document.createElement("div");
                      e.classList.add(this.main.config.multiSelected);
                      var i = document.createElement("div");
                      i.classList.add(this.main.config.values), e.appendChild(i);
                      var s = document.createElement("div");
                      s.classList.add(this.main.config.add);
                      var a = document.createElement("span");
                      return (
                        a.classList.add(this.main.config.plus),
                        (a.onclick = function (e) {
                          t.main.data.contentOpen && (t.main.close(), e.stopPropagation());
                        }),
                        s.appendChild(a),
                        e.appendChild(s),
                        (e.onclick = function (e) {
                          t.main.config.isEnabled &&
                            (e.target.classList.contains(t.main.config.valueDelete) ||
                              (t.main.data.contentOpen ? t.main.close() : t.main.open()));
                        }),
                        { container: e, values: i, add: s, plus: a }
                      );
                    }),
                    (n.prototype.values = function () {
                      if (this.multiSelected) {
                        for (
                          var t = this.multiSelected.values.childNodes,
                            e = this.main.data.getSelected(),
                            i = [],
                            s = 0,
                            a = t;
                          s < a.length;
                          s++
                        ) {
                          for (var n = a[s], r = !0, o = 0, l = e; o < l.length; o++) {
                            var c = l[o];
                            String(c.id) === String(n.dataset.id) && (r = !1);
                          }
                          r && i.push(n);
                        }
                        for (var h = 0, d = i; h < d.length; h++) {
                          var u = d[h];
                          u.classList.add("ss-out"), this.multiSelected.values.removeChild(u);
                        }
                        var p;
                        for (t = this.multiSelected.values.childNodes, c = 0; c < e.length; c++) {
                          r = !1;
                          for (var g = 0, f = t; g < f.length; g++)
                            (n = f[g]), String(e[c].id) === String(n.dataset.id) && (r = !0);
                          r ||
                            (0 !== t.length && HTMLElement.prototype.insertAdjacentElement
                              ? 0 === c
                                ? this.multiSelected.values.insertBefore(this.valueDiv(e[c]), t[c])
                                : t[c - 1].insertAdjacentElement("afterend", this.valueDiv(e[c]))
                              : this.multiSelected.values.appendChild(this.valueDiv(e[c])));
                        }
                        0 === e.length &&
                          ((p = document.createElement("span")).classList.add(this.main.config.disabled),
                          (p.innerHTML = this.main.config.placeholderText),
                          (this.multiSelected.values.innerHTML = p.outerHTML));
                      }
                    }),
                    (n.prototype.valueDiv = function (t) {
                      var e = this,
                        i = document.createElement("div");
                      i.classList.add(this.main.config.value), (i.dataset.id = t.id);
                      var s = document.createElement("span");
                      return (
                        s.classList.add(this.main.config.valueText),
                        (s.innerHTML = t.innerHTML && !0 !== this.main.config.valuesUseText ? t.innerHTML : t.text),
                        i.appendChild(s),
                        t.mandatory ||
                          ((s = document.createElement("span")).classList.add(this.main.config.valueDelete),
                          (s.innerHTML = this.main.config.deselectLabel),
                          (s.onclick = function (i) {
                            i.preventDefault(), i.stopPropagation();
                            var s = !1;
                            if ((e.main.beforeOnChange || (s = !0), e.main.beforeOnChange)) {
                              i = e.main.data.getSelected();
                              for (var a = JSON.parse(JSON.stringify(i)), n = 0; n < a.length; n++)
                                a[n].id === t.id && a.splice(n, 1);
                              !1 !== e.main.beforeOnChange(a) && (s = !0);
                            }
                            s &&
                              (e.main.data.removeFromSelected(t.id, "id"),
                              e.main.render(),
                              e.main.select.setValue(),
                              e.main.data.onDataChange());
                          }),
                          i.appendChild(s)),
                        i
                      );
                    }),
                    (n.prototype.contentDiv = function () {
                      var t = document.createElement("div");
                      return t.classList.add(this.main.config.content), t;
                    }),
                    (n.prototype.searchDiv = function () {
                      var t = this,
                        e = document.createElement("div"),
                        i = document.createElement("input"),
                        s = document.createElement("div");
                      e.classList.add(this.main.config.search);
                      var n = { container: e, input: i };
                      return (
                        this.main.config.showSearch || (e.classList.add(this.main.config.hide), (i.readOnly = !0)),
                        (i.type = "search"),
                        (i.placeholder = this.main.config.searchPlaceholder),
                        (i.tabIndex = 0),
                        i.setAttribute("aria-label", this.main.config.searchPlaceholder),
                        i.setAttribute("autocapitalize", "off"),
                        i.setAttribute("autocomplete", "off"),
                        i.setAttribute("autocorrect", "off"),
                        (i.onclick = function (e) {
                          setTimeout(function () {
                            "" === e.target.value && t.main.search("");
                          }, 10);
                        }),
                        (i.onkeydown = function (e) {
                          "ArrowUp" === e.key
                            ? (t.main.open(), t.highlightUp(), e.preventDefault())
                            : "ArrowDown" === e.key
                            ? (t.main.open(), t.highlightDown(), e.preventDefault())
                            : "Tab" === e.key
                            ? t.main.data.contentOpen
                              ? t.main.close()
                              : setTimeout(function () {
                                  t.main.close();
                                }, t.main.config.timeoutDelay)
                            : "Enter" === e.key && e.preventDefault();
                        }),
                        (i.onkeyup = function (e) {
                          var a = e.target;
                          if ("Enter" === e.key) {
                            if (t.main.addable && e.ctrlKey)
                              return s.click(), e.preventDefault(), void e.stopPropagation();
                            var n = t.list.querySelector("." + t.main.config.highlighted);
                            n && n.click();
                          } else
                            "ArrowUp" === e.key ||
                              "ArrowDown" === e.key ||
                              ("Escape" === e.key
                                ? t.main.close()
                                : t.main.config.showSearch && t.main.data.contentOpen
                                ? t.main.search(a.value)
                                : (i.value = ""));
                          e.preventDefault(), e.stopPropagation();
                        }),
                        (i.onfocus = function () {
                          t.main.open();
                        }),
                        e.appendChild(i),
                        this.main.addable &&
                          (s.classList.add(this.main.config.addable),
                          (s.innerHTML = "+"),
                          (s.onclick = function (e) {
                            var i;
                            t.main.addable &&
                              (e.preventDefault(),
                              e.stopPropagation(),
                              "" !== (e = t.search.input.value).trim()
                                ? ((e = t.main.addable(e)),
                                  (i = ""),
                                  e &&
                                    ("object" == typeof e
                                      ? (0, a.validateOption)(e) && (t.main.addData(e), (i = e.value || e.text))
                                      : (t.main.addData(t.main.data.newOption({ text: e, value: e })), (i = e)),
                                    t.main.search(""),
                                    setTimeout(function () {
                                      t.main.set(i, "value", !1, !1);
                                    }, 100),
                                    t.main.config.closeOnSelect &&
                                      setTimeout(function () {
                                        t.main.close();
                                      }, 100)))
                                : t.search.input.focus());
                          }),
                          e.appendChild(s),
                          (n.addable = s)),
                        n
                      );
                    }),
                    (n.prototype.highlightUp = function () {
                      var t = this.list.querySelector("." + this.main.config.highlighted),
                        e = null;
                      if (t)
                        for (e = t.previousSibling; null !== e && e.classList.contains(this.main.config.disabled); )
                          e = e.previousSibling;
                      else {
                        var i = this.list.querySelectorAll(
                          "." + this.main.config.option + ":not(." + this.main.config.disabled + ")"
                        );
                        e = i[i.length - 1];
                      }
                      null !== (e = e && e.classList.contains(this.main.config.optgroupLabel) ? null : e) ||
                        ((i = t.parentNode).classList.contains(this.main.config.optgroup) &&
                          (!i.previousSibling ||
                            ((i = i.previousSibling.querySelectorAll(
                              "." + this.main.config.option + ":not(." + this.main.config.disabled + ")"
                            )).length &&
                              (e = i[i.length - 1])))),
                        e &&
                          (t && t.classList.remove(this.main.config.highlighted),
                          e.classList.add(this.main.config.highlighted),
                          (0, s.ensureElementInView)(this.list, e));
                    }),
                    (n.prototype.highlightDown = function () {
                      var t,
                        e = this.list.querySelector("." + this.main.config.highlighted),
                        i = null;
                      if (e)
                        for (i = e.nextSibling; null !== i && i.classList.contains(this.main.config.disabled); )
                          i = i.nextSibling;
                      else
                        i = this.list.querySelector(
                          "." + this.main.config.option + ":not(." + this.main.config.disabled + ")"
                        );
                      null !== i ||
                        null === e ||
                        ((t = e.parentNode).classList.contains(this.main.config.optgroup) &&
                          t.nextSibling &&
                          (i = t.nextSibling.querySelector(
                            "." + this.main.config.option + ":not(." + this.main.config.disabled + ")"
                          ))),
                        i &&
                          (e && e.classList.remove(this.main.config.highlighted),
                          i.classList.add(this.main.config.highlighted),
                          (0, s.ensureElementInView)(this.list, i));
                    }),
                    (n.prototype.listDiv = function () {
                      var t = document.createElement("div");
                      return t.classList.add(this.main.config.list), t.setAttribute("role", "listbox"), t;
                    }),
                    (n.prototype.options = function (t) {
                      void 0 === t && (t = "");
                      var e = this.main.data.filtered || this.main.data.data;
                      if ((this.list.innerHTML = "") !== t)
                        return (
                          (i = document.createElement("div")).classList.add(this.main.config.option),
                          i.classList.add(this.main.config.disabled),
                          (i.innerHTML = t),
                          void this.list.appendChild(i)
                        );
                      if (this.main.config.isAjax && this.main.config.isSearching)
                        return (
                          (i = document.createElement("div")).classList.add(this.main.config.option),
                          i.classList.add(this.main.config.disabled),
                          (i.innerHTML = this.main.config.searchingText),
                          void this.list.appendChild(i)
                        );
                      if (0 === e.length) {
                        var i = document.createElement("div");
                        return (
                          i.classList.add(this.main.config.option),
                          i.classList.add(this.main.config.disabled),
                          (i.innerHTML = this.main.config.searchText),
                          void this.list.appendChild(i)
                        );
                      }
                      for (var s = this, a = 0, n = e; a < n.length; a++)
                        !(function (t) {
                          if (t.hasOwnProperty("label")) {
                            var e = t,
                              i = document.createElement("div");
                            i.classList.add(s.main.config.optgroup);
                            var a = document.createElement("div");
                            if (
                              (a.classList.add(s.main.config.optgroupLabel),
                              s.main.config.selectByGroup &&
                                s.main.config.isMultiple &&
                                a.classList.add(s.main.config.optgroupLabelSelectable),
                              (a.innerHTML = e.label),
                              i.appendChild(a),
                              (e = e.options))
                            ) {
                              for (var n, r = 0, o = e; r < o.length; r++) {
                                var l = o[r];
                                i.appendChild(s.option(l));
                              }
                              s.main.config.selectByGroup &&
                                s.main.config.isMultiple &&
                                ((n = s),
                                a.addEventListener("click", function (t) {
                                  t.preventDefault(), t.stopPropagation();
                                  for (var e = 0, s = i.children; e < s.length; e++) {
                                    var a = s[e];
                                    -1 !== a.className.indexOf(n.main.config.option) && a.click();
                                  }
                                }));
                            }
                            s.list.appendChild(i);
                          } else s.list.appendChild(s.option(t));
                        })(n[a]);
                    }),
                    (n.prototype.option = function (t) {
                      if (t.placeholder) {
                        var e = document.createElement("div");
                        return e.classList.add(this.main.config.option), e.classList.add(this.main.config.hide), e;
                      }
                      var i = document.createElement("div");
                      i.classList.add(this.main.config.option),
                        i.setAttribute("role", "option"),
                        t.class &&
                          t.class.split(" ").forEach(function (t) {
                            i.classList.add(t);
                          }),
                        t.style && (i.style.cssText = t.style);
                      var a = this.main.data.getSelected();
                      (i.dataset.id = t.id),
                        this.main.config.searchHighlight &&
                        this.main.slim &&
                        t.innerHTML &&
                        "" !== this.main.slim.search.input.value.trim()
                          ? (i.innerHTML = (0, s.highlight)(
                              t.innerHTML,
                              this.main.slim.search.input.value,
                              this.main.config.searchHighlighter
                            ))
                          : t.innerHTML && (i.innerHTML = t.innerHTML),
                        this.main.config.showOptionTooltips && i.textContent && i.setAttribute("title", i.textContent);
                      var n = this;
                      return (
                        i.addEventListener("click", function (e) {
                          e.preventDefault(), e.stopPropagation();
                          var i = this.dataset.id;
                          if (!0 === t.selected && n.main.config.allowDeselectOption) {
                            var s = !1;
                            if (
                              ((n.main.beforeOnChange && n.main.config.isMultiple) || (s = !0),
                              n.main.beforeOnChange && n.main.config.isMultiple)
                            ) {
                              for (
                                var r = n.main.data.getSelected(), o = JSON.parse(JSON.stringify(r)), l = 0;
                                l < o.length;
                                l++
                              )
                                o[l].id === i && o.splice(l, 1);
                              !1 !== n.main.beforeOnChange(o) && (s = !0);
                            }
                            s &&
                              (n.main.config.isMultiple
                                ? (n.main.data.removeFromSelected(i, "id"),
                                  n.main.render(),
                                  n.main.select.setValue(),
                                  n.main.data.onDataChange())
                                : n.main.set(""));
                          } else t.disabled || t.selected || (n.main.config.limit && Array.isArray(a) && n.main.config.limit <= a.length) || (n.main.beforeOnChange ? ((r = void 0), ((s = JSON.parse(JSON.stringify(n.main.data.getObjectFromData(i)))).selected = !0), n.main.config.isMultiple ? (r = JSON.parse(JSON.stringify(a))).push(s) : (r = JSON.parse(JSON.stringify(s))), !1 !== n.main.beforeOnChange(r) && n.main.set(i, "id", n.main.config.closeOnSelect)) : n.main.set(i, "id", n.main.config.closeOnSelect));
                        }),
                        (e = a && (0, s.isValueInArrayOfObjects)(a, "id", t.id)),
                        (t.disabled || e) &&
                          ((i.onclick = null),
                          n.main.config.allowDeselectOption || i.classList.add(this.main.config.disabled),
                          n.main.config.hideSelectedOption && i.classList.add(this.main.config.hide)),
                        e
                          ? i.classList.add(this.main.config.optionSelected)
                          : i.classList.remove(this.main.config.optionSelected),
                        i
                      );
                    }),
                    (i = n),
                    (e.Slim = i);
                },
              ]),
            (t.c = i),
            (t.d = function (e, i, s) {
              t.o(e, i) || Object.defineProperty(e, i, { enumerable: !0, get: s });
            }),
            (t.r = function (t) {
              "undefined" != typeof Symbol &&
                Symbol.toStringTag &&
                Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
                Object.defineProperty(t, "__esModule", { value: !0 });
            }),
            (t.t = function (e, i) {
              if ((1 & i && (e = t(e)), 8 & i)) return e;
              if (4 & i && "object" == typeof e && e && e.__esModule) return e;
              var s = Object.create(null);
              if (
                (t.r(s),
                Object.defineProperty(s, "default", { enumerable: !0, value: e }),
                2 & i && "string" != typeof e)
              )
                for (var a in e)
                  t.d(
                    s,
                    a,
                    function (t) {
                      return e[t];
                    }.bind(null, a)
                  );
              return s;
            }),
            (t.n = function (e) {
              var i =
                e && e.__esModule
                  ? function () {
                      return e.default;
                    }
                  : function () {
                      return e;
                    };
              return t.d(i, "a", i), i;
            }),
            (t.o = function (t, e) {
              return Object.prototype.hasOwnProperty.call(t, e);
            }),
            (t.p = ""),
            t((t.s = 2)).default
          );
          function t(s) {
            if (i[s]) return i[s].exports;
            var a = (i[s] = { i: s, l: !1, exports: {} });
            return e[s].call(a.exports, a, a.exports, t), (a.l = !0), a.exports;
          }
          var e, i;
        }),
        "object" == typeof a && "object" == typeof module
          ? (module.exports = s())
          : "function" == typeof define && define.amd
          ? define([], s)
          : "object" == typeof a
          ? (a.SlimSelect = s())
          : (i.SlimSelect = s()),
        (e.Z = a.SlimSelect);
    },
    51: function (t, e, i) {
      "use strict";
      function s(t) {
        return null !== t && "object" == typeof t && "constructor" in t && t.constructor === Object;
      }
      function a(t = {}, e = {}) {
        Object.keys(e).forEach((i) => {
          void 0 === t[i] ? (t[i] = e[i]) : s(e[i]) && s(t[i]) && Object.keys(e[i]).length > 0 && a(t[i], e[i]);
        });
      }
      i.d(e, {
        pt: function () {
          return K;
        },
        oM: function () {
          return Z;
        },
        LW: function () {
          return q;
        },
        ZP: function () {
          return U;
        },
      });
      const n = {
        body: {},
        addEventListener() {},
        removeEventListener() {},
        activeElement: { blur() {}, nodeName: "" },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({ initEvent() {} }),
        createElement: () => ({
          children: [],
          childNodes: [],
          style: {},
          setAttribute() {},
          getElementsByTagName: () => [],
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" },
      };
      function r() {
        const t = "undefined" != typeof document ? document : {};
        return a(t, n), t;
      }
      const o = {
        document: n,
        navigator: { userAgent: "" },
        location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" },
        history: { replaceState() {}, pushState() {}, go() {}, back() {} },
        CustomEvent: function () {
          return this;
        },
        addEventListener() {},
        removeEventListener() {},
        getComputedStyle: () => ({ getPropertyValue: () => "" }),
        Image() {},
        Date() {},
        screen: {},
        setTimeout() {},
        clearTimeout() {},
        matchMedia: () => ({}),
        requestAnimationFrame: (t) => ("undefined" == typeof setTimeout ? (t(), null) : setTimeout(t, 0)),
        cancelAnimationFrame(t) {
          "undefined" != typeof setTimeout && clearTimeout(t);
        },
      };
      function l() {
        const t = "undefined" != typeof window ? window : {};
        return a(t, o), t;
      }
      class c extends Array {
        constructor(t) {
          "number" == typeof t
            ? super(t)
            : (super(...(t || [])),
              (function (t) {
                const e = t.__proto__;
                Object.defineProperty(t, "__proto__", {
                  get: () => e,
                  set(t) {
                    e.__proto__ = t;
                  },
                });
              })(this));
        }
      }
      function h(t = []) {
        const e = [];
        return (
          t.forEach((t) => {
            Array.isArray(t) ? e.push(...h(t)) : e.push(t);
          }),
          e
        );
      }
      function d(t, e) {
        return Array.prototype.filter.call(t, e);
      }
      function u(t, e) {
        const i = l(),
          s = r();
        let a = [];
        if (!e && t instanceof c) return t;
        if (!t) return new c(a);
        if ("string" == typeof t) {
          const i = t.trim();
          if (i.indexOf("<") >= 0 && i.indexOf(">") >= 0) {
            let t = "div";
            0 === i.indexOf("<li") && (t = "ul"),
              0 === i.indexOf("<tr") && (t = "tbody"),
              (0 !== i.indexOf("<td") && 0 !== i.indexOf("<th")) || (t = "tr"),
              0 === i.indexOf("<tbody") && (t = "table"),
              0 === i.indexOf("<option") && (t = "select");
            const e = s.createElement(t);
            e.innerHTML = i;
            for (let t = 0; t < e.childNodes.length; t += 1) a.push(e.childNodes[t]);
          } else
            a = (function (t, e) {
              if ("string" != typeof t) return [t];
              const i = [],
                s = e.querySelectorAll(t);
              for (let t = 0; t < s.length; t += 1) i.push(s[t]);
              return i;
            })(t.trim(), e || s);
        } else if (t.nodeType || t === i || t === s) a.push(t);
        else if (Array.isArray(t)) {
          if (t instanceof c) return t;
          a = t;
        }
        return new c(
          (function (t) {
            const e = [];
            for (let i = 0; i < t.length; i += 1) -1 === e.indexOf(t[i]) && e.push(t[i]);
            return e;
          })(a)
        );
      }
      u.fn = c.prototype;
      const p = "resize scroll".split(" ");
      function g(t) {
        return function (...e) {
          if (void 0 === e[0]) {
            for (let e = 0; e < this.length; e += 1)
              p.indexOf(t) < 0 && (t in this[e] ? this[e][t]() : u(this[e]).trigger(t));
            return this;
          }
          return this.on(t, ...e);
        };
      }
      g("click"),
        g("blur"),
        g("focus"),
        g("focusin"),
        g("focusout"),
        g("keyup"),
        g("keydown"),
        g("keypress"),
        g("submit"),
        g("change"),
        g("mousedown"),
        g("mousemove"),
        g("mouseup"),
        g("mouseenter"),
        g("mouseleave"),
        g("mouseout"),
        g("mouseover"),
        g("touchstart"),
        g("touchend"),
        g("touchmove"),
        g("resize"),
        g("scroll");
      const f = {
        addClass: function (...t) {
          const e = h(t.map((t) => t.split(" ")));
          return (
            this.forEach((t) => {
              t.classList.add(...e);
            }),
            this
          );
        },
        removeClass: function (...t) {
          const e = h(t.map((t) => t.split(" ")));
          return (
            this.forEach((t) => {
              t.classList.remove(...e);
            }),
            this
          );
        },
        hasClass: function (...t) {
          const e = h(t.map((t) => t.split(" ")));
          return d(this, (t) => e.filter((e) => t.classList.contains(e)).length > 0).length > 0;
        },
        toggleClass: function (...t) {
          const e = h(t.map((t) => t.split(" ")));
          this.forEach((t) => {
            e.forEach((e) => {
              t.classList.toggle(e);
            });
          });
        },
        attr: function (t, e) {
          if (1 === arguments.length && "string" == typeof t) return this[0] ? this[0].getAttribute(t) : void 0;
          for (let i = 0; i < this.length; i += 1)
            if (2 === arguments.length) this[i].setAttribute(t, e);
            else for (const e in t) (this[i][e] = t[e]), this[i].setAttribute(e, t[e]);
          return this;
        },
        removeAttr: function (t) {
          for (let e = 0; e < this.length; e += 1) this[e].removeAttribute(t);
          return this;
        },
        transform: function (t) {
          for (let e = 0; e < this.length; e += 1) this[e].style.transform = t;
          return this;
        },
        transition: function (t) {
          for (let e = 0; e < this.length; e += 1)
            this[e].style.transitionDuration = "string" != typeof t ? `${t}ms` : t;
          return this;
        },
        on: function (...t) {
          let [e, i, s, a] = t;
          function n(t) {
            const e = t.target;
            if (!e) return;
            const a = t.target.dom7EventData || [];
            if ((a.indexOf(t) < 0 && a.unshift(t), u(e).is(i))) s.apply(e, a);
            else {
              const t = u(e).parents();
              for (let e = 0; e < t.length; e += 1) u(t[e]).is(i) && s.apply(t[e], a);
            }
          }
          function r(t) {
            const e = (t && t.target && t.target.dom7EventData) || [];
            e.indexOf(t) < 0 && e.unshift(t), s.apply(this, e);
          }
          "function" == typeof t[1] && (([e, s, a] = t), (i = void 0)), a || (a = !1);
          const o = e.split(" ");
          let l;
          for (let t = 0; t < this.length; t += 1) {
            const e = this[t];
            if (i)
              for (l = 0; l < o.length; l += 1) {
                const t = o[l];
                e.dom7LiveListeners || (e.dom7LiveListeners = {}),
                  e.dom7LiveListeners[t] || (e.dom7LiveListeners[t] = []),
                  e.dom7LiveListeners[t].push({ listener: s, proxyListener: n }),
                  e.addEventListener(t, n, a);
              }
            else
              for (l = 0; l < o.length; l += 1) {
                const t = o[l];
                e.dom7Listeners || (e.dom7Listeners = {}),
                  e.dom7Listeners[t] || (e.dom7Listeners[t] = []),
                  e.dom7Listeners[t].push({ listener: s, proxyListener: r }),
                  e.addEventListener(t, r, a);
              }
          }
          return this;
        },
        off: function (...t) {
          let [e, i, s, a] = t;
          "function" == typeof t[1] && (([e, s, a] = t), (i = void 0)), a || (a = !1);
          const n = e.split(" ");
          for (let t = 0; t < n.length; t += 1) {
            const e = n[t];
            for (let t = 0; t < this.length; t += 1) {
              const n = this[t];
              let r;
              if (
                (!i && n.dom7Listeners
                  ? (r = n.dom7Listeners[e])
                  : i && n.dom7LiveListeners && (r = n.dom7LiveListeners[e]),
                r && r.length)
              )
                for (let t = r.length - 1; t >= 0; t -= 1) {
                  const i = r[t];
                  (s && i.listener === s) || (s && i.listener && i.listener.dom7proxy && i.listener.dom7proxy === s)
                    ? (n.removeEventListener(e, i.proxyListener, a), r.splice(t, 1))
                    : s || (n.removeEventListener(e, i.proxyListener, a), r.splice(t, 1));
                }
            }
          }
          return this;
        },
        trigger: function (...t) {
          const e = l(),
            i = t[0].split(" "),
            s = t[1];
          for (let a = 0; a < i.length; a += 1) {
            const n = i[a];
            for (let i = 0; i < this.length; i += 1) {
              const a = this[i];
              if (e.CustomEvent) {
                const i = new e.CustomEvent(n, { detail: s, bubbles: !0, cancelable: !0 });
                (a.dom7EventData = t.filter((t, e) => e > 0)),
                  a.dispatchEvent(i),
                  (a.dom7EventData = []),
                  delete a.dom7EventData;
              }
            }
          }
          return this;
        },
        transitionEnd: function (t) {
          const e = this;
          return (
            t &&
              e.on("transitionend", function i(s) {
                s.target === this && (t.call(this, s), e.off("transitionend", i));
              }),
            this
          );
        },
        outerWidth: function (t) {
          if (this.length > 0) {
            if (t) {
              const t = this.styles();
              return (
                this[0].offsetWidth +
                parseFloat(t.getPropertyValue("margin-right")) +
                parseFloat(t.getPropertyValue("margin-left"))
              );
            }
            return this[0].offsetWidth;
          }
          return null;
        },
        outerHeight: function (t) {
          if (this.length > 0) {
            if (t) {
              const t = this.styles();
              return (
                this[0].offsetHeight +
                parseFloat(t.getPropertyValue("margin-top")) +
                parseFloat(t.getPropertyValue("margin-bottom"))
              );
            }
            return this[0].offsetHeight;
          }
          return null;
        },
        styles: function () {
          const t = l();
          return this[0] ? t.getComputedStyle(this[0], null) : {};
        },
        offset: function () {
          if (this.length > 0) {
            const t = l(),
              e = r(),
              i = this[0],
              s = i.getBoundingClientRect(),
              a = e.body,
              n = i.clientTop || a.clientTop || 0,
              o = i.clientLeft || a.clientLeft || 0,
              c = i === t ? t.scrollY : i.scrollTop,
              h = i === t ? t.scrollX : i.scrollLeft;
            return { top: s.top + c - n, left: s.left + h - o };
          }
          return null;
        },
        css: function (t, e) {
          const i = l();
          let s;
          if (1 === arguments.length) {
            if ("string" != typeof t) {
              for (s = 0; s < this.length; s += 1) for (const e in t) this[s].style[e] = t[e];
              return this;
            }
            if (this[0]) return i.getComputedStyle(this[0], null).getPropertyValue(t);
          }
          if (2 === arguments.length && "string" == typeof t) {
            for (s = 0; s < this.length; s += 1) this[s].style[t] = e;
            return this;
          }
          return this;
        },
        each: function (t) {
          return t
            ? (this.forEach((e, i) => {
                t.apply(e, [e, i]);
              }),
              this)
            : this;
        },
        html: function (t) {
          if (void 0 === t) return this[0] ? this[0].innerHTML : null;
          for (let e = 0; e < this.length; e += 1) this[e].innerHTML = t;
          return this;
        },
        text: function (t) {
          if (void 0 === t) return this[0] ? this[0].textContent.trim() : null;
          for (let e = 0; e < this.length; e += 1) this[e].textContent = t;
          return this;
        },
        is: function (t) {
          const e = l(),
            i = r(),
            s = this[0];
          let a, n;
          if (!s || void 0 === t) return !1;
          if ("string" == typeof t) {
            if (s.matches) return s.matches(t);
            if (s.webkitMatchesSelector) return s.webkitMatchesSelector(t);
            if (s.msMatchesSelector) return s.msMatchesSelector(t);
            for (a = u(t), n = 0; n < a.length; n += 1) if (a[n] === s) return !0;
            return !1;
          }
          if (t === i) return s === i;
          if (t === e) return s === e;
          if (t.nodeType || t instanceof c) {
            for (a = t.nodeType ? [t] : t, n = 0; n < a.length; n += 1) if (a[n] === s) return !0;
            return !1;
          }
          return !1;
        },
        index: function () {
          let t,
            e = this[0];
          if (e) {
            for (t = 0; null !== (e = e.previousSibling); ) 1 === e.nodeType && (t += 1);
            return t;
          }
        },
        eq: function (t) {
          if (void 0 === t) return this;
          const e = this.length;
          if (t > e - 1) return u([]);
          if (t < 0) {
            const i = e + t;
            return u(i < 0 ? [] : [this[i]]);
          }
          return u([this[t]]);
        },
        append: function (...t) {
          let e;
          const i = r();
          for (let s = 0; s < t.length; s += 1) {
            e = t[s];
            for (let t = 0; t < this.length; t += 1)
              if ("string" == typeof e) {
                const s = i.createElement("div");
                for (s.innerHTML = e; s.firstChild; ) this[t].appendChild(s.firstChild);
              } else if (e instanceof c) for (let i = 0; i < e.length; i += 1) this[t].appendChild(e[i]);
              else this[t].appendChild(e);
          }
          return this;
        },
        prepend: function (t) {
          const e = r();
          let i, s;
          for (i = 0; i < this.length; i += 1)
            if ("string" == typeof t) {
              const a = e.createElement("div");
              for (a.innerHTML = t, s = a.childNodes.length - 1; s >= 0; s -= 1)
                this[i].insertBefore(a.childNodes[s], this[i].childNodes[0]);
            } else if (t instanceof c)
              for (s = 0; s < t.length; s += 1) this[i].insertBefore(t[s], this[i].childNodes[0]);
            else this[i].insertBefore(t, this[i].childNodes[0]);
          return this;
        },
        next: function (t) {
          return this.length > 0
            ? t
              ? this[0].nextElementSibling && u(this[0].nextElementSibling).is(t)
                ? u([this[0].nextElementSibling])
                : u([])
              : this[0].nextElementSibling
              ? u([this[0].nextElementSibling])
              : u([])
            : u([]);
        },
        nextAll: function (t) {
          const e = [];
          let i = this[0];
          if (!i) return u([]);
          for (; i.nextElementSibling; ) {
            const s = i.nextElementSibling;
            t ? u(s).is(t) && e.push(s) : e.push(s), (i = s);
          }
          return u(e);
        },
        prev: function (t) {
          if (this.length > 0) {
            const e = this[0];
            return t
              ? e.previousElementSibling && u(e.previousElementSibling).is(t)
                ? u([e.previousElementSibling])
                : u([])
              : e.previousElementSibling
              ? u([e.previousElementSibling])
              : u([]);
          }
          return u([]);
        },
        prevAll: function (t) {
          const e = [];
          let i = this[0];
          if (!i) return u([]);
          for (; i.previousElementSibling; ) {
            const s = i.previousElementSibling;
            t ? u(s).is(t) && e.push(s) : e.push(s), (i = s);
          }
          return u(e);
        },
        parent: function (t) {
          const e = [];
          for (let i = 0; i < this.length; i += 1)
            null !== this[i].parentNode &&
              (t ? u(this[i].parentNode).is(t) && e.push(this[i].parentNode) : e.push(this[i].parentNode));
          return u(e);
        },
        parents: function (t) {
          const e = [];
          for (let i = 0; i < this.length; i += 1) {
            let s = this[i].parentNode;
            for (; s; ) t ? u(s).is(t) && e.push(s) : e.push(s), (s = s.parentNode);
          }
          return u(e);
        },
        closest: function (t) {
          let e = this;
          return void 0 === t ? u([]) : (e.is(t) || (e = e.parents(t).eq(0)), e);
        },
        find: function (t) {
          const e = [];
          for (let i = 0; i < this.length; i += 1) {
            const s = this[i].querySelectorAll(t);
            for (let t = 0; t < s.length; t += 1) e.push(s[t]);
          }
          return u(e);
        },
        children: function (t) {
          const e = [];
          for (let i = 0; i < this.length; i += 1) {
            const s = this[i].children;
            for (let i = 0; i < s.length; i += 1) (t && !u(s[i]).is(t)) || e.push(s[i]);
          }
          return u(e);
        },
        filter: function (t) {
          return u(d(this, t));
        },
        remove: function () {
          for (let t = 0; t < this.length; t += 1) this[t].parentNode && this[t].parentNode.removeChild(this[t]);
          return this;
        },
      };
      Object.keys(f).forEach((t) => {
        Object.defineProperty(u.fn, t, { value: f[t], writable: !0 });
      });
      var m = u;
      function v(t, e = 0) {
        return setTimeout(t, e);
      }
      function x() {
        return Date.now();
      }
      function b(t) {
        return (
          "object" == typeof t &&
          null !== t &&
          t.constructor &&
          "Object" === Object.prototype.toString.call(t).slice(8, -1)
        );
      }
      function y(...t) {
        const e = Object(t[0]),
          i = ["__proto__", "constructor", "prototype"];
        for (let a = 1; a < t.length; a += 1) {
          const n = t[a];
          if (
            null != n &&
            ((s = n),
            !("undefined" != typeof window && void 0 !== window.HTMLElement
              ? s instanceof HTMLElement
              : s && (1 === s.nodeType || 11 === s.nodeType)))
          ) {
            const t = Object.keys(Object(n)).filter((t) => i.indexOf(t) < 0);
            for (let i = 0, s = t.length; i < s; i += 1) {
              const s = t[i],
                a = Object.getOwnPropertyDescriptor(n, s);
              void 0 !== a &&
                a.enumerable &&
                (b(e[s]) && b(n[s])
                  ? n[s].__swiper__
                    ? (e[s] = n[s])
                    : y(e[s], n[s])
                  : !b(e[s]) && b(n[s])
                  ? ((e[s] = {}), n[s].__swiper__ ? (e[s] = n[s]) : y(e[s], n[s]))
                  : (e[s] = n[s]));
            }
          }
        }
        var s;
        return e;
      }
      function w(t, e, i) {
        t.style.setProperty(e, i);
      }
      function k({ swiper: t, targetPosition: e, side: i }) {
        const s = l(),
          a = -t.translate;
        let n,
          r = null;
        const o = t.params.speed;
        (t.wrapperEl.style.scrollSnapType = "none"), s.cancelAnimationFrame(t.cssModeFrameID);
        const c = e > a ? "next" : "prev",
          h = (t, e) => ("next" === c && t >= e) || ("prev" === c && t <= e),
          d = () => {
            (n = new Date().getTime()), null === r && (r = n);
            const l = Math.max(Math.min((n - r) / o, 1), 0),
              c = 0.5 - Math.cos(l * Math.PI) / 2;
            let u = a + c * (e - a);
            if ((h(u, e) && (u = e), t.wrapperEl.scrollTo({ [i]: u }), h(u, e)))
              return (
                (t.wrapperEl.style.overflow = "hidden"),
                (t.wrapperEl.style.scrollSnapType = ""),
                setTimeout(() => {
                  (t.wrapperEl.style.overflow = ""), t.wrapperEl.scrollTo({ [i]: u });
                }),
                void s.cancelAnimationFrame(t.cssModeFrameID)
              );
            t.cssModeFrameID = s.requestAnimationFrame(d);
          };
        d();
      }
      let S, C, A;
      function E() {
        return (
          S ||
            (S = (function () {
              const t = l(),
                e = r();
              return {
                smoothScroll: e.documentElement && "scrollBehavior" in e.documentElement.style,
                touch: !!("ontouchstart" in t || (t.DocumentTouch && e instanceof t.DocumentTouch)),
                passiveListener: (function () {
                  let e = !1;
                  try {
                    const i = Object.defineProperty({}, "passive", {
                      get() {
                        e = !0;
                      },
                    });
                    t.addEventListener("testPassiveListener", null, i);
                  } catch (t) {}
                  return e;
                })(),
                gestures: "ongesturestart" in t,
              };
            })()),
          S
        );
      }
      var T = {
          on(t, e, i) {
            const s = this;
            if (!s.eventsListeners || s.destroyed) return s;
            if ("function" != typeof e) return s;
            const a = i ? "unshift" : "push";
            return (
              t.split(" ").forEach((t) => {
                s.eventsListeners[t] || (s.eventsListeners[t] = []), s.eventsListeners[t][a](e);
              }),
              s
            );
          },
          once(t, e, i) {
            const s = this;
            if (!s.eventsListeners || s.destroyed) return s;
            if ("function" != typeof e) return s;
            function a(...i) {
              s.off(t, a), a.__emitterProxy && delete a.__emitterProxy, e.apply(s, i);
            }
            return (a.__emitterProxy = e), s.on(t, a, i);
          },
          onAny(t, e) {
            const i = this;
            if (!i.eventsListeners || i.destroyed) return i;
            if ("function" != typeof t) return i;
            const s = e ? "unshift" : "push";
            return i.eventsAnyListeners.indexOf(t) < 0 && i.eventsAnyListeners[s](t), i;
          },
          offAny(t) {
            const e = this;
            if (!e.eventsListeners || e.destroyed) return e;
            if (!e.eventsAnyListeners) return e;
            const i = e.eventsAnyListeners.indexOf(t);
            return i >= 0 && e.eventsAnyListeners.splice(i, 1), e;
          },
          off(t, e) {
            const i = this;
            return !i.eventsListeners || i.destroyed
              ? i
              : i.eventsListeners
              ? (t.split(" ").forEach((t) => {
                  void 0 === e
                    ? (i.eventsListeners[t] = [])
                    : i.eventsListeners[t] &&
                      i.eventsListeners[t].forEach((s, a) => {
                        (s === e || (s.__emitterProxy && s.__emitterProxy === e)) && i.eventsListeners[t].splice(a, 1);
                      });
                }),
                i)
              : i;
          },
          emit(...t) {
            const e = this;
            if (!e.eventsListeners || e.destroyed) return e;
            if (!e.eventsListeners) return e;
            let i, s, a;
            return (
              "string" == typeof t[0] || Array.isArray(t[0])
                ? ((i = t[0]), (s = t.slice(1, t.length)), (a = e))
                : ((i = t[0].events), (s = t[0].data), (a = t[0].context || e)),
              s.unshift(a),
              (Array.isArray(i) ? i : i.split(" ")).forEach((t) => {
                e.eventsAnyListeners &&
                  e.eventsAnyListeners.length &&
                  e.eventsAnyListeners.forEach((e) => {
                    e.apply(a, [t, ...s]);
                  }),
                  e.eventsListeners &&
                    e.eventsListeners[t] &&
                    e.eventsListeners[t].forEach((t) => {
                      t.apply(a, s);
                    });
              }),
              e
            );
          },
        },
        L = {
          updateSize: function () {
            const t = this;
            let e, i;
            const s = t.$el;
            (e = void 0 !== t.params.width && null !== t.params.width ? t.params.width : s[0].clientWidth),
              (i = void 0 !== t.params.height && null !== t.params.height ? t.params.height : s[0].clientHeight),
              (0 === e && t.isHorizontal()) ||
                (0 === i && t.isVertical()) ||
                ((e = e - parseInt(s.css("padding-left") || 0, 10) - parseInt(s.css("padding-right") || 0, 10)),
                (i = i - parseInt(s.css("padding-top") || 0, 10) - parseInt(s.css("padding-bottom") || 0, 10)),
                Number.isNaN(e) && (e = 0),
                Number.isNaN(i) && (i = 0),
                Object.assign(t, { width: e, height: i, size: t.isHorizontal() ? e : i }));
          },
          updateSlides: function () {
            const t = this;
            function e(e) {
              return t.isHorizontal()
                ? e
                : {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom",
                  }[e];
            }
            function i(t, i) {
              return parseFloat(t.getPropertyValue(e(i)) || 0);
            }
            const s = t.params,
              { $wrapperEl: a, size: n, rtlTranslate: r, wrongRTL: o } = t,
              l = t.virtual && s.virtual.enabled,
              c = l ? t.virtual.slides.length : t.slides.length,
              h = a.children(`.${t.params.slideClass}`),
              d = l ? t.virtual.slides.length : h.length;
            let u = [];
            const p = [],
              g = [];
            let f = s.slidesOffsetBefore;
            "function" == typeof f && (f = s.slidesOffsetBefore.call(t));
            let m = s.slidesOffsetAfter;
            "function" == typeof m && (m = s.slidesOffsetAfter.call(t));
            const v = t.snapGrid.length,
              x = t.slidesGrid.length;
            let b = s.spaceBetween,
              y = -f,
              k = 0,
              S = 0;
            if (void 0 === n) return;
            "string" == typeof b && b.indexOf("%") >= 0 && (b = (parseFloat(b.replace("%", "")) / 100) * n),
              (t.virtualSize = -b),
              r
                ? h.css({ marginLeft: "", marginBottom: "", marginTop: "" })
                : h.css({ marginRight: "", marginBottom: "", marginTop: "" }),
              s.centeredSlides &&
                s.cssMode &&
                (w(t.wrapperEl, "--swiper-centered-offset-before", ""),
                w(t.wrapperEl, "--swiper-centered-offset-after", ""));
            const C = s.grid && s.grid.rows > 1 && t.grid;
            let A;
            C && t.grid.initSlides(d);
            const E =
              "auto" === s.slidesPerView &&
              s.breakpoints &&
              Object.keys(s.breakpoints).filter((t) => void 0 !== s.breakpoints[t].slidesPerView).length > 0;
            for (let a = 0; a < d; a += 1) {
              A = 0;
              const r = h.eq(a);
              if ((C && t.grid.updateSlide(a, r, d, e), "none" !== r.css("display"))) {
                if ("auto" === s.slidesPerView) {
                  E && (h[a].style[e("width")] = "");
                  const n = getComputedStyle(r[0]),
                    o = r[0].style.transform,
                    l = r[0].style.webkitTransform;
                  if (
                    (o && (r[0].style.transform = "none"), l && (r[0].style.webkitTransform = "none"), s.roundLengths)
                  )
                    A = t.isHorizontal() ? r.outerWidth(!0) : r.outerHeight(!0);
                  else {
                    const t = i(n, "width"),
                      e = i(n, "padding-left"),
                      s = i(n, "padding-right"),
                      a = i(n, "margin-left"),
                      o = i(n, "margin-right"),
                      l = n.getPropertyValue("box-sizing");
                    if (l && "border-box" === l) A = t + a + o;
                    else {
                      const { clientWidth: i, offsetWidth: n } = r[0];
                      A = t + e + s + a + o + (n - i);
                    }
                  }
                  o && (r[0].style.transform = o),
                    l && (r[0].style.webkitTransform = l),
                    s.roundLengths && (A = Math.floor(A));
                } else
                  (A = (n - (s.slidesPerView - 1) * b) / s.slidesPerView),
                    s.roundLengths && (A = Math.floor(A)),
                    h[a] && (h[a].style[e("width")] = `${A}px`);
                h[a] && (h[a].swiperSlideSize = A),
                  g.push(A),
                  s.centeredSlides
                    ? ((y = y + A / 2 + k / 2 + b),
                      0 === k && 0 !== a && (y = y - n / 2 - b),
                      0 === a && (y = y - n / 2 - b),
                      Math.abs(y) < 0.001 && (y = 0),
                      s.roundLengths && (y = Math.floor(y)),
                      S % s.slidesPerGroup == 0 && u.push(y),
                      p.push(y))
                    : (s.roundLengths && (y = Math.floor(y)),
                      (S - Math.min(t.params.slidesPerGroupSkip, S)) % t.params.slidesPerGroup == 0 && u.push(y),
                      p.push(y),
                      (y = y + A + b)),
                  (t.virtualSize += A + b),
                  (k = A),
                  (S += 1);
              }
            }
            if (
              ((t.virtualSize = Math.max(t.virtualSize, n) + m),
              r &&
                o &&
                ("slide" === s.effect || "coverflow" === s.effect) &&
                a.css({ width: `${t.virtualSize + s.spaceBetween}px` }),
              s.setWrapperSize && a.css({ [e("width")]: `${t.virtualSize + s.spaceBetween}px` }),
              C && t.grid.updateWrapperSize(A, u, e),
              !s.centeredSlides)
            ) {
              const e = [];
              for (let i = 0; i < u.length; i += 1) {
                let a = u[i];
                s.roundLengths && (a = Math.floor(a)), u[i] <= t.virtualSize - n && e.push(a);
              }
              (u = e), Math.floor(t.virtualSize - n) - Math.floor(u[u.length - 1]) > 1 && u.push(t.virtualSize - n);
            }
            if ((0 === u.length && (u = [0]), 0 !== s.spaceBetween)) {
              const i = t.isHorizontal() && r ? "marginLeft" : e("marginRight");
              h.filter((t, e) => !s.cssMode || e !== h.length - 1).css({ [i]: `${b}px` });
            }
            if (s.centeredSlides && s.centeredSlidesBounds) {
              let t = 0;
              g.forEach((e) => {
                t += e + (s.spaceBetween ? s.spaceBetween : 0);
              }),
                (t -= s.spaceBetween);
              const e = t - n;
              u = u.map((t) => (t < 0 ? -f : t > e ? e + m : t));
            }
            if (s.centerInsufficientSlides) {
              let t = 0;
              if (
                (g.forEach((e) => {
                  t += e + (s.spaceBetween ? s.spaceBetween : 0);
                }),
                (t -= s.spaceBetween),
                t < n)
              ) {
                const e = (n - t) / 2;
                u.forEach((t, i) => {
                  u[i] = t - e;
                }),
                  p.forEach((t, i) => {
                    p[i] = t + e;
                  });
              }
            }
            if (
              (Object.assign(t, { slides: h, snapGrid: u, slidesGrid: p, slidesSizesGrid: g }),
              s.centeredSlides && s.cssMode && !s.centeredSlidesBounds)
            ) {
              w(t.wrapperEl, "--swiper-centered-offset-before", -u[0] + "px"),
                w(t.wrapperEl, "--swiper-centered-offset-after", t.size / 2 - g[g.length - 1] / 2 + "px");
              const e = -t.snapGrid[0],
                i = -t.slidesGrid[0];
              (t.snapGrid = t.snapGrid.map((t) => t + e)), (t.slidesGrid = t.slidesGrid.map((t) => t + i));
            }
            if (
              (d !== c && t.emit("slidesLengthChange"),
              u.length !== v && (t.params.watchOverflow && t.checkOverflow(), t.emit("snapGridLengthChange")),
              p.length !== x && t.emit("slidesGridLengthChange"),
              s.watchSlidesProgress && t.updateSlidesOffset(),
              !(l || s.cssMode || ("slide" !== s.effect && "fade" !== s.effect)))
            ) {
              const e = `${s.containerModifierClass}backface-hidden`,
                i = t.$el.hasClass(e);
              d <= s.maxBackfaceHiddenSlides ? i || t.$el.addClass(e) : i && t.$el.removeClass(e);
            }
          },
          updateAutoHeight: function (t) {
            const e = this,
              i = [],
              s = e.virtual && e.params.virtual.enabled;
            let a,
              n = 0;
            "number" == typeof t ? e.setTransition(t) : !0 === t && e.setTransition(e.params.speed);
            const r = (t) =>
              s
                ? e.slides.filter((e) => parseInt(e.getAttribute("data-swiper-slide-index"), 10) === t)[0]
                : e.slides.eq(t)[0];
            if ("auto" !== e.params.slidesPerView && e.params.slidesPerView > 1)
              if (e.params.centeredSlides)
                (e.visibleSlides || m([])).each((t) => {
                  i.push(t);
                });
              else
                for (a = 0; a < Math.ceil(e.params.slidesPerView); a += 1) {
                  const t = e.activeIndex + a;
                  if (t > e.slides.length && !s) break;
                  i.push(r(t));
                }
            else i.push(r(e.activeIndex));
            for (a = 0; a < i.length; a += 1)
              if (void 0 !== i[a]) {
                const t = i[a].offsetHeight;
                n = t > n ? t : n;
              }
            (n || 0 === n) && e.$wrapperEl.css("height", `${n}px`);
          },
          updateSlidesOffset: function () {
            const t = this,
              e = t.slides;
            for (let i = 0; i < e.length; i += 1)
              e[i].swiperSlideOffset = t.isHorizontal() ? e[i].offsetLeft : e[i].offsetTop;
          },
          updateSlidesProgress: function (t = (this && this.translate) || 0) {
            const e = this,
              i = e.params,
              { slides: s, rtlTranslate: a, snapGrid: n } = e;
            if (0 === s.length) return;
            void 0 === s[0].swiperSlideOffset && e.updateSlidesOffset();
            let r = -t;
            a && (r = t), s.removeClass(i.slideVisibleClass), (e.visibleSlidesIndexes = []), (e.visibleSlides = []);
            for (let t = 0; t < s.length; t += 1) {
              const o = s[t];
              let l = o.swiperSlideOffset;
              i.cssMode && i.centeredSlides && (l -= s[0].swiperSlideOffset);
              const c = (r + (i.centeredSlides ? e.minTranslate() : 0) - l) / (o.swiperSlideSize + i.spaceBetween),
                h = (r - n[0] + (i.centeredSlides ? e.minTranslate() : 0) - l) / (o.swiperSlideSize + i.spaceBetween),
                d = -(r - l),
                u = d + e.slidesSizesGrid[t];
              ((d >= 0 && d < e.size - 1) || (u > 1 && u <= e.size) || (d <= 0 && u >= e.size)) &&
                (e.visibleSlides.push(o), e.visibleSlidesIndexes.push(t), s.eq(t).addClass(i.slideVisibleClass)),
                (o.progress = a ? -c : c),
                (o.originalProgress = a ? -h : h);
            }
            e.visibleSlides = m(e.visibleSlides);
          },
          updateProgress: function (t) {
            const e = this;
            if (void 0 === t) {
              const i = e.rtlTranslate ? -1 : 1;
              t = (e && e.translate && e.translate * i) || 0;
            }
            const i = e.params,
              s = e.maxTranslate() - e.minTranslate();
            let { progress: a, isBeginning: n, isEnd: r } = e;
            const o = n,
              l = r;
            0 === s ? ((a = 0), (n = !0), (r = !0)) : ((a = (t - e.minTranslate()) / s), (n = a <= 0), (r = a >= 1)),
              Object.assign(e, { progress: a, isBeginning: n, isEnd: r }),
              (i.watchSlidesProgress || (i.centeredSlides && i.autoHeight)) && e.updateSlidesProgress(t),
              n && !o && e.emit("reachBeginning toEdge"),
              r && !l && e.emit("reachEnd toEdge"),
              ((o && !n) || (l && !r)) && e.emit("fromEdge"),
              e.emit("progress", a);
          },
          updateSlidesClasses: function () {
            const t = this,
              { slides: e, params: i, $wrapperEl: s, activeIndex: a, realIndex: n } = t,
              r = t.virtual && i.virtual.enabled;
            let o;
            e.removeClass(
              `${i.slideActiveClass} ${i.slideNextClass} ${i.slidePrevClass} ${i.slideDuplicateActiveClass} ${i.slideDuplicateNextClass} ${i.slideDuplicatePrevClass}`
            ),
              (o = r ? t.$wrapperEl.find(`.${i.slideClass}[data-swiper-slide-index="${a}"]`) : e.eq(a)),
              o.addClass(i.slideActiveClass),
              i.loop &&
                (o.hasClass(i.slideDuplicateClass)
                  ? s
                      .children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${n}"]`)
                      .addClass(i.slideDuplicateActiveClass)
                  : s
                      .children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${n}"]`)
                      .addClass(i.slideDuplicateActiveClass));
            let l = o.nextAll(`.${i.slideClass}`).eq(0).addClass(i.slideNextClass);
            i.loop && 0 === l.length && ((l = e.eq(0)), l.addClass(i.slideNextClass));
            let c = o.prevAll(`.${i.slideClass}`).eq(0).addClass(i.slidePrevClass);
            i.loop && 0 === c.length && ((c = e.eq(-1)), c.addClass(i.slidePrevClass)),
              i.loop &&
                (l.hasClass(i.slideDuplicateClass)
                  ? s
                      .children(
                        `.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${l.attr(
                          "data-swiper-slide-index"
                        )}"]`
                      )
                      .addClass(i.slideDuplicateNextClass)
                  : s
                      .children(
                        `.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${l.attr(
                          "data-swiper-slide-index"
                        )}"]`
                      )
                      .addClass(i.slideDuplicateNextClass),
                c.hasClass(i.slideDuplicateClass)
                  ? s
                      .children(
                        `.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${c.attr(
                          "data-swiper-slide-index"
                        )}"]`
                      )
                      .addClass(i.slideDuplicatePrevClass)
                  : s
                      .children(
                        `.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${c.attr(
                          "data-swiper-slide-index"
                        )}"]`
                      )
                      .addClass(i.slideDuplicatePrevClass)),
              t.emitSlidesClasses();
          },
          updateActiveIndex: function (t) {
            const e = this,
              i = e.rtlTranslate ? e.translate : -e.translate,
              { slidesGrid: s, snapGrid: a, params: n, activeIndex: r, realIndex: o, snapIndex: l } = e;
            let c,
              h = t;
            if (void 0 === h) {
              for (let t = 0; t < s.length; t += 1)
                void 0 !== s[t + 1]
                  ? i >= s[t] && i < s[t + 1] - (s[t + 1] - s[t]) / 2
                    ? (h = t)
                    : i >= s[t] && i < s[t + 1] && (h = t + 1)
                  : i >= s[t] && (h = t);
              n.normalizeSlideIndex && (h < 0 || void 0 === h) && (h = 0);
            }
            if (a.indexOf(i) >= 0) c = a.indexOf(i);
            else {
              const t = Math.min(n.slidesPerGroupSkip, h);
              c = t + Math.floor((h - t) / n.slidesPerGroup);
            }
            if ((c >= a.length && (c = a.length - 1), h === r))
              return void (c !== l && ((e.snapIndex = c), e.emit("snapIndexChange")));
            const d = parseInt(e.slides.eq(h).attr("data-swiper-slide-index") || h, 10);
            Object.assign(e, { snapIndex: c, realIndex: d, previousIndex: r, activeIndex: h }),
              e.emit("activeIndexChange"),
              e.emit("snapIndexChange"),
              o !== d && e.emit("realIndexChange"),
              (e.initialized || e.params.runCallbacksOnInit) && e.emit("slideChange");
          },
          updateClickedSlide: function (t) {
            const e = this,
              i = e.params,
              s = m(t).closest(`.${i.slideClass}`)[0];
            let a,
              n = !1;
            if (s)
              for (let t = 0; t < e.slides.length; t += 1)
                if (e.slides[t] === s) {
                  (n = !0), (a = t);
                  break;
                }
            if (!s || !n) return (e.clickedSlide = void 0), void (e.clickedIndex = void 0);
            (e.clickedSlide = s),
              e.virtual && e.params.virtual.enabled
                ? (e.clickedIndex = parseInt(m(s).attr("data-swiper-slide-index"), 10))
                : (e.clickedIndex = a),
              i.slideToClickedSlide &&
                void 0 !== e.clickedIndex &&
                e.clickedIndex !== e.activeIndex &&
                e.slideToClickedSlide();
          },
        };
      function P({ swiper: t, runCallbacks: e, direction: i, step: s }) {
        const { activeIndex: a, previousIndex: n } = t;
        let r = i;
        if ((r || (r = a > n ? "next" : a < n ? "prev" : "reset"), t.emit(`transition${s}`), e && a !== n)) {
          if ("reset" === r) return void t.emit(`slideResetTransition${s}`);
          t.emit(`slideChangeTransition${s}`),
            "next" === r ? t.emit(`slideNextTransition${s}`) : t.emit(`slidePrevTransition${s}`);
        }
      }
      var M = {
        slideTo: function (t = 0, e = this.params.speed, i = !0, s, a) {
          if ("number" != typeof t && "string" != typeof t)
            throw new Error(
              `The 'index' argument cannot have type other than 'number' or 'string'. [${typeof t}] given.`
            );
          if ("string" == typeof t) {
            const e = parseInt(t, 10);
            if (!isFinite(e))
              throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${t}] given.`);
            t = e;
          }
          const n = this;
          let r = t;
          r < 0 && (r = 0);
          const {
            params: o,
            snapGrid: l,
            slidesGrid: c,
            previousIndex: h,
            activeIndex: d,
            rtlTranslate: u,
            wrapperEl: p,
            enabled: g,
          } = n;
          if ((n.animating && o.preventInteractionOnTransition) || (!g && !s && !a)) return !1;
          const f = Math.min(n.params.slidesPerGroupSkip, r);
          let m = f + Math.floor((r - f) / n.params.slidesPerGroup);
          m >= l.length && (m = l.length - 1);
          const v = -l[m];
          if (o.normalizeSlideIndex)
            for (let t = 0; t < c.length; t += 1) {
              const e = -Math.floor(100 * v),
                i = Math.floor(100 * c[t]),
                s = Math.floor(100 * c[t + 1]);
              void 0 !== c[t + 1]
                ? e >= i && e < s - (s - i) / 2
                  ? (r = t)
                  : e >= i && e < s && (r = t + 1)
                : e >= i && (r = t);
            }
          if (n.initialized && r !== d) {
            if (!n.allowSlideNext && v < n.translate && v < n.minTranslate()) return !1;
            if (!n.allowSlidePrev && v > n.translate && v > n.maxTranslate() && (d || 0) !== r) return !1;
          }
          let x;
          if (
            (r !== (h || 0) && i && n.emit("beforeSlideChangeStart"),
            n.updateProgress(v),
            (x = r > d ? "next" : r < d ? "prev" : "reset"),
            (u && -v === n.translate) || (!u && v === n.translate))
          )
            return (
              n.updateActiveIndex(r),
              o.autoHeight && n.updateAutoHeight(),
              n.updateSlidesClasses(),
              "slide" !== o.effect && n.setTranslate(v),
              "reset" !== x && (n.transitionStart(i, x), n.transitionEnd(i, x)),
              !1
            );
          if (o.cssMode) {
            const t = n.isHorizontal(),
              i = u ? v : -v;
            if (0 === e) {
              const e = n.virtual && n.params.virtual.enabled;
              e && ((n.wrapperEl.style.scrollSnapType = "none"), (n._immediateVirtual = !0)),
                (p[t ? "scrollLeft" : "scrollTop"] = i),
                e &&
                  requestAnimationFrame(() => {
                    (n.wrapperEl.style.scrollSnapType = ""), (n._swiperImmediateVirtual = !1);
                  });
            } else {
              if (!n.support.smoothScroll) return k({ swiper: n, targetPosition: i, side: t ? "left" : "top" }), !0;
              p.scrollTo({ [t ? "left" : "top"]: i, behavior: "smooth" });
            }
            return !0;
          }
          return (
            n.setTransition(e),
            n.setTranslate(v),
            n.updateActiveIndex(r),
            n.updateSlidesClasses(),
            n.emit("beforeTransitionStart", e, s),
            n.transitionStart(i, x),
            0 === e
              ? n.transitionEnd(i, x)
              : n.animating ||
                ((n.animating = !0),
                n.onSlideToWrapperTransitionEnd ||
                  (n.onSlideToWrapperTransitionEnd = function (t) {
                    n &&
                      !n.destroyed &&
                      t.target === this &&
                      (n.$wrapperEl[0].removeEventListener("transitionend", n.onSlideToWrapperTransitionEnd),
                      n.$wrapperEl[0].removeEventListener("webkitTransitionEnd", n.onSlideToWrapperTransitionEnd),
                      (n.onSlideToWrapperTransitionEnd = null),
                      delete n.onSlideToWrapperTransitionEnd,
                      n.transitionEnd(i, x));
                  }),
                n.$wrapperEl[0].addEventListener("transitionend", n.onSlideToWrapperTransitionEnd),
                n.$wrapperEl[0].addEventListener("webkitTransitionEnd", n.onSlideToWrapperTransitionEnd)),
            !0
          );
        },
        slideToLoop: function (t = 0, e = this.params.speed, i = !0, s) {
          if ("string" == typeof t) {
            const e = parseInt(t, 10);
            if (!isFinite(e))
              throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${t}] given.`);
            t = e;
          }
          const a = this;
          let n = t;
          return a.params.loop && (n += a.loopedSlides), a.slideTo(n, e, i, s);
        },
        slideNext: function (t = this.params.speed, e = !0, i) {
          const s = this,
            { animating: a, enabled: n, params: r } = s;
          if (!n) return s;
          let o = r.slidesPerGroup;
          "auto" === r.slidesPerView &&
            1 === r.slidesPerGroup &&
            r.slidesPerGroupAuto &&
            (o = Math.max(s.slidesPerViewDynamic("current", !0), 1));
          const l = s.activeIndex < r.slidesPerGroupSkip ? 1 : o;
          if (r.loop) {
            if (a && r.loopPreventsSlide) return !1;
            s.loopFix(), (s._clientLeft = s.$wrapperEl[0].clientLeft);
          }
          return r.rewind && s.isEnd ? s.slideTo(0, t, e, i) : s.slideTo(s.activeIndex + l, t, e, i);
        },
        slidePrev: function (t = this.params.speed, e = !0, i) {
          const s = this,
            { params: a, animating: n, snapGrid: r, slidesGrid: o, rtlTranslate: l, enabled: c } = s;
          if (!c) return s;
          if (a.loop) {
            if (n && a.loopPreventsSlide) return !1;
            s.loopFix(), (s._clientLeft = s.$wrapperEl[0].clientLeft);
          }
          function h(t) {
            return t < 0 ? -Math.floor(Math.abs(t)) : Math.floor(t);
          }
          const d = h(l ? s.translate : -s.translate),
            u = r.map((t) => h(t));
          let p = r[u.indexOf(d) - 1];
          if (void 0 === p && a.cssMode) {
            let t;
            r.forEach((e, i) => {
              d >= e && (t = i);
            }),
              void 0 !== t && (p = r[t > 0 ? t - 1 : t]);
          }
          let g = 0;
          if (
            (void 0 !== p &&
              ((g = o.indexOf(p)),
              g < 0 && (g = s.activeIndex - 1),
              "auto" === a.slidesPerView &&
                1 === a.slidesPerGroup &&
                a.slidesPerGroupAuto &&
                ((g = g - s.slidesPerViewDynamic("previous", !0) + 1), (g = Math.max(g, 0)))),
            a.rewind && s.isBeginning)
          ) {
            const a =
              s.params.virtual && s.params.virtual.enabled && s.virtual
                ? s.virtual.slides.length - 1
                : s.slides.length - 1;
            return s.slideTo(a, t, e, i);
          }
          return s.slideTo(g, t, e, i);
        },
        slideReset: function (t = this.params.speed, e = !0, i) {
          return this.slideTo(this.activeIndex, t, e, i);
        },
        slideToClosest: function (t = this.params.speed, e = !0, i, s = 0.5) {
          const a = this;
          let n = a.activeIndex;
          const r = Math.min(a.params.slidesPerGroupSkip, n),
            o = r + Math.floor((n - r) / a.params.slidesPerGroup),
            l = a.rtlTranslate ? a.translate : -a.translate;
          if (l >= a.snapGrid[o]) {
            const t = a.snapGrid[o];
            l - t > (a.snapGrid[o + 1] - t) * s && (n += a.params.slidesPerGroup);
          } else {
            const t = a.snapGrid[o - 1];
            l - t <= (a.snapGrid[o] - t) * s && (n -= a.params.slidesPerGroup);
          }
          return (n = Math.max(n, 0)), (n = Math.min(n, a.slidesGrid.length - 1)), a.slideTo(n, t, e, i);
        },
        slideToClickedSlide: function () {
          const t = this,
            { params: e, $wrapperEl: i } = t,
            s = "auto" === e.slidesPerView ? t.slidesPerViewDynamic() : e.slidesPerView;
          let a,
            n = t.clickedIndex;
          if (e.loop) {
            if (t.animating) return;
            (a = parseInt(m(t.clickedSlide).attr("data-swiper-slide-index"), 10)),
              e.centeredSlides
                ? n < t.loopedSlides - s / 2 || n > t.slides.length - t.loopedSlides + s / 2
                  ? (t.loopFix(),
                    (n = i
                      .children(`.${e.slideClass}[data-swiper-slide-index="${a}"]:not(.${e.slideDuplicateClass})`)
                      .eq(0)
                      .index()),
                    v(() => {
                      t.slideTo(n);
                    }))
                  : t.slideTo(n)
                : n > t.slides.length - s
                ? (t.loopFix(),
                  (n = i
                    .children(`.${e.slideClass}[data-swiper-slide-index="${a}"]:not(.${e.slideDuplicateClass})`)
                    .eq(0)
                    .index()),
                  v(() => {
                    t.slideTo(n);
                  }))
                : t.slideTo(n);
          } else t.slideTo(n);
        },
      };
      function O(t) {
        const e = this,
          i = r(),
          s = l(),
          a = e.touchEventsData,
          { params: n, touches: o, enabled: c } = e;
        if (!c) return;
        if (e.animating && n.preventInteractionOnTransition) return;
        !e.animating && n.cssMode && n.loop && e.loopFix();
        let h = t;
        h.originalEvent && (h = h.originalEvent);
        let d = m(h.target);
        if ("wrapper" === n.touchEventsTarget && !d.closest(e.wrapperEl).length) return;
        if (((a.isTouchEvent = "touchstart" === h.type), !a.isTouchEvent && "which" in h && 3 === h.which)) return;
        if (!a.isTouchEvent && "button" in h && h.button > 0) return;
        if (a.isTouched && a.isMoved) return;
        const u = !!n.noSwipingClass && "" !== n.noSwipingClass,
          p = t.composedPath ? t.composedPath() : t.path;
        u && h.target && h.target.shadowRoot && p && (d = m(p[0]));
        const g = n.noSwipingSelector ? n.noSwipingSelector : `.${n.noSwipingClass}`,
          f = !(!h.target || !h.target.shadowRoot);
        if (
          n.noSwiping &&
          (f
            ? (function (t, e = this) {
                return (function e(i) {
                  if (!i || i === r() || i === l()) return null;
                  i.assignedSlot && (i = i.assignedSlot);
                  const s = i.closest(t);
                  return s || i.getRootNode ? s || e(i.getRootNode().host) : null;
                })(e);
              })(g, d[0])
            : d.closest(g)[0])
        )
          return void (e.allowClick = !0);
        if (n.swipeHandler && !d.closest(n.swipeHandler)[0]) return;
        (o.currentX = "touchstart" === h.type ? h.targetTouches[0].pageX : h.pageX),
          (o.currentY = "touchstart" === h.type ? h.targetTouches[0].pageY : h.pageY);
        const v = o.currentX,
          b = o.currentY,
          y = n.edgeSwipeDetection || n.iOSEdgeSwipeDetection,
          w = n.edgeSwipeThreshold || n.iOSEdgeSwipeThreshold;
        if (y && (v <= w || v >= s.innerWidth - w)) {
          if ("prevent" !== y) return;
          t.preventDefault();
        }
        if (
          (Object.assign(a, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0,
          }),
          (o.startX = v),
          (o.startY = b),
          (a.touchStartTime = x()),
          (e.allowClick = !0),
          e.updateSize(),
          (e.swipeDirection = void 0),
          n.threshold > 0 && (a.allowThresholdMove = !1),
          "touchstart" !== h.type)
        ) {
          let t = !0;
          d.is(a.focusableElements) && ((t = !1), "SELECT" === d[0].nodeName && (a.isTouched = !1)),
            i.activeElement &&
              m(i.activeElement).is(a.focusableElements) &&
              i.activeElement !== d[0] &&
              i.activeElement.blur();
          const s = t && e.allowTouchMove && n.touchStartPreventDefault;
          (!n.touchStartForcePreventDefault && !s) || d[0].isContentEditable || h.preventDefault();
        }
        e.params.freeMode &&
          e.params.freeMode.enabled &&
          e.freeMode &&
          e.animating &&
          !n.cssMode &&
          e.freeMode.onTouchStart(),
          e.emit("touchStart", h);
      }
      function I(t) {
        const e = r(),
          i = this,
          s = i.touchEventsData,
          { params: a, touches: n, rtlTranslate: o, enabled: l } = i;
        if (!l) return;
        let c = t;
        if ((c.originalEvent && (c = c.originalEvent), !s.isTouched))
          return void (s.startMoving && s.isScrolling && i.emit("touchMoveOpposite", c));
        if (s.isTouchEvent && "touchmove" !== c.type) return;
        const h = "touchmove" === c.type && c.targetTouches && (c.targetTouches[0] || c.changedTouches[0]),
          d = "touchmove" === c.type ? h.pageX : c.pageX,
          u = "touchmove" === c.type ? h.pageY : c.pageY;
        if (c.preventedByNestedSwiper) return (n.startX = d), void (n.startY = u);
        if (!i.allowTouchMove)
          return (
            m(c.target).is(s.focusableElements) || (i.allowClick = !1),
            void (
              s.isTouched &&
              (Object.assign(n, { startX: d, startY: u, currentX: d, currentY: u }), (s.touchStartTime = x()))
            )
          );
        if (s.isTouchEvent && a.touchReleaseOnEdges && !a.loop)
          if (i.isVertical()) {
            if ((u < n.startY && i.translate <= i.maxTranslate()) || (u > n.startY && i.translate >= i.minTranslate()))
              return (s.isTouched = !1), void (s.isMoved = !1);
          } else if (
            (d < n.startX && i.translate <= i.maxTranslate()) ||
            (d > n.startX && i.translate >= i.minTranslate())
          )
            return;
        if (s.isTouchEvent && e.activeElement && c.target === e.activeElement && m(c.target).is(s.focusableElements))
          return (s.isMoved = !0), void (i.allowClick = !1);
        if ((s.allowTouchCallbacks && i.emit("touchMove", c), c.targetTouches && c.targetTouches.length > 1)) return;
        (n.currentX = d), (n.currentY = u);
        const p = n.currentX - n.startX,
          g = n.currentY - n.startY;
        if (i.params.threshold && Math.sqrt(p ** 2 + g ** 2) < i.params.threshold) return;
        if (void 0 === s.isScrolling) {
          let t;
          (i.isHorizontal() && n.currentY === n.startY) || (i.isVertical() && n.currentX === n.startX)
            ? (s.isScrolling = !1)
            : p * p + g * g >= 25 &&
              ((t = (180 * Math.atan2(Math.abs(g), Math.abs(p))) / Math.PI),
              (s.isScrolling = i.isHorizontal() ? t > a.touchAngle : 90 - t > a.touchAngle));
        }
        if (
          (s.isScrolling && i.emit("touchMoveOpposite", c),
          void 0 === s.startMoving && ((n.currentX === n.startX && n.currentY === n.startY) || (s.startMoving = !0)),
          s.isScrolling)
        )
          return void (s.isTouched = !1);
        if (!s.startMoving) return;
        (i.allowClick = !1),
          !a.cssMode && c.cancelable && c.preventDefault(),
          a.touchMoveStopPropagation && !a.nested && c.stopPropagation(),
          s.isMoved ||
            (a.loop && !a.cssMode && i.loopFix(),
            (s.startTranslate = i.getTranslate()),
            i.setTransition(0),
            i.animating && i.$wrapperEl.trigger("webkitTransitionEnd transitionend"),
            (s.allowMomentumBounce = !1),
            !a.grabCursor || (!0 !== i.allowSlideNext && !0 !== i.allowSlidePrev) || i.setGrabCursor(!0),
            i.emit("sliderFirstMove", c)),
          i.emit("sliderMove", c),
          (s.isMoved = !0);
        let f = i.isHorizontal() ? p : g;
        (n.diff = f),
          (f *= a.touchRatio),
          o && (f = -f),
          (i.swipeDirection = f > 0 ? "prev" : "next"),
          (s.currentTranslate = f + s.startTranslate);
        let v = !0,
          b = a.resistanceRatio;
        if (
          (a.touchReleaseOnEdges && (b = 0),
          f > 0 && s.currentTranslate > i.minTranslate()
            ? ((v = !1),
              a.resistance &&
                (s.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + s.startTranslate + f) ** b))
            : f < 0 &&
              s.currentTranslate < i.maxTranslate() &&
              ((v = !1),
              a.resistance &&
                (s.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - s.startTranslate - f) ** b)),
          v && (c.preventedByNestedSwiper = !0),
          !i.allowSlideNext &&
            "next" === i.swipeDirection &&
            s.currentTranslate < s.startTranslate &&
            (s.currentTranslate = s.startTranslate),
          !i.allowSlidePrev &&
            "prev" === i.swipeDirection &&
            s.currentTranslate > s.startTranslate &&
            (s.currentTranslate = s.startTranslate),
          i.allowSlidePrev || i.allowSlideNext || (s.currentTranslate = s.startTranslate),
          a.threshold > 0)
        ) {
          if (!(Math.abs(f) > a.threshold || s.allowThresholdMove)) return void (s.currentTranslate = s.startTranslate);
          if (!s.allowThresholdMove)
            return (
              (s.allowThresholdMove = !0),
              (n.startX = n.currentX),
              (n.startY = n.currentY),
              (s.currentTranslate = s.startTranslate),
              void (n.diff = i.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY)
            );
        }
        a.followFinger &&
          !a.cssMode &&
          (((a.freeMode && a.freeMode.enabled && i.freeMode) || a.watchSlidesProgress) &&
            (i.updateActiveIndex(), i.updateSlidesClasses()),
          i.params.freeMode && a.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(),
          i.updateProgress(s.currentTranslate),
          i.setTranslate(s.currentTranslate));
      }
      function F(t) {
        const e = this,
          i = e.touchEventsData,
          { params: s, touches: a, rtlTranslate: n, slidesGrid: r, enabled: o } = e;
        if (!o) return;
        let l = t;
        if (
          (l.originalEvent && (l = l.originalEvent),
          i.allowTouchCallbacks && e.emit("touchEnd", l),
          (i.allowTouchCallbacks = !1),
          !i.isTouched)
        )
          return i.isMoved && s.grabCursor && e.setGrabCursor(!1), (i.isMoved = !1), void (i.startMoving = !1);
        s.grabCursor &&
          i.isMoved &&
          i.isTouched &&
          (!0 === e.allowSlideNext || !0 === e.allowSlidePrev) &&
          e.setGrabCursor(!1);
        const c = x(),
          h = c - i.touchStartTime;
        if (e.allowClick) {
          const t = l.path || (l.composedPath && l.composedPath());
          e.updateClickedSlide((t && t[0]) || l.target),
            e.emit("tap click", l),
            h < 300 && c - i.lastClickTime < 300 && e.emit("doubleTap doubleClick", l);
        }
        if (
          ((i.lastClickTime = x()),
          v(() => {
            e.destroyed || (e.allowClick = !0);
          }),
          !i.isTouched || !i.isMoved || !e.swipeDirection || 0 === a.diff || i.currentTranslate === i.startTranslate)
        )
          return (i.isTouched = !1), (i.isMoved = !1), void (i.startMoving = !1);
        let d;
        if (
          ((i.isTouched = !1),
          (i.isMoved = !1),
          (i.startMoving = !1),
          (d = s.followFinger ? (n ? e.translate : -e.translate) : -i.currentTranslate),
          s.cssMode)
        )
          return;
        if (e.params.freeMode && s.freeMode.enabled) return void e.freeMode.onTouchEnd({ currentPos: d });
        let u = 0,
          p = e.slidesSizesGrid[0];
        for (let t = 0; t < r.length; t += t < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup) {
          const e = t < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup;
          void 0 !== r[t + e]
            ? d >= r[t] && d < r[t + e] && ((u = t), (p = r[t + e] - r[t]))
            : d >= r[t] && ((u = t), (p = r[r.length - 1] - r[r.length - 2]));
        }
        let g = null,
          f = null;
        s.rewind &&
          (e.isBeginning
            ? (f =
                e.params.virtual && e.params.virtual.enabled && e.virtual
                  ? e.virtual.slides.length - 1
                  : e.slides.length - 1)
            : e.isEnd && (g = 0));
        const m = (d - r[u]) / p,
          b = u < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup;
        if (h > s.longSwipesMs) {
          if (!s.longSwipes) return void e.slideTo(e.activeIndex);
          "next" === e.swipeDirection &&
            (m >= s.longSwipesRatio ? e.slideTo(s.rewind && e.isEnd ? g : u + b) : e.slideTo(u)),
            "prev" === e.swipeDirection &&
              (m > 1 - s.longSwipesRatio
                ? e.slideTo(u + b)
                : null !== f && m < 0 && Math.abs(m) > s.longSwipesRatio
                ? e.slideTo(f)
                : e.slideTo(u));
        } else {
          if (!s.shortSwipes) return void e.slideTo(e.activeIndex);
          !e.navigation || (l.target !== e.navigation.nextEl && l.target !== e.navigation.prevEl)
            ? ("next" === e.swipeDirection && e.slideTo(null !== g ? g : u + b),
              "prev" === e.swipeDirection && e.slideTo(null !== f ? f : u))
            : l.target === e.navigation.nextEl
            ? e.slideTo(u + b)
            : e.slideTo(u);
        }
      }
      function D() {
        const t = this,
          { params: e, el: i } = t;
        if (i && 0 === i.offsetWidth) return;
        e.breakpoints && t.setBreakpoint();
        const { allowSlideNext: s, allowSlidePrev: a, snapGrid: n } = t;
        (t.allowSlideNext = !0),
          (t.allowSlidePrev = !0),
          t.updateSize(),
          t.updateSlides(),
          t.updateSlidesClasses(),
          ("auto" === e.slidesPerView || e.slidesPerView > 1) && t.isEnd && !t.isBeginning && !t.params.centeredSlides
            ? t.slideTo(t.slides.length - 1, 0, !1, !0)
            : t.slideTo(t.activeIndex, 0, !1, !0),
          t.autoplay && t.autoplay.running && t.autoplay.paused && t.autoplay.run(),
          (t.allowSlidePrev = a),
          (t.allowSlideNext = s),
          t.params.watchOverflow && n !== t.snapGrid && t.checkOverflow();
      }
      function z(t) {
        const e = this;
        e.enabled &&
          (e.allowClick ||
            (e.params.preventClicks && t.preventDefault(),
            e.params.preventClicksPropagation && e.animating && (t.stopPropagation(), t.stopImmediatePropagation())));
      }
      function N() {
        const t = this,
          { wrapperEl: e, rtlTranslate: i, enabled: s } = t;
        if (!s) return;
        let a;
        (t.previousTranslate = t.translate),
          t.isHorizontal() ? (t.translate = -e.scrollLeft) : (t.translate = -e.scrollTop),
          0 === t.translate && (t.translate = 0),
          t.updateActiveIndex(),
          t.updateSlidesClasses();
        const n = t.maxTranslate() - t.minTranslate();
        (a = 0 === n ? 0 : (t.translate - t.minTranslate()) / n),
          a !== t.progress && t.updateProgress(i ? -t.translate : t.translate),
          t.emit("setTranslate", t.translate, !1);
      }
      let R = !1;
      function _() {}
      const B = (t, e) => {
        const i = r(),
          { params: s, touchEvents: a, el: n, wrapperEl: o, device: l, support: c } = t,
          h = !!s.nested,
          d = "on" === e ? "addEventListener" : "removeEventListener",
          u = e;
        if (c.touch) {
          const e = !("touchstart" !== a.start || !c.passiveListener || !s.passiveListeners) && {
            passive: !0,
            capture: !1,
          };
          n[d](a.start, t.onTouchStart, e),
            n[d](a.move, t.onTouchMove, c.passiveListener ? { passive: !1, capture: h } : h),
            n[d](a.end, t.onTouchEnd, e),
            a.cancel && n[d](a.cancel, t.onTouchEnd, e);
        } else n[d](a.start, t.onTouchStart, !1), i[d](a.move, t.onTouchMove, h), i[d](a.end, t.onTouchEnd, !1);
        (s.preventClicks || s.preventClicksPropagation) && n[d]("click", t.onClick, !0),
          s.cssMode && o[d]("scroll", t.onScroll),
          s.updateOnWindowResize
            ? t[u](l.ios || l.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", D, !0)
            : t[u]("observerUpdate", D, !0);
      };
      var X = {
        attachEvents: function () {
          const t = this,
            e = r(),
            { params: i, support: s } = t;
          (t.onTouchStart = O.bind(t)),
            (t.onTouchMove = I.bind(t)),
            (t.onTouchEnd = F.bind(t)),
            i.cssMode && (t.onScroll = N.bind(t)),
            (t.onClick = z.bind(t)),
            s.touch && !R && (e.addEventListener("touchstart", _), (R = !0)),
            B(t, "on");
        },
        detachEvents: function () {
          B(this, "off");
        },
      };
      const H = (t, e) => t.grid && e.grid && e.grid.rows > 1;
      var Y = {
          addClasses: function () {
            const t = this,
              { classNames: e, params: i, rtl: s, $el: a, device: n, support: r } = t,
              o = (function (t, e) {
                const i = [];
                return (
                  t.forEach((t) => {
                    "object" == typeof t
                      ? Object.keys(t).forEach((s) => {
                          t[s] && i.push(e + s);
                        })
                      : "string" == typeof t && i.push(e + t);
                  }),
                  i
                );
              })(
                [
                  "initialized",
                  i.direction,
                  { "pointer-events": !r.touch },
                  { "free-mode": t.params.freeMode && i.freeMode.enabled },
                  { autoheight: i.autoHeight },
                  { rtl: s },
                  { grid: i.grid && i.grid.rows > 1 },
                  { "grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill },
                  { android: n.android },
                  { ios: n.ios },
                  { "css-mode": i.cssMode },
                  { centered: i.cssMode && i.centeredSlides },
                  { "watch-progress": i.watchSlidesProgress },
                ],
                i.containerModifierClass
              );
            e.push(...o), a.addClass([...e].join(" ")), t.emitContainerClasses();
          },
          removeClasses: function () {
            const { $el: t, classNames: e } = this;
            t.removeClass(e.join(" ")), this.emitContainerClasses();
          },
        },
        W = {
          init: !0,
          direction: "horizontal",
          touchEventsTarget: "wrapper",
          initialSlide: 0,
          speed: 300,
          cssMode: !1,
          updateOnWindowResize: !0,
          resizeObserver: !0,
          nested: !1,
          createElements: !1,
          enabled: !0,
          focusableElements: "input, select, option, textarea, button, video, label",
          width: null,
          height: null,
          preventInteractionOnTransition: !1,
          userAgent: null,
          url: null,
          edgeSwipeDetection: !1,
          edgeSwipeThreshold: 20,
          autoHeight: !1,
          setWrapperSize: !1,
          virtualTranslate: !1,
          effect: "slide",
          breakpoints: void 0,
          breakpointsBase: "window",
          spaceBetween: 0,
          slidesPerView: 1,
          slidesPerGroup: 1,
          slidesPerGroupSkip: 0,
          slidesPerGroupAuto: !1,
          centeredSlides: !1,
          centeredSlidesBounds: !1,
          slidesOffsetBefore: 0,
          slidesOffsetAfter: 0,
          normalizeSlideIndex: !0,
          centerInsufficientSlides: !1,
          watchOverflow: !0,
          roundLengths: !1,
          touchRatio: 1,
          touchAngle: 45,
          simulateTouch: !0,
          shortSwipes: !0,
          longSwipes: !0,
          longSwipesRatio: 0.5,
          longSwipesMs: 300,
          followFinger: !0,
          allowTouchMove: !0,
          threshold: 0,
          touchMoveStopPropagation: !1,
          touchStartPreventDefault: !0,
          touchStartForcePreventDefault: !1,
          touchReleaseOnEdges: !1,
          uniqueNavElements: !0,
          resistance: !0,
          resistanceRatio: 0.85,
          watchSlidesProgress: !1,
          grabCursor: !1,
          preventClicks: !0,
          preventClicksPropagation: !0,
          slideToClickedSlide: !1,
          preloadImages: !0,
          updateOnImagesReady: !0,
          loop: !1,
          loopAdditionalSlides: 0,
          loopedSlides: null,
          loopedSlidesLimit: !0,
          loopFillGroupWithBlank: !1,
          loopPreventsSlide: !0,
          rewind: !1,
          allowSlidePrev: !0,
          allowSlideNext: !0,
          swipeHandler: null,
          noSwiping: !0,
          noSwipingClass: "swiper-no-swiping",
          noSwipingSelector: null,
          passiveListeners: !0,
          maxBackfaceHiddenSlides: 10,
          containerModifierClass: "swiper-",
          slideClass: "swiper-slide",
          slideBlankClass: "swiper-slide-invisible-blank",
          slideActiveClass: "swiper-slide-active",
          slideDuplicateActiveClass: "swiper-slide-duplicate-active",
          slideVisibleClass: "swiper-slide-visible",
          slideDuplicateClass: "swiper-slide-duplicate",
          slideNextClass: "swiper-slide-next",
          slideDuplicateNextClass: "swiper-slide-duplicate-next",
          slidePrevClass: "swiper-slide-prev",
          slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
          wrapperClass: "swiper-wrapper",
          runCallbacksOnInit: !0,
          _emitClasses: !1,
        };
      function $(t, e) {
        return function (i = {}) {
          const s = Object.keys(i)[0],
            a = i[s];
          "object" == typeof a && null !== a
            ? (["navigation", "pagination", "scrollbar"].indexOf(s) >= 0 && !0 === t[s] && (t[s] = { auto: !0 }),
              s in t && "enabled" in a
                ? (!0 === t[s] && (t[s] = { enabled: !0 }),
                  "object" != typeof t[s] || "enabled" in t[s] || (t[s].enabled = !0),
                  t[s] || (t[s] = { enabled: !1 }),
                  y(e, i))
                : y(e, i))
            : y(e, i);
        };
      }
      const V = {
          eventsEmitter: T,
          update: L,
          translate: {
            getTranslate: function (t = this.isHorizontal() ? "x" : "y") {
              const { params: e, rtlTranslate: i, translate: s, $wrapperEl: a } = this;
              if (e.virtualTranslate) return i ? -s : s;
              if (e.cssMode) return s;
              let n = (function (t, e = "x") {
                const i = l();
                let s, a, n;
                const r = (function (t) {
                  const e = l();
                  let i;
                  return (
                    e.getComputedStyle && (i = e.getComputedStyle(t, null)),
                    !i && t.currentStyle && (i = t.currentStyle),
                    i || (i = t.style),
                    i
                  );
                })(t);
                return (
                  i.WebKitCSSMatrix
                    ? ((a = r.transform || r.webkitTransform),
                      a.split(",").length > 6 &&
                        (a = a
                          .split(", ")
                          .map((t) => t.replace(",", "."))
                          .join(", ")),
                      (n = new i.WebKitCSSMatrix("none" === a ? "" : a)))
                    : ((n =
                        r.MozTransform ||
                        r.OTransform ||
                        r.MsTransform ||
                        r.msTransform ||
                        r.transform ||
                        r.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,")),
                      (s = n.toString().split(","))),
                  "x" === e && (a = i.WebKitCSSMatrix ? n.m41 : 16 === s.length ? parseFloat(s[12]) : parseFloat(s[4])),
                  "y" === e && (a = i.WebKitCSSMatrix ? n.m42 : 16 === s.length ? parseFloat(s[13]) : parseFloat(s[5])),
                  a || 0
                );
              })(a[0], t);
              return i && (n = -n), n || 0;
            },
            setTranslate: function (t, e) {
              const i = this,
                { rtlTranslate: s, params: a, $wrapperEl: n, wrapperEl: r, progress: o } = i;
              let l,
                c = 0,
                h = 0;
              i.isHorizontal() ? (c = s ? -t : t) : (h = t),
                a.roundLengths && ((c = Math.floor(c)), (h = Math.floor(h))),
                a.cssMode
                  ? (r[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -c : -h)
                  : a.virtualTranslate || n.transform(`translate3d(${c}px, ${h}px, 0px)`),
                (i.previousTranslate = i.translate),
                (i.translate = i.isHorizontal() ? c : h);
              const d = i.maxTranslate() - i.minTranslate();
              (l = 0 === d ? 0 : (t - i.minTranslate()) / d),
                l !== o && i.updateProgress(t),
                i.emit("setTranslate", i.translate, e);
            },
            minTranslate: function () {
              return -this.snapGrid[0];
            },
            maxTranslate: function () {
              return -this.snapGrid[this.snapGrid.length - 1];
            },
            translateTo: function (t = 0, e = this.params.speed, i = !0, s = !0, a) {
              const n = this,
                { params: r, wrapperEl: o } = n;
              if (n.animating && r.preventInteractionOnTransition) return !1;
              const l = n.minTranslate(),
                c = n.maxTranslate();
              let h;
              if (((h = s && t > l ? l : s && t < c ? c : t), n.updateProgress(h), r.cssMode)) {
                const t = n.isHorizontal();
                if (0 === e) o[t ? "scrollLeft" : "scrollTop"] = -h;
                else {
                  if (!n.support.smoothScroll)
                    return k({ swiper: n, targetPosition: -h, side: t ? "left" : "top" }), !0;
                  o.scrollTo({ [t ? "left" : "top"]: -h, behavior: "smooth" });
                }
                return !0;
              }
              return (
                0 === e
                  ? (n.setTransition(0),
                    n.setTranslate(h),
                    i && (n.emit("beforeTransitionStart", e, a), n.emit("transitionEnd")))
                  : (n.setTransition(e),
                    n.setTranslate(h),
                    i && (n.emit("beforeTransitionStart", e, a), n.emit("transitionStart")),
                    n.animating ||
                      ((n.animating = !0),
                      n.onTranslateToWrapperTransitionEnd ||
                        (n.onTranslateToWrapperTransitionEnd = function (t) {
                          n &&
                            !n.destroyed &&
                            t.target === this &&
                            (n.$wrapperEl[0].removeEventListener("transitionend", n.onTranslateToWrapperTransitionEnd),
                            n.$wrapperEl[0].removeEventListener(
                              "webkitTransitionEnd",
                              n.onTranslateToWrapperTransitionEnd
                            ),
                            (n.onTranslateToWrapperTransitionEnd = null),
                            delete n.onTranslateToWrapperTransitionEnd,
                            i && n.emit("transitionEnd"));
                        }),
                      n.$wrapperEl[0].addEventListener("transitionend", n.onTranslateToWrapperTransitionEnd),
                      n.$wrapperEl[0].addEventListener("webkitTransitionEnd", n.onTranslateToWrapperTransitionEnd))),
                !0
              );
            },
          },
          transition: {
            setTransition: function (t, e) {
              const i = this;
              i.params.cssMode || i.$wrapperEl.transition(t), i.emit("setTransition", t, e);
            },
            transitionStart: function (t = !0, e) {
              const i = this,
                { params: s } = i;
              s.cssMode ||
                (s.autoHeight && i.updateAutoHeight(), P({ swiper: i, runCallbacks: t, direction: e, step: "Start" }));
            },
            transitionEnd: function (t = !0, e) {
              const i = this,
                { params: s } = i;
              (i.animating = !1),
                s.cssMode || (i.setTransition(0), P({ swiper: i, runCallbacks: t, direction: e, step: "End" }));
            },
          },
          slide: M,
          loop: {
            loopCreate: function () {
              const t = this,
                e = r(),
                { params: i, $wrapperEl: s } = t,
                a = s.children().length > 0 ? m(s.children()[0].parentNode) : s;
              a.children(`.${i.slideClass}.${i.slideDuplicateClass}`).remove();
              let n = a.children(`.${i.slideClass}`);
              if (i.loopFillGroupWithBlank) {
                const t = i.slidesPerGroup - (n.length % i.slidesPerGroup);
                if (t !== i.slidesPerGroup) {
                  for (let s = 0; s < t; s += 1) {
                    const t = m(e.createElement("div")).addClass(`${i.slideClass} ${i.slideBlankClass}`);
                    a.append(t);
                  }
                  n = a.children(`.${i.slideClass}`);
                }
              }
              "auto" !== i.slidesPerView || i.loopedSlides || (i.loopedSlides = n.length),
                (t.loopedSlides = Math.ceil(parseFloat(i.loopedSlides || i.slidesPerView, 10))),
                (t.loopedSlides += i.loopAdditionalSlides),
                t.loopedSlides > n.length && t.params.loopedSlidesLimit && (t.loopedSlides = n.length);
              const o = [],
                l = [];
              n.each((t, e) => {
                m(t).attr("data-swiper-slide-index", e);
              });
              for (let e = 0; e < t.loopedSlides; e += 1) {
                const t = e - Math.floor(e / n.length) * n.length;
                l.push(n.eq(t)[0]), o.unshift(n.eq(n.length - t - 1)[0]);
              }
              for (let t = 0; t < l.length; t += 1) a.append(m(l[t].cloneNode(!0)).addClass(i.slideDuplicateClass));
              for (let t = o.length - 1; t >= 0; t -= 1)
                a.prepend(m(o[t].cloneNode(!0)).addClass(i.slideDuplicateClass));
            },
            loopFix: function () {
              const t = this;
              t.emit("beforeLoopFix");
              const {
                activeIndex: e,
                slides: i,
                loopedSlides: s,
                allowSlidePrev: a,
                allowSlideNext: n,
                snapGrid: r,
                rtlTranslate: o,
              } = t;
              let l;
              (t.allowSlidePrev = !0), (t.allowSlideNext = !0);
              const c = -r[e] - t.getTranslate();
              e < s
                ? ((l = i.length - 3 * s + e),
                  (l += s),
                  t.slideTo(l, 0, !1, !0) && 0 !== c && t.setTranslate((o ? -t.translate : t.translate) - c))
                : e >= i.length - s &&
                  ((l = -i.length + e + s),
                  (l += s),
                  t.slideTo(l, 0, !1, !0) && 0 !== c && t.setTranslate((o ? -t.translate : t.translate) - c)),
                (t.allowSlidePrev = a),
                (t.allowSlideNext = n),
                t.emit("loopFix");
            },
            loopDestroy: function () {
              const { $wrapperEl: t, params: e, slides: i } = this;
              t.children(`.${e.slideClass}.${e.slideDuplicateClass},.${e.slideClass}.${e.slideBlankClass}`).remove(),
                i.removeAttr("data-swiper-slide-index");
            },
          },
          grabCursor: {
            setGrabCursor: function (t) {
              const e = this;
              if (
                e.support.touch ||
                !e.params.simulateTouch ||
                (e.params.watchOverflow && e.isLocked) ||
                e.params.cssMode
              )
                return;
              const i = "container" === e.params.touchEventsTarget ? e.el : e.wrapperEl;
              (i.style.cursor = "move"), (i.style.cursor = t ? "grabbing" : "grab");
            },
            unsetGrabCursor: function () {
              const t = this;
              t.support.touch ||
                (t.params.watchOverflow && t.isLocked) ||
                t.params.cssMode ||
                (t["container" === t.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "");
            },
          },
          events: X,
          breakpoints: {
            setBreakpoint: function () {
              const t = this,
                { activeIndex: e, initialized: i, loopedSlides: s = 0, params: a, $el: n } = t,
                r = a.breakpoints;
              if (!r || (r && 0 === Object.keys(r).length)) return;
              const o = t.getBreakpoint(r, t.params.breakpointsBase, t.el);
              if (!o || t.currentBreakpoint === o) return;
              const l = (o in r ? r[o] : void 0) || t.originalParams,
                c = H(t, a),
                h = H(t, l),
                d = a.enabled;
              c && !h
                ? (n.removeClass(`${a.containerModifierClass}grid ${a.containerModifierClass}grid-column`),
                  t.emitContainerClasses())
                : !c &&
                  h &&
                  (n.addClass(`${a.containerModifierClass}grid`),
                  ((l.grid.fill && "column" === l.grid.fill) || (!l.grid.fill && "column" === a.grid.fill)) &&
                    n.addClass(`${a.containerModifierClass}grid-column`),
                  t.emitContainerClasses()),
                ["navigation", "pagination", "scrollbar"].forEach((e) => {
                  const i = a[e] && a[e].enabled,
                    s = l[e] && l[e].enabled;
                  i && !s && t[e].disable(), !i && s && t[e].enable();
                });
              const u = l.direction && l.direction !== a.direction,
                p = a.loop && (l.slidesPerView !== a.slidesPerView || u);
              u && i && t.changeDirection(), y(t.params, l);
              const g = t.params.enabled;
              Object.assign(t, {
                allowTouchMove: t.params.allowTouchMove,
                allowSlideNext: t.params.allowSlideNext,
                allowSlidePrev: t.params.allowSlidePrev,
              }),
                d && !g ? t.disable() : !d && g && t.enable(),
                (t.currentBreakpoint = o),
                t.emit("_beforeBreakpoint", l),
                p && i && (t.loopDestroy(), t.loopCreate(), t.updateSlides(), t.slideTo(e - s + t.loopedSlides, 0, !1)),
                t.emit("breakpoint", l);
            },
            getBreakpoint: function (t, e = "window", i) {
              if (!t || ("container" === e && !i)) return;
              let s = !1;
              const a = l(),
                n = "window" === e ? a.innerHeight : i.clientHeight,
                r = Object.keys(t).map((t) => {
                  if ("string" == typeof t && 0 === t.indexOf("@")) {
                    const e = parseFloat(t.substr(1));
                    return { value: n * e, point: t };
                  }
                  return { value: t, point: t };
                });
              r.sort((t, e) => parseInt(t.value, 10) - parseInt(e.value, 10));
              for (let t = 0; t < r.length; t += 1) {
                const { point: n, value: o } = r[t];
                "window" === e ? a.matchMedia(`(min-width: ${o}px)`).matches && (s = n) : o <= i.clientWidth && (s = n);
              }
              return s || "max";
            },
          },
          checkOverflow: {
            checkOverflow: function () {
              const t = this,
                { isLocked: e, params: i } = t,
                { slidesOffsetBefore: s } = i;
              if (s) {
                const e = t.slides.length - 1,
                  i = t.slidesGrid[e] + t.slidesSizesGrid[e] + 2 * s;
                t.isLocked = t.size > i;
              } else t.isLocked = 1 === t.snapGrid.length;
              !0 === i.allowSlideNext && (t.allowSlideNext = !t.isLocked),
                !0 === i.allowSlidePrev && (t.allowSlidePrev = !t.isLocked),
                e && e !== t.isLocked && (t.isEnd = !1),
                e !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock");
            },
          },
          classes: Y,
          images: {
            loadImage: function (t, e, i, s, a, n) {
              const r = l();
              let o;
              function c() {
                n && n();
              }
              m(t).parent("picture")[0] || (t.complete && a)
                ? c()
                : e
                ? ((o = new r.Image()),
                  (o.onload = c),
                  (o.onerror = c),
                  s && (o.sizes = s),
                  i && (o.srcset = i),
                  e && (o.src = e))
                : c();
            },
            preloadImages: function () {
              const t = this;
              function e() {
                null != t &&
                  t &&
                  !t.destroyed &&
                  (void 0 !== t.imagesLoaded && (t.imagesLoaded += 1),
                  t.imagesLoaded === t.imagesToLoad.length &&
                    (t.params.updateOnImagesReady && t.update(), t.emit("imagesReady")));
              }
              t.imagesToLoad = t.$el.find("img");
              for (let i = 0; i < t.imagesToLoad.length; i += 1) {
                const s = t.imagesToLoad[i];
                t.loadImage(
                  s,
                  s.currentSrc || s.getAttribute("src"),
                  s.srcset || s.getAttribute("srcset"),
                  s.sizes || s.getAttribute("sizes"),
                  !0,
                  e
                );
              }
            },
          },
        },
        j = {};
      class G {
        constructor(...t) {
          let e, i;
          if (
            (1 === t.length && t[0].constructor && "Object" === Object.prototype.toString.call(t[0]).slice(8, -1)
              ? (i = t[0])
              : ([e, i] = t),
            i || (i = {}),
            (i = y({}, i)),
            e && !i.el && (i.el = e),
            i.el && m(i.el).length > 1)
          ) {
            const t = [];
            return (
              m(i.el).each((e) => {
                const s = y({}, i, { el: e });
                t.push(new G(s));
              }),
              t
            );
          }
          const s = this;
          (s.__swiper__ = !0),
            (s.support = E()),
            (s.device = (function (t = {}) {
              return (
                C ||
                  (C = (function ({ userAgent: t } = {}) {
                    const e = E(),
                      i = l(),
                      s = i.navigator.platform,
                      a = t || i.navigator.userAgent,
                      n = { ios: !1, android: !1 },
                      r = i.screen.width,
                      o = i.screen.height,
                      c = a.match(/(Android);?[\s\/]+([\d.]+)?/);
                    let h = a.match(/(iPad).*OS\s([\d_]+)/);
                    const d = a.match(/(iPod)(.*OS\s([\d_]+))?/),
                      u = !h && a.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                      p = "Win32" === s;
                    let g = "MacIntel" === s;
                    return (
                      !h &&
                        g &&
                        e.touch &&
                        [
                          "1024x1366",
                          "1366x1024",
                          "834x1194",
                          "1194x834",
                          "834x1112",
                          "1112x834",
                          "768x1024",
                          "1024x768",
                          "820x1180",
                          "1180x820",
                          "810x1080",
                          "1080x810",
                        ].indexOf(`${r}x${o}`) >= 0 &&
                        ((h = a.match(/(Version)\/([\d.]+)/)), h || (h = [0, 1, "13_0_0"]), (g = !1)),
                      c && !p && ((n.os = "android"), (n.android = !0)),
                      (h || u || d) && ((n.os = "ios"), (n.ios = !0)),
                      n
                    );
                  })(t)),
                C
              );
            })({ userAgent: i.userAgent })),
            (s.browser =
              (A ||
                (A = (function () {
                  const t = l();
                  return {
                    isSafari: (function () {
                      const e = t.navigator.userAgent.toLowerCase();
                      return e.indexOf("safari") >= 0 && e.indexOf("chrome") < 0 && e.indexOf("android") < 0;
                    })(),
                    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent),
                  };
                })()),
              A)),
            (s.eventsListeners = {}),
            (s.eventsAnyListeners = []),
            (s.modules = [...s.__modules__]),
            i.modules && Array.isArray(i.modules) && s.modules.push(...i.modules);
          const a = {};
          s.modules.forEach((t) => {
            t({
              swiper: s,
              extendParams: $(i, a),
              on: s.on.bind(s),
              once: s.once.bind(s),
              off: s.off.bind(s),
              emit: s.emit.bind(s),
            });
          });
          const n = y({}, W, a);
          return (
            (s.params = y({}, n, j, i)),
            (s.originalParams = y({}, s.params)),
            (s.passedParams = y({}, i)),
            s.params &&
              s.params.on &&
              Object.keys(s.params.on).forEach((t) => {
                s.on(t, s.params.on[t]);
              }),
            s.params && s.params.onAny && s.onAny(s.params.onAny),
            (s.$ = m),
            Object.assign(s, {
              enabled: s.params.enabled,
              el: e,
              classNames: [],
              slides: m(),
              slidesGrid: [],
              snapGrid: [],
              slidesSizesGrid: [],
              isHorizontal: () => "horizontal" === s.params.direction,
              isVertical: () => "vertical" === s.params.direction,
              activeIndex: 0,
              realIndex: 0,
              isBeginning: !0,
              isEnd: !1,
              translate: 0,
              previousTranslate: 0,
              progress: 0,
              velocity: 0,
              animating: !1,
              allowSlideNext: s.params.allowSlideNext,
              allowSlidePrev: s.params.allowSlidePrev,
              touchEvents: (function () {
                const t = ["touchstart", "touchmove", "touchend", "touchcancel"],
                  e = ["pointerdown", "pointermove", "pointerup"];
                return (
                  (s.touchEventsTouch = { start: t[0], move: t[1], end: t[2], cancel: t[3] }),
                  (s.touchEventsDesktop = { start: e[0], move: e[1], end: e[2] }),
                  s.support.touch || !s.params.simulateTouch ? s.touchEventsTouch : s.touchEventsDesktop
                );
              })(),
              touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: s.params.focusableElements,
                lastClickTime: x(),
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                isTouchEvent: void 0,
                startMoving: void 0,
              },
              allowClick: !0,
              allowTouchMove: s.params.allowTouchMove,
              touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 },
              imagesToLoad: [],
              imagesLoaded: 0,
            }),
            s.emit("_swiper"),
            s.params.init && s.init(),
            s
          );
        }
        enable() {
          const t = this;
          t.enabled || ((t.enabled = !0), t.params.grabCursor && t.setGrabCursor(), t.emit("enable"));
        }
        disable() {
          const t = this;
          t.enabled && ((t.enabled = !1), t.params.grabCursor && t.unsetGrabCursor(), t.emit("disable"));
        }
        setProgress(t, e) {
          const i = this;
          t = Math.min(Math.max(t, 0), 1);
          const s = i.minTranslate(),
            a = (i.maxTranslate() - s) * t + s;
          i.translateTo(a, void 0 === e ? 0 : e), i.updateActiveIndex(), i.updateSlidesClasses();
        }
        emitContainerClasses() {
          const t = this;
          if (!t.params._emitClasses || !t.el) return;
          const e = t.el.className
            .split(" ")
            .filter((e) => 0 === e.indexOf("swiper") || 0 === e.indexOf(t.params.containerModifierClass));
          t.emit("_containerClasses", e.join(" "));
        }
        getSlideClasses(t) {
          const e = this;
          return e.destroyed
            ? ""
            : t.className
                .split(" ")
                .filter((t) => 0 === t.indexOf("swiper-slide") || 0 === t.indexOf(e.params.slideClass))
                .join(" ");
        }
        emitSlidesClasses() {
          const t = this;
          if (!t.params._emitClasses || !t.el) return;
          const e = [];
          t.slides.each((i) => {
            const s = t.getSlideClasses(i);
            e.push({ slideEl: i, classNames: s }), t.emit("_slideClass", i, s);
          }),
            t.emit("_slideClasses", e);
        }
        slidesPerViewDynamic(t = "current", e = !1) {
          const { params: i, slides: s, slidesGrid: a, slidesSizesGrid: n, size: r, activeIndex: o } = this;
          let l = 1;
          if (i.centeredSlides) {
            let t,
              e = s[o].swiperSlideSize;
            for (let i = o + 1; i < s.length; i += 1)
              s[i] && !t && ((e += s[i].swiperSlideSize), (l += 1), e > r && (t = !0));
            for (let i = o - 1; i >= 0; i -= 1)
              s[i] && !t && ((e += s[i].swiperSlideSize), (l += 1), e > r && (t = !0));
          } else if ("current" === t)
            for (let t = o + 1; t < s.length; t += 1) (e ? a[t] + n[t] - a[o] < r : a[t] - a[o] < r) && (l += 1);
          else for (let t = o - 1; t >= 0; t -= 1) a[o] - a[t] < r && (l += 1);
          return l;
        }
        update() {
          const t = this;
          if (!t || t.destroyed) return;
          const { snapGrid: e, params: i } = t;
          function s() {
            const e = t.rtlTranslate ? -1 * t.translate : t.translate,
              i = Math.min(Math.max(e, t.maxTranslate()), t.minTranslate());
            t.setTranslate(i), t.updateActiveIndex(), t.updateSlidesClasses();
          }
          let a;
          i.breakpoints && t.setBreakpoint(),
            t.updateSize(),
            t.updateSlides(),
            t.updateProgress(),
            t.updateSlidesClasses(),
            t.params.freeMode && t.params.freeMode.enabled
              ? (s(), t.params.autoHeight && t.updateAutoHeight())
              : ((a =
                  ("auto" === t.params.slidesPerView || t.params.slidesPerView > 1) &&
                  t.isEnd &&
                  !t.params.centeredSlides
                    ? t.slideTo(t.slides.length - 1, 0, !1, !0)
                    : t.slideTo(t.activeIndex, 0, !1, !0)),
                a || s()),
            i.watchOverflow && e !== t.snapGrid && t.checkOverflow(),
            t.emit("update");
        }
        changeDirection(t, e = !0) {
          const i = this,
            s = i.params.direction;
          return (
            t || (t = "horizontal" === s ? "vertical" : "horizontal"),
            t === s ||
              ("horizontal" !== t && "vertical" !== t) ||
              (i.$el
                .removeClass(`${i.params.containerModifierClass}${s}`)
                .addClass(`${i.params.containerModifierClass}${t}`),
              i.emitContainerClasses(),
              (i.params.direction = t),
              i.slides.each((e) => {
                "vertical" === t ? (e.style.width = "") : (e.style.height = "");
              }),
              i.emit("changeDirection"),
              e && i.update()),
            i
          );
        }
        changeLanguageDirection(t) {
          const e = this;
          (e.rtl && "rtl" === t) ||
            (!e.rtl && "ltr" === t) ||
            ((e.rtl = "rtl" === t),
            (e.rtlTranslate = "horizontal" === e.params.direction && e.rtl),
            e.rtl
              ? (e.$el.addClass(`${e.params.containerModifierClass}rtl`), (e.el.dir = "rtl"))
              : (e.$el.removeClass(`${e.params.containerModifierClass}rtl`), (e.el.dir = "ltr")),
            e.update());
        }
        mount(t) {
          const e = this;
          if (e.mounted) return !0;
          const i = m(t || e.params.el);
          if (!(t = i[0])) return !1;
          t.swiper = e;
          const s = () => `.${(e.params.wrapperClass || "").trim().split(" ").join(".")}`;
          let a = (() => {
            if (t && t.shadowRoot && t.shadowRoot.querySelector) {
              const e = m(t.shadowRoot.querySelector(s()));
              return (e.children = (t) => i.children(t)), e;
            }
            return i.children ? i.children(s()) : m(i).children(s());
          })();
          if (0 === a.length && e.params.createElements) {
            const t = r().createElement("div");
            (a = m(t)),
              (t.className = e.params.wrapperClass),
              i.append(t),
              i.children(`.${e.params.slideClass}`).each((t) => {
                a.append(t);
              });
          }
          return (
            Object.assign(e, {
              $el: i,
              el: t,
              $wrapperEl: a,
              wrapperEl: a[0],
              mounted: !0,
              rtl: "rtl" === t.dir.toLowerCase() || "rtl" === i.css("direction"),
              rtlTranslate:
                "horizontal" === e.params.direction && ("rtl" === t.dir.toLowerCase() || "rtl" === i.css("direction")),
              wrongRTL: "-webkit-box" === a.css("display"),
            }),
            !0
          );
        }
        init(t) {
          const e = this;
          return (
            e.initialized ||
              !1 === e.mount(t) ||
              (e.emit("beforeInit"),
              e.params.breakpoints && e.setBreakpoint(),
              e.addClasses(),
              e.params.loop && e.loopCreate(),
              e.updateSize(),
              e.updateSlides(),
              e.params.watchOverflow && e.checkOverflow(),
              e.params.grabCursor && e.enabled && e.setGrabCursor(),
              e.params.preloadImages && e.preloadImages(),
              e.params.loop
                ? e.slideTo(e.params.initialSlide + e.loopedSlides, 0, e.params.runCallbacksOnInit, !1, !0)
                : e.slideTo(e.params.initialSlide, 0, e.params.runCallbacksOnInit, !1, !0),
              e.attachEvents(),
              (e.initialized = !0),
              e.emit("init"),
              e.emit("afterInit")),
            e
          );
        }
        destroy(t = !0, e = !0) {
          const i = this,
            { params: s, $el: a, $wrapperEl: n, slides: r } = i;
          return (
            void 0 === i.params ||
              i.destroyed ||
              (i.emit("beforeDestroy"),
              (i.initialized = !1),
              i.detachEvents(),
              s.loop && i.loopDestroy(),
              e &&
                (i.removeClasses(),
                a.removeAttr("style"),
                n.removeAttr("style"),
                r &&
                  r.length &&
                  r
                    .removeClass(
                      [s.slideVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass].join(" ")
                    )
                    .removeAttr("style")
                    .removeAttr("data-swiper-slide-index")),
              i.emit("destroy"),
              Object.keys(i.eventsListeners).forEach((t) => {
                i.off(t);
              }),
              !1 !== t &&
                ((i.$el[0].swiper = null),
                (function (t) {
                  const e = t;
                  Object.keys(e).forEach((t) => {
                    try {
                      e[t] = null;
                    } catch (t) {}
                    try {
                      delete e[t];
                    } catch (t) {}
                  });
                })(i)),
              (i.destroyed = !0)),
            null
          );
        }
        static extendDefaults(t) {
          y(j, t);
        }
        static get extendedDefaults() {
          return j;
        }
        static get defaults() {
          return W;
        }
        static installModule(t) {
          G.prototype.__modules__ || (G.prototype.__modules__ = []);
          const e = G.prototype.__modules__;
          "function" == typeof t && e.indexOf(t) < 0 && e.push(t);
        }
        static use(t) {
          return Array.isArray(t) ? (t.forEach((t) => G.installModule(t)), G) : (G.installModule(t), G);
        }
      }
      Object.keys(V).forEach((t) => {
        Object.keys(V[t]).forEach((e) => {
          G.prototype[e] = V[t][e];
        });
      }),
        G.use([
          function ({ swiper: t, on: e, emit: i }) {
            const s = l();
            let a = null,
              n = null;
            const r = () => {
                t && !t.destroyed && t.initialized && (i("beforeResize"), i("resize"));
              },
              o = () => {
                t && !t.destroyed && t.initialized && i("orientationchange");
              };
            e("init", () => {
              t.params.resizeObserver && void 0 !== s.ResizeObserver
                ? t &&
                  !t.destroyed &&
                  t.initialized &&
                  ((a = new ResizeObserver((e) => {
                    n = s.requestAnimationFrame(() => {
                      const { width: i, height: s } = t;
                      let a = i,
                        n = s;
                      e.forEach(({ contentBoxSize: e, contentRect: i, target: s }) => {
                        (s && s !== t.el) ||
                          ((a = i ? i.width : (e[0] || e).inlineSize), (n = i ? i.height : (e[0] || e).blockSize));
                      }),
                        (a === i && n === s) || r();
                    });
                  })),
                  a.observe(t.el))
                : (s.addEventListener("resize", r), s.addEventListener("orientationchange", o));
            }),
              e("destroy", () => {
                n && s.cancelAnimationFrame(n),
                  a && a.unobserve && t.el && (a.unobserve(t.el), (a = null)),
                  s.removeEventListener("resize", r),
                  s.removeEventListener("orientationchange", o);
              });
          },
          function ({ swiper: t, extendParams: e, on: i, emit: s }) {
            const a = [],
              n = l(),
              r = (t, e = {}) => {
                const i = new (n.MutationObserver || n.WebkitMutationObserver)((t) => {
                  if (1 === t.length) return void s("observerUpdate", t[0]);
                  const e = function () {
                    s("observerUpdate", t[0]);
                  };
                  n.requestAnimationFrame ? n.requestAnimationFrame(e) : n.setTimeout(e, 0);
                });
                i.observe(t, {
                  attributes: void 0 === e.attributes || e.attributes,
                  childList: void 0 === e.childList || e.childList,
                  characterData: void 0 === e.characterData || e.characterData,
                }),
                  a.push(i);
              };
            e({ observer: !1, observeParents: !1, observeSlideChildren: !1 }),
              i("init", () => {
                if (t.params.observer) {
                  if (t.params.observeParents) {
                    const e = t.$el.parents();
                    for (let t = 0; t < e.length; t += 1) r(e[t]);
                  }
                  r(t.$el[0], { childList: t.params.observeSlideChildren }), r(t.$wrapperEl[0], { attributes: !1 });
                }
              }),
              i("destroy", () => {
                a.forEach((t) => {
                  t.disconnect();
                }),
                  a.splice(0, a.length);
              });
          },
        ]);
      var U = G;
      function q({ swiper: t, extendParams: e, on: i, emit: s }) {
        const a = r();
        let n,
          o,
          l,
          c,
          h = !1,
          d = null,
          u = null;
        function p() {
          if (!t.params.scrollbar.el || !t.scrollbar.el) return;
          const { scrollbar: e, rtlTranslate: i, progress: s } = t,
            { $dragEl: a, $el: n } = e,
            r = t.params.scrollbar;
          let c = o,
            h = (l - o) * s;
          i
            ? ((h = -h), h > 0 ? ((c = o - h), (h = 0)) : -h + o > l && (c = l + h))
            : h < 0
            ? ((c = o + h), (h = 0))
            : h + o > l && (c = l - h),
            t.isHorizontal()
              ? (a.transform(`translate3d(${h}px, 0, 0)`), (a[0].style.width = `${c}px`))
              : (a.transform(`translate3d(0px, ${h}px, 0)`), (a[0].style.height = `${c}px`)),
            r.hide &&
              (clearTimeout(d),
              (n[0].style.opacity = 1),
              (d = setTimeout(() => {
                (n[0].style.opacity = 0), n.transition(400);
              }, 1e3)));
        }
        function g() {
          if (!t.params.scrollbar.el || !t.scrollbar.el) return;
          const { scrollbar: e } = t,
            { $dragEl: i, $el: s } = e;
          (i[0].style.width = ""),
            (i[0].style.height = ""),
            (l = t.isHorizontal() ? s[0].offsetWidth : s[0].offsetHeight),
            (c =
              t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0))),
            (o = "auto" === t.params.scrollbar.dragSize ? l * c : parseInt(t.params.scrollbar.dragSize, 10)),
            t.isHorizontal() ? (i[0].style.width = `${o}px`) : (i[0].style.height = `${o}px`),
            (s[0].style.display = c >= 1 ? "none" : ""),
            t.params.scrollbar.hide && (s[0].style.opacity = 0),
            t.params.watchOverflow &&
              t.enabled &&
              e.$el[t.isLocked ? "addClass" : "removeClass"](t.params.scrollbar.lockClass);
        }
        function f(e) {
          return t.isHorizontal()
            ? "touchstart" === e.type || "touchmove" === e.type
              ? e.targetTouches[0].clientX
              : e.clientX
            : "touchstart" === e.type || "touchmove" === e.type
            ? e.targetTouches[0].clientY
            : e.clientY;
        }
        function x(e) {
          const { scrollbar: i, rtlTranslate: s } = t,
            { $el: a } = i;
          let r;
          (r = (f(e) - a.offset()[t.isHorizontal() ? "left" : "top"] - (null !== n ? n : o / 2)) / (l - o)),
            (r = Math.max(Math.min(r, 1), 0)),
            s && (r = 1 - r);
          const c = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * r;
          t.updateProgress(c), t.setTranslate(c), t.updateActiveIndex(), t.updateSlidesClasses();
        }
        function b(e) {
          const i = t.params.scrollbar,
            { scrollbar: a, $wrapperEl: r } = t,
            { $el: o, $dragEl: l } = a;
          (h = !0),
            (n =
              e.target === l[0] || e.target === l
                ? f(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"]
                : null),
            e.preventDefault(),
            e.stopPropagation(),
            r.transition(100),
            l.transition(100),
            x(e),
            clearTimeout(u),
            o.transition(0),
            i.hide && o.css("opacity", 1),
            t.params.cssMode && t.$wrapperEl.css("scroll-snap-type", "none"),
            s("scrollbarDragStart", e);
        }
        function y(e) {
          const { scrollbar: i, $wrapperEl: a } = t,
            { $el: n, $dragEl: r } = i;
          h &&
            (e.preventDefault ? e.preventDefault() : (e.returnValue = !1),
            x(e),
            a.transition(0),
            n.transition(0),
            r.transition(0),
            s("scrollbarDragMove", e));
        }
        function w(e) {
          const i = t.params.scrollbar,
            { scrollbar: a, $wrapperEl: n } = t,
            { $el: r } = a;
          h &&
            ((h = !1),
            t.params.cssMode && (t.$wrapperEl.css("scroll-snap-type", ""), n.transition("")),
            i.hide &&
              (clearTimeout(u),
              (u = v(() => {
                r.css("opacity", 0), r.transition(400);
              }, 1e3))),
            s("scrollbarDragEnd", e),
            i.snapOnRelease && t.slideToClosest());
        }
        function k(e) {
          const { scrollbar: i, touchEventsTouch: s, touchEventsDesktop: n, params: r, support: o } = t,
            l = i.$el;
          if (!l) return;
          const c = l[0],
            h = !(!o.passiveListener || !r.passiveListeners) && { passive: !1, capture: !1 },
            d = !(!o.passiveListener || !r.passiveListeners) && { passive: !0, capture: !1 };
          if (!c) return;
          const u = "on" === e ? "addEventListener" : "removeEventListener";
          o.touch
            ? (c[u](s.start, b, h), c[u](s.move, y, h), c[u](s.end, w, d))
            : (c[u](n.start, b, h), a[u](n.move, y, h), a[u](n.end, w, d));
        }
        function S() {
          const { scrollbar: e, $el: i } = t;
          t.params.scrollbar = (function (t, e, i, s) {
            const a = r();
            return (
              t.params.createElements &&
                Object.keys(s).forEach((n) => {
                  if (!i[n] && !0 === i.auto) {
                    let r = t.$el.children(`.${s[n]}`)[0];
                    r || ((r = a.createElement("div")), (r.className = s[n]), t.$el.append(r)), (i[n] = r), (e[n] = r);
                  }
                }),
              i
            );
          })(t, t.originalParams.scrollbar, t.params.scrollbar, { el: "swiper-scrollbar" });
          const s = t.params.scrollbar;
          if (!s.el) return;
          let a = m(s.el);
          t.params.uniqueNavElements &&
            "string" == typeof s.el &&
            a.length > 1 &&
            1 === i.find(s.el).length &&
            (a = i.find(s.el)),
            a.addClass(t.isHorizontal() ? s.horizontalClass : s.verticalClass);
          let n = a.find(`.${t.params.scrollbar.dragClass}`);
          0 === n.length && ((n = m(`<div class="${t.params.scrollbar.dragClass}"></div>`)), a.append(n)),
            Object.assign(e, { $el: a, el: a[0], $dragEl: n, dragEl: n[0] }),
            s.draggable && t.params.scrollbar.el && t.scrollbar.el && k("on"),
            a && a[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass);
        }
        function C() {
          const e = t.params.scrollbar,
            i = t.scrollbar.$el;
          i && i.removeClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass),
            t.params.scrollbar.el && t.scrollbar.el && k("off");
        }
        e({
          scrollbar: {
            el: null,
            dragSize: "auto",
            hide: !1,
            draggable: !1,
            snapOnRelease: !0,
            lockClass: "swiper-scrollbar-lock",
            dragClass: "swiper-scrollbar-drag",
            scrollbarDisabledClass: "swiper-scrollbar-disabled",
            horizontalClass: "swiper-scrollbar-horizontal",
            verticalClass: "swiper-scrollbar-vertical",
          },
        }),
          (t.scrollbar = { el: null, dragEl: null, $el: null, $dragEl: null }),
          i("init", () => {
            !1 === t.params.scrollbar.enabled ? A() : (S(), g(), p());
          }),
          i("update resize observerUpdate lock unlock", () => {
            g();
          }),
          i("setTranslate", () => {
            p();
          }),
          i("setTransition", (e, i) => {
            !(function (e) {
              t.params.scrollbar.el && t.scrollbar.el && t.scrollbar.$dragEl.transition(e);
            })(i);
          }),
          i("enable disable", () => {
            const { $el: e } = t.scrollbar;
            e && e[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass);
          }),
          i("destroy", () => {
            C();
          });
        const A = () => {
          t.$el.addClass(t.params.scrollbar.scrollbarDisabledClass),
            t.scrollbar.$el && t.scrollbar.$el.addClass(t.params.scrollbar.scrollbarDisabledClass),
            C();
        };
        Object.assign(t.scrollbar, {
          enable: () => {
            t.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass),
              t.scrollbar.$el && t.scrollbar.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass),
              S(),
              g(),
              p();
          },
          disable: A,
          updateSize: g,
          setTranslate: p,
          init: S,
          destroy: C,
        });
      }
      function Z({ swiper: t, extendParams: e, on: i, emit: s }) {
        e({
          lazy: {
            checkInView: !1,
            enabled: !1,
            loadPrevNext: !1,
            loadPrevNextAmount: 1,
            loadOnTransitionStart: !1,
            scrollingElement: "",
            elementClass: "swiper-lazy",
            loadingClass: "swiper-lazy-loading",
            loadedClass: "swiper-lazy-loaded",
            preloaderClass: "swiper-lazy-preloader",
          },
        }),
          (t.lazy = {});
        let a = !1,
          n = !1;
        function r(e, i = !0) {
          const a = t.params.lazy;
          if (void 0 === e) return;
          if (0 === t.slides.length) return;
          const n =
              t.virtual && t.params.virtual.enabled
                ? t.$wrapperEl.children(`.${t.params.slideClass}[data-swiper-slide-index="${e}"]`)
                : t.slides.eq(e),
            o = n.find(`.${a.elementClass}:not(.${a.loadedClass}):not(.${a.loadingClass})`);
          !n.hasClass(a.elementClass) || n.hasClass(a.loadedClass) || n.hasClass(a.loadingClass) || o.push(n[0]),
            0 !== o.length &&
              o.each((e) => {
                const o = m(e);
                o.addClass(a.loadingClass);
                const l = o.attr("data-background"),
                  c = o.attr("data-src"),
                  h = o.attr("data-srcset"),
                  d = o.attr("data-sizes"),
                  u = o.parent("picture");
                t.loadImage(o[0], c || l, h, d, !1, () => {
                  if (null != t && t && (!t || t.params) && !t.destroyed) {
                    if (
                      (l
                        ? (o.css("background-image", `url("${l}")`), o.removeAttr("data-background"))
                        : (h && (o.attr("srcset", h), o.removeAttr("data-srcset")),
                          d && (o.attr("sizes", d), o.removeAttr("data-sizes")),
                          u.length &&
                            u.children("source").each((t) => {
                              const e = m(t);
                              e.attr("data-srcset") &&
                                (e.attr("srcset", e.attr("data-srcset")), e.removeAttr("data-srcset"));
                            }),
                          c && (o.attr("src", c), o.removeAttr("data-src"))),
                      o.addClass(a.loadedClass).removeClass(a.loadingClass),
                      n.find(`.${a.preloaderClass}`).remove(),
                      t.params.loop && i)
                    ) {
                      const e = n.attr("data-swiper-slide-index");
                      n.hasClass(t.params.slideDuplicateClass)
                        ? r(
                            t.$wrapperEl
                              .children(`[data-swiper-slide-index="${e}"]:not(.${t.params.slideDuplicateClass})`)
                              .index(),
                            !1
                          )
                        : r(
                            t.$wrapperEl
                              .children(`.${t.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`)
                              .index(),
                            !1
                          );
                    }
                    s("lazyImageReady", n[0], o[0]), t.params.autoHeight && t.updateAutoHeight();
                  }
                }),
                  s("lazyImageLoad", n[0], o[0]);
              });
        }
        function o() {
          const { $wrapperEl: e, params: i, slides: s, activeIndex: a } = t,
            o = t.virtual && i.virtual.enabled,
            l = i.lazy;
          let c = i.slidesPerView;
          function h(t) {
            if (o) {
              if (e.children(`.${i.slideClass}[data-swiper-slide-index="${t}"]`).length) return !0;
            } else if (s[t]) return !0;
            return !1;
          }
          function d(t) {
            return o ? m(t).attr("data-swiper-slide-index") : m(t).index();
          }
          if (("auto" === c && (c = 0), n || (n = !0), t.params.watchSlidesProgress))
            e.children(`.${i.slideVisibleClass}`).each((t) => {
              r(o ? m(t).attr("data-swiper-slide-index") : m(t).index());
            });
          else if (c > 1) for (let t = a; t < a + c; t += 1) h(t) && r(t);
          else r(a);
          if (l.loadPrevNext)
            if (c > 1 || (l.loadPrevNextAmount && l.loadPrevNextAmount > 1)) {
              const t = l.loadPrevNextAmount,
                e = Math.ceil(c),
                i = Math.min(a + e + Math.max(t, e), s.length),
                n = Math.max(a - Math.max(e, t), 0);
              for (let t = a + e; t < i; t += 1) h(t) && r(t);
              for (let t = n; t < a; t += 1) h(t) && r(t);
            } else {
              const t = e.children(`.${i.slideNextClass}`);
              t.length > 0 && r(d(t));
              const s = e.children(`.${i.slidePrevClass}`);
              s.length > 0 && r(d(s));
            }
        }
        function c() {
          const e = l();
          if (!t || t.destroyed) return;
          const i = t.params.lazy.scrollingElement ? m(t.params.lazy.scrollingElement) : m(e),
            s = i[0] === e,
            n = s ? e.innerWidth : i[0].offsetWidth,
            r = s ? e.innerHeight : i[0].offsetHeight,
            h = t.$el.offset(),
            { rtlTranslate: d } = t;
          let u = !1;
          d && (h.left -= t.$el[0].scrollLeft);
          const p = [
            [h.left, h.top],
            [h.left + t.width, h.top],
            [h.left, h.top + t.height],
            [h.left + t.width, h.top + t.height],
          ];
          for (let t = 0; t < p.length; t += 1) {
            const e = p[t];
            if (e[0] >= 0 && e[0] <= n && e[1] >= 0 && e[1] <= r) {
              if (0 === e[0] && 0 === e[1]) continue;
              u = !0;
            }
          }
          const g = !(
            "touchstart" !== t.touchEvents.start ||
            !t.support.passiveListener ||
            !t.params.passiveListeners
          ) && { passive: !0, capture: !1 };
          u ? (o(), i.off("scroll", c, g)) : a || ((a = !0), i.on("scroll", c, g));
        }
        i("beforeInit", () => {
          t.params.lazy.enabled && t.params.preloadImages && (t.params.preloadImages = !1);
        }),
          i("init", () => {
            t.params.lazy.enabled && (t.params.lazy.checkInView ? c() : o());
          }),
          i("scroll", () => {
            t.params.freeMode && t.params.freeMode.enabled && !t.params.freeMode.sticky && o();
          }),
          i("scrollbarDragMove resize _freeModeNoMomentumRelease", () => {
            t.params.lazy.enabled && (t.params.lazy.checkInView ? c() : o());
          }),
          i("transitionStart", () => {
            t.params.lazy.enabled &&
              (t.params.lazy.loadOnTransitionStart || (!t.params.lazy.loadOnTransitionStart && !n)) &&
              (t.params.lazy.checkInView ? c() : o());
          }),
          i("transitionEnd", () => {
            t.params.lazy.enabled && !t.params.lazy.loadOnTransitionStart && (t.params.lazy.checkInView ? c() : o());
          }),
          i("slideChange", () => {
            const {
              lazy: e,
              cssMode: i,
              watchSlidesProgress: s,
              touchReleaseOnEdges: a,
              resistanceRatio: n,
            } = t.params;
            e.enabled && (i || (s && (a || 0 === n))) && o();
          }),
          i("destroy", () => {
            t.$el && t.$el.find(`.${t.params.lazy.loadingClass}`).removeClass(t.params.lazy.loadingClass);
          }),
          Object.assign(t.lazy, { load: o, loadInSlide: r });
      }
      function K({ swiper: t, extendParams: e, on: i, emit: s }) {
        let a;
        function n() {
          if (!t.size) return (t.autoplay.running = !1), void (t.autoplay.paused = !1);
          const e = t.slides.eq(t.activeIndex);
          let i = t.params.autoplay.delay;
          e.attr("data-swiper-autoplay") && (i = e.attr("data-swiper-autoplay") || t.params.autoplay.delay),
            clearTimeout(a),
            (a = v(() => {
              let e;
              t.params.autoplay.reverseDirection
                ? t.params.loop
                  ? (t.loopFix(), (e = t.slidePrev(t.params.speed, !0, !0)), s("autoplay"))
                  : t.isBeginning
                  ? t.params.autoplay.stopOnLastSlide
                    ? l()
                    : ((e = t.slideTo(t.slides.length - 1, t.params.speed, !0, !0)), s("autoplay"))
                  : ((e = t.slidePrev(t.params.speed, !0, !0)), s("autoplay"))
                : t.params.loop
                ? (t.loopFix(), (e = t.slideNext(t.params.speed, !0, !0)), s("autoplay"))
                : t.isEnd
                ? t.params.autoplay.stopOnLastSlide
                  ? l()
                  : ((e = t.slideTo(0, t.params.speed, !0, !0)), s("autoplay"))
                : ((e = t.slideNext(t.params.speed, !0, !0)), s("autoplay")),
                ((t.params.cssMode && t.autoplay.running) || !1 === e) && n();
            }, i));
        }
        function o() {
          return void 0 === a && !t.autoplay.running && ((t.autoplay.running = !0), s("autoplayStart"), n(), !0);
        }
        function l() {
          return (
            !!t.autoplay.running &&
            void 0 !== a &&
            (a && (clearTimeout(a), (a = void 0)), (t.autoplay.running = !1), s("autoplayStop"), !0)
          );
        }
        function c(e) {
          t.autoplay.running &&
            (t.autoplay.paused ||
              (a && clearTimeout(a),
              (t.autoplay.paused = !0),
              0 !== e && t.params.autoplay.waitForTransition
                ? ["transitionend", "webkitTransitionEnd"].forEach((e) => {
                    t.$wrapperEl[0].addEventListener(e, d);
                  })
                : ((t.autoplay.paused = !1), n())));
        }
        function h() {
          const e = r();
          "hidden" === e.visibilityState && t.autoplay.running && c(),
            "visible" === e.visibilityState && t.autoplay.paused && (n(), (t.autoplay.paused = !1));
        }
        function d(e) {
          t &&
            !t.destroyed &&
            t.$wrapperEl &&
            e.target === t.$wrapperEl[0] &&
            (["transitionend", "webkitTransitionEnd"].forEach((e) => {
              t.$wrapperEl[0].removeEventListener(e, d);
            }),
            (t.autoplay.paused = !1),
            t.autoplay.running ? n() : l());
        }
        function u() {
          t.params.autoplay.disableOnInteraction ? l() : (s("autoplayPause"), c()),
            ["transitionend", "webkitTransitionEnd"].forEach((e) => {
              t.$wrapperEl[0].removeEventListener(e, d);
            });
        }
        function p() {
          t.params.autoplay.disableOnInteraction || ((t.autoplay.paused = !1), s("autoplayResume"), n());
        }
        (t.autoplay = { running: !1, paused: !1 }),
          e({
            autoplay: {
              enabled: !1,
              delay: 3e3,
              waitForTransition: !0,
              disableOnInteraction: !0,
              stopOnLastSlide: !1,
              reverseDirection: !1,
              pauseOnMouseEnter: !1,
            },
          }),
          i("init", () => {
            t.params.autoplay.enabled &&
              (o(),
              r().addEventListener("visibilitychange", h),
              t.params.autoplay.pauseOnMouseEnter && (t.$el.on("mouseenter", u), t.$el.on("mouseleave", p)));
          }),
          i("beforeTransitionStart", (e, i, s) => {
            t.autoplay.running && (s || !t.params.autoplay.disableOnInteraction ? t.autoplay.pause(i) : l());
          }),
          i("sliderFirstMove", () => {
            t.autoplay.running && (t.params.autoplay.disableOnInteraction ? l() : c());
          }),
          i("touchEnd", () => {
            t.params.cssMode && t.autoplay.paused && !t.params.autoplay.disableOnInteraction && n();
          }),
          i("destroy", () => {
            t.$el.off("mouseenter", u),
              t.$el.off("mouseleave", p),
              t.autoplay.running && l(),
              r().removeEventListener("visibilitychange", h);
          }),
          Object.assign(t.autoplay, { pause: c, run: n, start: o, stop: l });
      }
    },
    478: function (t, e, i) {
      "use strict";
      i.d(e, {
        ZP: function () {
          return L;
        },
      });
      const s = new Set(),
        a = new WeakMap(),
        n = new WeakMap(),
        r = new WeakMap(),
        o = new WeakMap(),
        l = new WeakMap(),
        c = new WeakMap(),
        h = new WeakMap(),
        d = new WeakSet();
      let u;
      const p = "__aa_tgt",
        g = "__aa_del";
      function f(t) {
        clearTimeout(h.get(t));
        const e = C(t),
          i = "function" == typeof e ? 500 : e.duration;
        h.set(
          t,
          setTimeout(async () => {
            const e = r.get(t);
            (e && !(await e.finished)) ||
              (a.set(t, k(t)),
              (function (t) {
                const e = o.get(t);
                null == e || e.disconnect();
                let i = a.get(t),
                  s = 0;
                i || ((i = k(t)), a.set(t, i));
                const { offsetWidth: n, offsetHeight: r } = u,
                  l = [i.top - 5, n - (i.left + 5 + i.width), r - (i.top + 5 + i.height), i.left - 5]
                    .map((t) => -1 * Math.floor(t) + "px")
                    .join(" "),
                  c = new IntersectionObserver(
                    () => {
                      ++s > 1 && f(t);
                    },
                    { root: u, threshold: 1, rootMargin: l }
                  );
                c.observe(t), o.set(t, c);
              })(t));
          }, i)
        );
      }
      function m(t) {
        setTimeout(() => {
          l.set(
            t,
            setInterval(() => v(f.bind(null, t)), 2e3)
          );
        }, Math.round(2e3 * Math.random()));
      }
      function v(t) {
        "function" == typeof requestIdleCallback ? requestIdleCallback(() => t()) : requestAnimationFrame(() => t());
      }
      let x, b;
      function y(t, e) {
        e || p in t
          ? e && !(p in e) && Object.defineProperty(e, p, { value: t })
          : Object.defineProperty(t, p, { value: t });
      }
      function w(t) {
        return Number(t.replace(/[^0-9.\-]/g, ""));
      }
      function k(t) {
        const e = t.getBoundingClientRect();
        return { top: e.top + window.scrollY, left: e.left + window.scrollX, width: e.width, height: e.height };
      }
      function S(t, e, i) {
        let s = e.width,
          a = e.height,
          n = i.width,
          r = i.height;
        const o = getComputedStyle(t);
        if ("content-box" === o.getPropertyValue("box-sizing")) {
          const t = w(o.paddingTop) + w(o.paddingBottom) + w(o.borderTopWidth) + w(o.borderBottomWidth),
            e = w(o.paddingLeft) + w(o.paddingRight) + w(o.borderRightWidth) + w(o.borderLeftWidth);
          (s -= e), (n -= e), (a -= t), (r -= t);
        }
        return [s, n, a, r].map(Math.round);
      }
      function C(t) {
        return p in t && c.has(t[p]) ? c.get(t[p]) : { duration: 250, easing: "ease-in-out" };
      }
      function A(t) {
        if (p in t) return t[p];
      }
      function E(t) {
        const e = A(t);
        return !!e && d.has(e);
      }
      function T(t, ...e) {
        e.forEach((e) => e(t, c.has(t)));
        for (let i = 0; i < t.children.length; i++) {
          const s = t.children.item(i);
          s && e.forEach((t) => t(s, c.has(s)));
        }
      }
      function L(t, e = {}) {
        return (
          x &&
            b &&
            ((window.matchMedia("(prefers-reduced-motion: reduce)").matches &&
              "function" != typeof e &&
              !e.disrespectUserMotionPreference) ||
              (d.add(t),
              "static" === getComputedStyle(t).position && Object.assign(t.style, { position: "relative" }),
              T(t, f, m, (t) => (null == b ? void 0 : b.observe(t))),
              "function" == typeof e ? c.set(t, e) : c.set(t, { duration: 250, easing: "ease-in-out", ...e }),
              x.observe(t, { childList: !0 }),
              s.add(t))),
          Object.freeze({
            parent: t,
            enable: () => {
              d.add(t);
            },
            disable: () => {
              d.delete(t);
            },
            isEnabled: () => d.has(t),
          })
        );
      }
      "undefined" != typeof window &&
        ((u = document.documentElement),
        (x = new MutationObserver((t) => {
          const e = (function (t) {
            return (
              !t
                .reduce((t, e) => [...t, ...Array.from(e.addedNodes), ...Array.from(e.removedNodes)], [])
                .every((t) => "#comment" === t.nodeName) &&
              t.reduce((t, e) => {
                if (!1 === t) return !1;
                if (e.target instanceof Element) {
                  if ((y(e.target), !t.has(e.target))) {
                    t.add(e.target);
                    for (let i = 0; i < e.target.children.length; i++) {
                      const s = e.target.children.item(i);
                      if (s) {
                        if (g in s) return !1;
                        y(e.target, s), t.add(s);
                      }
                    }
                  }
                  if (e.removedNodes.length)
                    for (let i = 0; i < e.removedNodes.length; i++) {
                      const s = e.removedNodes[i];
                      if (g in s) return !1;
                      s instanceof Element && (t.add(s), y(e.target, s), n.set(s, [e.previousSibling, e.nextSibling]));
                    }
                }
                return t;
              }, new Set())
            );
          })(t);
          e &&
            e.forEach((t) =>
              (function (t) {
                var e;
                const i = u.contains(t),
                  s = a.has(t);
                i && n.has(t) && n.delete(t),
                  r.has(t) && (null === (e = r.get(t)) || void 0 === e || e.cancel()),
                  s && i
                    ? (function (t) {
                        const e = a.get(t),
                          i = k(t);
                        if (!E(t)) return a.set(t, i);
                        let s;
                        if (!e) return;
                        const n = C(t);
                        if ("function" != typeof n) {
                          const a = e.left - i.left,
                            r = e.top - i.top,
                            [o, l, c, h] = S(t, e, i),
                            d = { transform: `translate(${a}px, ${r}px)` },
                            u = { transform: "translate(0, 0)" };
                          o !== l && ((d.width = `${o}px`), (u.width = `${l}px`)),
                            c !== h && ((d.height = `${c}px`), (u.height = `${h}px`)),
                            (s = t.animate([d, u], { duration: n.duration, easing: n.easing }));
                        } else (s = new Animation(n(t, "remain", e, i))), s.play();
                        r.set(t, s), a.set(t, i), s.addEventListener("finish", f.bind(null, t));
                      })(t)
                    : s && !i
                    ? (function (t) {
                        var e;
                        if (!n.has(t) || !a.has(t)) return;
                        const [i, s] = n.get(t);
                        function l() {
                          var e;
                          t.remove(),
                            a.delete(t),
                            n.delete(t),
                            r.delete(t),
                            null === (e = o.get(t)) || void 0 === e || e.disconnect();
                        }
                        if (
                          (Object.defineProperty(t, g, { value: !0 }),
                          s && s.parentNode && s.parentNode instanceof Element
                            ? s.parentNode.insertBefore(t, s)
                            : i && i.parentNode
                            ? i.parentNode.appendChild(t)
                            : null === (e = A(t)) || void 0 === e || e.appendChild(t),
                          !E(t))
                        )
                          return l();
                        const [c, h, d, u] = (function (t) {
                            const e = a.get(t),
                              [i, , s] = S(t, e, k(t));
                            let n = t.parentElement;
                            for (; n && ("static" === getComputedStyle(n).position || n instanceof HTMLBodyElement); )
                              n = n.parentElement;
                            n || (n = document.body);
                            const r = getComputedStyle(n),
                              o = a.get(n) || k(n);
                            return [
                              Math.round(e.top - o.top) - w(r.borderTopWidth),
                              Math.round(e.left - o.left) - w(r.borderLeftWidth),
                              i,
                              s,
                            ];
                          })(t),
                          p = C(t),
                          f = a.get(t);
                        let m;
                        Object.assign(t.style, {
                          position: "absolute",
                          top: `${c}px`,
                          left: `${h}px`,
                          width: `${d}px`,
                          height: `${u}px`,
                          margin: 0,
                          pointerEvents: "none",
                          transformOrigin: "center",
                          zIndex: 100,
                        }),
                          "function" != typeof p
                            ? (m = t.animate(
                                [
                                  { transform: "scale(1)", opacity: 1 },
                                  { transform: "scale(.98)", opacity: 0 },
                                ],
                                { duration: p.duration, easing: "ease-out" }
                              ))
                            : ((m = new Animation(p(t, "remove", f))), m.play()),
                          r.set(t, m),
                          m.addEventListener("finish", l);
                      })(t)
                    : (function (t) {
                        const e = k(t);
                        a.set(t, e);
                        const i = C(t);
                        if (!E(t)) return;
                        let s;
                        "function" != typeof i
                          ? (s = t.animate(
                              [
                                { transform: "scale(.98)", opacity: 0 },
                                { transform: "scale(0.98)", opacity: 0, offset: 0.5 },
                                { transform: "scale(1)", opacity: 1 },
                              ],
                              { duration: 1.5 * i.duration, easing: "ease-in" }
                            ))
                          : ((s = new Animation(i(t, "add", e))), s.play()),
                          r.set(t, s),
                          s.addEventListener("finish", f.bind(null, t));
                      })(t);
              })(t)
            );
        })),
        (b = new ResizeObserver((t) => {
          t.forEach((t) => {
            t.target === u &&
              (clearTimeout(h.get(u)),
              h.set(
                u,
                setTimeout(() => {
                  s.forEach((t) => T(t, (t) => v(() => f(t))));
                }, 100)
              )),
              a.has(t.target) && f(t.target);
          });
        })),
        b.observe(u));
    },
  },
]);
